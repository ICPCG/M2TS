{
    "321": "\tpublic int getPushesLowerbound() {\n\t\treturn pushesLowerbound;\n\t}\n",
    "323": "\tpublic void setPushesLowerbound(int pushesLowerbound) {\n\t\tthis.pushesLowerbound = pushesLowerbound;\n\t}\n",
    "324": "\t\tpublic void play() {\n\t\t\t\n\t\t\t// If no sound file is there nothing can be played.\n\t\t\tif(currentSoundFilename.equals(\"\"))\n\t\t\t\treturn;\n\t\t\t\n\t\t\t// Check if the this sound must be read from another file (the user has\n\t\t\t// chosen another sound to be played).\n\t\t\tString settingsFileName = Settings.get(soundSettingsKey);\n\t\t\tif(!currentSoundFilename.equals(settingsFileName)) {\n\t\t\t\tloadClip(settingsFileName);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// Stop the currently playing sound to play the new sound if necessary.\n\t\t\tif (clip.isRunning()) {\n\t\t\t\tclip.stop();\n\t\t\t}\n\t\t\t\n\t\t\t// Rewind to the beginning.\n\t\t\tclip.setFramePosition(0); \n\t\t\t\n\t\t\t// Start playing.\n\t\t\tclip.start();    \n\t\t}\n",
    "343": "\tpublic int getInfluenceValue(int boxNo1, int boxNo2) {\n\t\treturn influence.getInfluenceDistance( board.boxData.getBoxPosition(boxNo1),\n\t\t\t\t                               board.boxData.getBoxPosition(boxNo2) );\n\t}\n",
    "351": "\tpublic void setPositions(int[] positions){\n\t\tthis.positions = positions;\n\t}\n",
    "352": "\tpublic int getPlayerPosition() {\n\t\treturn positions[positions.length-1];\n\t}\n",
    "355": "\tpublic int getPulledBoxNumber() {\n\t\treturn pulledBoxNo;\n\t}\n",
    "357": "\tpublic int getStartBoxPosition() {\n\t\treturn startPosition;\n\t}\n",
    "359": "\tpublic int getTargetBoxPosition() {\n\t\treturn targetPosition;\n\t}\n",
    "361": "    public BoardPositionPackingSequence getPrecedingBoardPosition() {\n    \treturn precedingBoardPosition;\n    }\n",
    "364": "\tpublic int compareTo(BoardPositionPackingSequence boardPosition) {\n\t\treturn boardPosition.getRelevance() - getRelevance();\n\t}\n",
    "373": "\tpublic boolean isForcedPush() {\n\t\treturn isPushForced;\n\t}\n",
    "376": "\tfinal public void setInfoText(String text) {\n\t\tinfoText.setText(text);\n\t}\n",
    "412": "\tpublic boolean isSolverStoppedDueToOutOfMemory() {\n\t\treturn isSolverStoppedDueToOutOfMemory;\n\t}\n",
    "428": "    final protected IBoardPositionMoves getBestBoardPosition(){\n\n\t\t// Nimmt die Liste aller Stellungen mit einer bestimmten L\u00f6sungspfadl\u00e4nge auf\n\t\tLinkedList<IBoardPositionMoves> boardPositionList;\n\t\t\n\t\tfor(int solutionLength = shortestSolutionPathLength; solutionLength <= longestSolutionPathLength; solutionLength++) {\n\t\t\n\t\t\t// Liste der Stellungen mit der aktuellen Pfadl\u00e4nge holen. \n\t\t\tboardPositionList = boardPositionQueue.get(solutionLength);\n\t\t\t\n\t\t\tif(boardPositionList.size() > 0){\t \n\t\t\t    shortestSolutionPathLength = solutionLength;\n\t\t\t    \n\t\t\t\t// Die zuletzt eingef\u00fcgte Stellung zur\u00fcckgeben\n\t    \t\treturn boardPositionList.removeLast();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "437": "\tfinal public IBoardPosition getPrecedingBoardPosition() {\n\t\treturn precedingBoardPosition;\n\t}\n",
    "440": "\tfinal public int getDirection() {\n\t\treturn positionData >>> 13;\n\t}\n",
    "442": "\tpublic int getBoxNo() {\n\t\treturn positionData & ((1 << 10) - 1);\n\t}\n",
    "445": "\tprotected String creatorName() {\n\t\treturn Texts.getText(\"solver\");\n\t}\n",
    "446": "\tfinal public int getPlayerPosition() {\n\t\treturn playerPosition;\n\t}\n",
    "448": "\tfinal public void setPositions(int[] positions) {\n\t\tthis.positions = positions;\n\t}\n",
    "450": "\tfinal public IBoardPosition getPrecedingBoardPosition() {\n\t\treturn null;\n\t}\n",
    "454": "\tfinal public void setSearchDirection(SearchDirection searchDirection) {\n\n\t\tif (searchDirection == SearchDirection.FORWARD) {\n\t\t\tforwardsSearch  = true;\n\t\t} else {\n\t\t\tbackwardsSearch = true;\n\t\t}\n\t}\n",
    "458": "\tfinal public int getDirection() {\n\t\treturn 0;\n\t}\n",
    "459": "\tpublic int getPushesCount() {\n\n\t\tint pushesCount = 0;\n\n\t\tfor (BoardPosition currentBoardPosition = this; currentBoardPosition\n\t\t\t\t.getPrecedingBoardPosition() != null; currentBoardPosition = (BoardPosition) currentBoardPosition\n\t\t\t\t.getPrecedingBoardPosition()) {\n\t\t\tif (currentBoardPosition.getBoxNo() != NO_BOX_PUSHED) {\n\t\t\t\tpushesCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn pushesCount;\n\t}\n",
    "461": "\tfinal public int getBoxNo() {\n\t\treturn NO_BOX_PUSHED;\n\t}\n",
    "463": "\tpublic void setMaximumSolutionLength(short maximumSolutionLength) {\n\t\tmaximumPushesCurrentIteration = maximumSolutionLength;\n\t}\n",
    "464": "\tfinal public int getPlayerPosition() {\n\t\treturn positions[boxCount];\n\t}\n",
    "466": "\tpublic short getMaximumSolutionLength() {\n\t\treturn maximumPushesCurrentIteration;\n\t}\n",
    "467": "\tfinal public int getPushesCount() {\n\t\treturn 0;\n\t}\n",
    "472": "\tprotected String solutionByMeAt(Date date) {\n\t\treturn  Texts.getText(\"createdBy\")\n\t\t      + \" \" + creatorName()\n\t\t      + \" \" + Utilities.dateString(date);\n\t}\n",
    "476": "\tfinal public void setMovesCount(int movesCount) {\n\t\tthis.movesCount = (short) movesCount;\n\t}\n",
    "487": "\tpublic int getIndexPackingSequence() {\n\t\treturn indexPackingSequence;\n\t}\n",
    "489": "\tpublic void setIndexPackingSequence(int indexPackingSequence) {\n\t\tthis.indexPackingSequence = indexPackingSequence;\n\t}\n",
    "494": "\tprotected boolean isBoxInactive(int boxNo) {\n\t\treturn isBoxInactive[boxNo];\n\t}\n",
    "496": "\tfinal public boolean isBoxInactive() {\n\t\treturn (positionData & INACTIVE_BOX) > 0;\n\t}\n",
    "497": "\tpublic void setCorralDeadlock() {\n\t\tisDeadlock = true;\n\t}\n",
    "498": "\tpublic void setNotCorralDeadlock() {\n\t\tisNotDeadlock = true;\n\t}\n",
    "499": "\t\tpublic boolean getValue() {\n\t\t\t/*\n\t\t\t * Since we here are inside of class Settings, we should not get\n\t\t\t * an IllegalAccessException.\n\t\t\t * Hence, we catch the exceptions here, and return false,\n\t\t\t * just in case.\n\t\t\t */\n\t\t\ttry {\n\t\t\t\treturn field.getBoolean(null);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n",
    "500": "\tprotected String solutionByMeNow() {\n\t\treturn solutionByMeAt(null);\n\t}\n",
    "501": "\tpublic void setCorralNo(int corralNo) {\n\t\tthis.corralNo = corralNo;\n\t}\n",
    "503": "\tpublic void setInfoText(String text) {\n\t\tinfoText.setText(text);\n\t}\n",
    "504": "\tpublic int getCorralNo() {\n\t\treturn corralNo;\n\t}\n",
    "506": "\tpublic boolean isCorralDeadlock() {\n\t\treturn isDeadlock;\n\t}\n",
    "507": "\tpublic boolean isNotCorralDeadlock() {\n\t\treturn isNotDeadlock;\n\t}\n",
    "508": "\tpublic boolean isClassified() {\n\t\treturn isDeadlock || isNotDeadlock;\n\t}\n",
    "510": "\tpublic boolean isBeeingAnalyzed() {\n\t\treturn !isDeadlock && !isNotDeadlock;\n\t}\n",
    "513": "\tpublic CBoard getClone() {\n\t\treturn new CBoard(boardElements.clone(), width, height, playerPositionX, playerPositionY);\n\t}\n",
    "514": "\t\tpublic void setValue(boolean value) {\n\t\t\t/*\n\t\t\t * Regarding exceptions see comment in \"getValue\"\n\t\t\t */\n\t\t\ttry {\n\t\t\t\tfield.setBoolean(null, value);\n\t\t\t\tSystem.out.println(\"Setting: DebugVar: \"+field.getName()+\" set to \"+value);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t// well... forget it.\n\t\t}\n",
    "517": "\tprivate boolean isEqual(int boxConfigurationNumber, byte[] boxConfiguration) {\n\t\t\n\t\tint indexOfBoxConfiguration = boxConfigurationNumber * packedBoardByteSize;\n\t\t\n\t\t// Compare byte by byte of both box configurations.\n\t\tfor(int byteNo=0; byteNo < boxConfiguration.length; byteNo++) {\n\t\t\tif (boxConfigurations[indexOfBoxConfiguration++] != boxConfiguration[byteNo]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n",
    "523": "\tpublic int getMaxCapacity() {\n\t\treturn maxCapacity;\n\t}\n",
    "524": "\tpublic void add(int boardPositionIndex, int boardPositionPredecessor) {\n\t\t\n\t\t// The moves queue also contains an arbitrary number of span markers.\n\t\t// Therefore after every added board position there must be done\n\t\t// a check whether the memory block is already full.\n\t\tadd(boardPositionIndex      );\n\t\tadd(boardPositionPredecessor);\n\t}\n",
    "531": "\tpublic void jumpOverBoardPosition(int boardPosition) {\n\t\n\t\t// \"Remove\" all values from the queue which are equal to the passed one\n\t\t// FFS/hm: does the caller guarantee that the Q cannot become empty by this?\n\t\twhile(memoryBlockToRead.memory[nextIndexToRead] == boardPosition) {\n\t\t\tremoveBoardPosition();\n\t\t}\n\t}\n",
    "535": "\tpublic int removeLastBoardPosition() {\n\t\t\t\t\t\t\n\t\tif(nextIndexToWrite == 0) {\n\t\t\t\n\t\t\t// The previous memory block becomes the new current memory block.\n\t\t\tmemoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;\n\t\t\tnextIndexToWrite = MEMORY_BLOCK_SIZE;\n\t\t}\n\t\t\n\t\treturn memoryBlockToWrite.memory[--nextIndexToWrite];\n\t}\n",
    "538": "\tpublic void jumpXBoardPositionsBackwards(int jumpCount) {\n\t\t\n\t\twhile(jumpCount > nextIndexToWrite) {\n\t\t\t\t\t\t\t\n\t\t\t// Assign the previous memory block of the queue.\n\t\t\tmemoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;\n\t\t\t\n\t\t\tjumpCount -= nextIndexToWrite;\n\t\t\tnextIndexToWrite = MEMORY_BLOCK_SIZE;\t\t\t\t\t\n\t\t}\n\t\tnextIndexToWrite -= jumpCount;\n\t}\n",
    "542": "\tpublic boolean isEmpty() {\n\t\t// This method is only called for the moves queue which has recycling activated.\n\t\treturn memoryBlockToRead == memoryBlockToWrite\n\t\t    && nextIndexToRead   == nextIndexToWrite;\n\t}\n",
    "547": "\tpublic boolean isGenerationStoppedDueToFullStorage() {\n\t\treturn generationStoppedDueToFullStorage;\n\t}\n",
    "551": "\tpublic int getBoxConfigurationNumber() {\n\t\treturn uniqueBoxConfigurationNumber;\n\t}\n",
    "561": "\tpublic boolean isBetterMovesPushesThan( OptimizerSolution other ) {\n\t\tif (other == null) {\n\t\t\treturn true;\t\t\t// everybody is better than nobody\n\t\t}\n\t\treturn Utilities.intCompare2Pairs( movesCount , other.movesCount,\n\t\t                                   pushesCount, other.pushesCount )\n\t\t     < 0 ;\n\t}\n",
    "563": "\tpublic boolean isBetterPushesMovesThan( OptimizerSolution other ) {\n\t\tif (other == null) {\n\t\t\treturn true;\t\t\t// everybody is better than nobody\n\t\t}\n\t\treturn Utilities.intCompare2Pairs( pushesCount, other.pushesCount,\n\t\t                                   movesCount , other.movesCount  )\n\t\t     < 0 ;\n\t}\n",
    "568": "\tpublic void add(OptimizerBoardPosition boardPosition) {\n\n\t\t// Ensure that a real board position has been passed.\n        if (boardPosition == null)\n            throw new NullPointerException();\n\t\t\n\t\t// Double the size of the queue if it is full.\n\t\tif (count >= queue.length) {\n\t\t\tqueue = Arrays.copyOf(queue, queue.length * 2);\t\n\t\t}\t\t\n\t\t\n\t\t// Add the new value at the correct position. \n\t\tsiftUp(count, boardPosition);\n\t\t\n\t\t// One more board position has been stored => increase the counter.\n\t\tcount++;\n\t}\n",
    "570": "\tpublic int size() {\n\t\treturn count;\n\t}\n",
    "572": "\tpublic OptimizerBoardPosition removeFirst() {\n\n\t\tif (count == 0)\n\t\t\treturn null;\n\n\t\t// The head of the queue must be returned.\n\t\tOptimizerBoardPosition result = queue[0];\n\t\t\n\t\t// The head of the queue has (logically) been removed => adjust the size.\n\t\t--count;\n\t\t\n\t\t// Remove the last board position.\n\t\tOptimizerBoardPosition x = queue[count];\n\t\tqueue[count] = null;\n\t\t\n\t\t// If there is at least one board position left in the queue then \n\t\t// shift the board positions so the queue has a new head.\n\t\tif (count != 0)\n\t\t\tsiftDown(0, x);\n\n\t\treturn result;\n\t}\n",
    "576": "\tprivate void addLogTextStyle(final String text, final String stylename) {\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tStyledDocument doc = optimizerLog.getStyledDocument(); \n\t\t\t\t\tdoc.insertString(doc.getLength(), text+\"\\n\", doc.getStyle(stylename));\t\t\t\n\t\t\t\t} catch (BadLocationException e) {\t/* ignore */ }\n\t\t\t}\n\t\t});\n\t}\n",
    "577": "\t private void siftDown(int position, OptimizerBoardPosition boardPosition) {\n\t\t \n\t\t // Calculate the half of the size as the maximum position the loop must go to.\n\t\t int half = count >>> 1;        \n\t\t \n\t\t while (position < half) {\n\t\t\t int childIndex = (position << 1) + 1; // assuming the left child is the \"better\" board position\n\t\t\t OptimizerBoardPosition child = queue[childIndex];\n\t\t\t int rightChildIndex = childIndex + 1;\n\t\t\t if (rightChildIndex < count && child.compareTo(queue[rightChildIndex]) > 0)\n\t\t\t\t child = queue[childIndex = rightChildIndex];\n\t\t\t if (boardPosition.compareTo(child) <= 0)\n\t\t\t\t break;\n\t\t\t queue[position] = child;\n\t\t\t position = childIndex;\n\t\t }\n\t\t \n\t\t queue[position] = boardPosition;\n\t }\n",
    "580": "\tpublic int getNumberOfStoredBoardPositions() {\n\t\treturn count.get();\n\t}\n",
    "601": "\tpublic void removeAllMarkings() {\n\t\tmarkedSquares = null;\n\t}\n",
    "608": "\tpublic void showDeadlockQueryStats() {\n\t\tdlqTotStats.sumFrom(dlqCurStats);\n\t\tif ( ! dlqTotStats.equals(dlqCurStats)) {\n\t\t\tshow1DLQStats(\"total\", dlqTotStats, 0);\n\t\t}\n\t\t\n\t\tshow1DLQStats(\"this time\", dlqCurStats, dlqTotStats.dlqAsked);\n\t\tdlqCurStats.clear();\n\t}\n",
    "610": "\tprivate int getBoxConfigurationIndex(int boardPositionIndex) {\n\t\t// The board position may just been locked by another thread. However,\n\t\t// this method is only called for already completely stored board positions.\n\t\t// Hence, the index can't hold just the \"LOCKED\" value but must\n\t\t// always also contain a valid box configuration index.\n\t\treturn table.get(boardPositionIndex+BOX_CONFIGURATION_OFFSET)&(~LOCKED); \n\t}\n",
    "613": "\tfinal private boolean hasSubset(byte[] boxConfiguration1, byte[] boxConfigurationArray, int indexInArray) {\n\t\tfor (int i = 0; i < packedBoardByteSize; i++) {\n\t\t\tbyte b2 = boxConfigurationArray[indexInArray + i];\n\t\t\t// \"b2\" is a subset, if all its 1-bits survive the ANDing with the first byte\n\t\t\tif ((boxConfiguration1[i] & b2) != b2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "617": "\tprivate int getPlayerPosition(int boardPositionIndex) {\n\t\t// The player position is only using some of the lower bits of the int it is stored in. Hence, we have to use a bit mask.\n\t\treturn table.get(boardPositionIndex+PLAYER_POSITION_OFFSET)&PLAYER_POSITION_AND_MASK;\n\t}\t\n",
    "619": "\t\tfinal private void doubleTreeSize() {\n\t\n\t\t\t// Double the tree size.\n\t\t\tint[] newArrayPointers = new int[2*2*treeSizeMax];\n\t\t\tSystem.arraycopy(arrayPointers, 0, newArrayPointers, 0, 2*treeSizeMax);\n\t\t\tarrayPointers = newArrayPointers;\n\t\n\t\t\tbyte[] newArrayData = new byte[packedBoardByteSize*2*treeSizeMax];\n\t\t\tSystem.arraycopy(treeData, 0, newArrayData, 0, packedBoardByteSize*treeSizeMax);\n\t\t\ttreeData = newArrayData;\n\t\n\t\t\ttreeSizeMax <<= 1;\n\t\t}\n",
    "626": "\t\tfinal private int treeToSortedListRecursively(int indexInTree, int last) {\n\t\n\t\t\t// If the end of the tree has been reached return the last index.\n\t\t\tif (indexInTree == -1) {\n\t\t\t\treturn last;\n\t\t\t}\n\t\n\t\t\t// Left side of the tree.\n\t\t\tint d = treeToSortedListRecursively(arrayPointers[2*indexInTree], last);\n\t\t\tsortedList[d++] = indexInTree;\n\t\n\t\t\t// Right side of the tree.\n\t\t\treturn (treeToSortedListRecursively(arrayPointers[2*indexInTree+1], d));\n\t\t}\n",
    "637": "\tfinal public int getNumberOfSelectedObject() {\n\t\treturn currentlyMarkedObject;\n\t}\n",
    "638": "\t\tfinal private void binaryTreeToBinaryHeap() {\n\t\t\n\t\t\tbyte[] treeDataTemp = new byte[packedBoardByteSize*treeSize];\n\t\t\n\t\t\tfor (int i=0, indexInVector = 0; i<treeSize; i++) {\n\t\t\t\tSystem.arraycopy(treeData, arrayPointers[i]*packedBoardByteSize, treeDataTemp, indexInVector, packedBoardByteSize);\n\t\t\t\tindexInVector += packedBoardByteSize;\n\t\t\t}\n\t\t\n\t\t\ttreeData = treeDataTemp;\n\t\t\tarrayPointers = null;\n\t\t}\n",
    "641": "\tfinal public void mouseWheelMoved(MouseWheelEvent evt) {\n\n\t\tint scrollDirection = evt.getWheelRotation();\n\n\t\t// Scrollen nach oben\n\t\tif (scrollDirection < 0 && currentlyMarkedObject > 0) {\n\t\t\tcurrentlyMarkedObject--;\n\t\t}\n\n\t\t// Scrollen nach unten\n\t\tif (scrollDirection > 0 && currentlyMarkedObject < 4) {\n\t\t\tcurrentlyMarkedObject++;\n\t\t}\n\n\t\tapplication.redraw(false);\n\t}\n",
    "643": "\tpublic void setProcessedStatus(int boardPositionIndex, boolean processedStatus) {\n\t\t\n\t\t// Set/delete the \"processed\"-flag. This needn't to be done using compareAndSwap\n\t\t// because all of the other information stored at that offset have already been \n\t\t// stored and cannot change anymore while this method is executed.\n\t\tint currentValue = table.get(boardPositionIndex+PLAYER_POSITION_OFFSET);\n\t\tif(processedStatus == true)\n\t\t\ttable.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue | PROCESSED_FLAG_BIT_MASK);\n\t\telse\n\t\t\ttable.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue & (~PROCESSED_FLAG_BIT_MASK));\n\t}\n",
    "648": "\tpublic void stateChanged(final ChangeEvent e) {\n\t\t\t\t\n\t\t// Get the tabbed pane all views are stored in.\n\t\tJTabbedPane tabbedPane = (JTabbedPane) e.getSource();\n\t\t\n\t\t/*\n\t\t * View on the levels\n\t\t */\n\t\tif(tabbedPane.getSelectedComponent() == languageSettings) {\n\t\t\n\t\t}\t\t\n\t\t\n\t}\n",
    "651": "\t\tprotected void finalize() {\n\t\t\tarrayPointers = null;\n\t\t\tsortedList = null;\n\t\t\ttreeData = null;\n\t\t}\n",
    "653": "\tpublic void stateChanged(final ChangeEvent e) {\n\t\t\t\t\n\t\t// Get the tabbed pane all views are stored in.\n\t\tJTabbedPane tabbedPane = (JTabbedPane) e.getSource();\n\t\t\n\t\t/*\n\t\t * Language settings\n\t\t */\n\t\tif(tabbedPane.getSelectedComponent() == languageSettings) {\n\t\t\n\t\t}\t\t\n\t\t\n\t}\n",
    "656": "\tprivate void createPanel() {\n\t\t\n\t\tsetLayout(new BorderLayout());\n\n\t\tJPanel guiPanel = new JPanel(new GridLayout(0, 1, 0, 10));\n\t\tguiPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createRaisedBevelBorder(), BorderFactory.createEmptyBorder(10, 10, 10, 10)));\n\n\t\t// Just a quick and dirty test coding ...\n\t\tNimRODFontDialog d = new NimRODFontDialog(null);\n\t\tComponent[] c = d.getContentPane().getComponents();\n\t\tguiPanel.add(c[0]);\n\t\t\n\t\tadd(guiPanel, BorderLayout.NORTH);\n\t}\n",
    "663": "\tprivate void updateElements() {\n\t\tfinal boolean selected = checkboxGUI.isSelected();\n\t\t\n\t\ttextfieldGUI.setEnabled(selected);\n\t\tlabelGUI.setEnabled(selected);\n\t}\n",
    "666": "\tpublic Double getValueAsDouble() {\n\t\treturn checkboxGUI.isSelected() ? textfieldGUI.getValueAsDouble() : null;\n\t}\n",
    "669": "\tpublic Integer getValueAsInteger() {\n\t\treturn checkboxGUI.isSelected() ? textfieldGUI.getValueAsInteger() : null;\n\t}\n",
    "670": "\tpublic void enterMeForTypeDate(JTable table) {\n\t\ttable.setDefaultRenderer(java.util.Date.class, this);\n\t}\n",
    "672": "\tpublic void addLevel(Level level) {\n\t\tdisplayedLevels.add(level);\n\t\tif (displayedLevels.size() < levelsPerPage) {\n\t\t\tlastLevelIndex = displayedLevels.size() - 1;\n\t\t} else {\n\t\t\tlastLevelIndex = levelsPerPage - 1;\n\t\t}\n\t}\n",
    "675": "\tpublic boolean isFieldActive() {\n\t\treturn textfieldGUI.isEnabled();\n\t}\n",
    "676": "\tpublic void addLevelCollection(final LevelCollection collection, int startNumber, int endNumber) {\n\t\tfor(int levelNo = startNumber; levelNo <= collection.getNumberOfLevels() && levelNo <= endNumber; levelNo++) {\n\t\t\taddLevel(collection.getLevel(levelNo));\n\t\t}\n\t}\n",
    "677": "\tpublic double setValue(double value) {\n\n\t\tdouble rc = value;\n\t\tif (value > maximumValue) {\n\t\t\trc = maximumValue;\n\t\t} else if (value < minimumValue) {\n\t\t\trc = minimumValue;\n\t\t} else {\n\t\t\trc = value;\n\t\t}\n\t\ttextfieldGUI.setValue(rc);\n\n\t\treturn rc;\t\t\n\t}\n",
    "684": "\tpublic void actionPerformed(ActionEvent actionevent) {\n\t\tif (actionevent.getActionCommand() == \"okbutton\") {\n\t\t\tdispose();\n\t\t}\n\t}\n",
    "685": "\tpublic void informAllUnsync(Generator<E> eventgen) {\n\t\t/*\n\t\t * We must not directly use (weakhashmap.keySet()), since it still\n\t\t * is coupled to the weakhashmap itself, which needs synchronization.\n\t\t * Hence we first must obtain a copy.\n\t\t */\n\t\tfor (L listener : getListenersCopy()) {\n\t\t\tfinal E evt = ((eventgen != null) ? eventgen.generate() : null);\n\t\t\tcaller.call(listener, evt);\n\t\t}\n\t}\n",
    "687": "\tpublic void setToStart() {\n\t\tsetTo(true);\n\t}\n",
    "688": "\tpublic void setToStop() {\n\t\tsetTo(false);\n\t}\n",
    "690": "\tprivate void setTo( boolean forStart ) {\n\t\tString textkey = (forStart ? startkey           : stopkey          );\n\t\tString action  = (forStart ? startActionCommand : stopActionCommand);\n\t\t\n\t\tsetText(Texts.getText( textkey ));\n\t\tsetActionCommand( action );\n\t\t\n\t\tsetupBorder(forStart);\n\t\tsetupBgColor(forStart);\n\t}\n",
    "693": "\tprivate void setupBorder(boolean forStart) {\n\t\tsetBorder( useBorder ? makeBorder(forStart) : null );\n\t}\n",
    "694": "\tprivate void setupBgColor(boolean forStart) {\n\t\tif (useBgColor) {\n\t\t\tint rgb = (forStart ? bgColorStart : bgColorStop);\n\t\t\t\n\t\t\tsetBackground( new Color(rgb) );\n\t\t\tsetOpaque(false);\n\t\t} else {\n\t\t\t// FFS/hm: should we actively put away a background color?\n\t\t}\n\t}\n",
    "696": "\tpublic Border makeBorder(boolean forStart) {\n\t\tint rgb = (forStart ? borderColorStart : borderColorStop);\n\t\treturn makeRgbBorder(rgb, useRoundedCorners);\n\t}\n",
    "697": "\tpublic Border makeStartBorder() {\n\t\treturn makeBorder(true);\n\t}\n",
    "699": "\tpublic Border makeStopBorder() {\n\t\treturn makeBorder(false);\n\t}\n",
    "703": "\tpublic void setUseBorder(boolean useBorder) {\n\t\tthis.useBorder = useBorder;\n\t}\n",
    "706": "\tpublic void setUseBgColor(boolean useBgColor) {\n\t\tthis.useBgColor = useBgColor;\n\t}\n",
    "710": "\tpublic void setBorderColorStart(int borderColorStart) {\n\t\tthis.borderColorStart = borderColorStart;\n\t}\n",
    "715": "\tpublic void setBorderColorStop(int borderColorStop) {\n\t\tthis.borderColorStop = borderColorStop;\n\t}\n",
    "718": "\tpublic void setBgColorStart(int bgColorStart) {\n\t\tthis.bgColorStart = bgColorStart;\n\t}\n",
    "721": "\tpublic void setBgColorStop(int bgColorStop) {\n\t\tthis.bgColorStop = bgColorStop;\n\t}\n",
    "722": "\tstatic private boolean isOutsideClip(int x, int y, int xlen, int ylen, Rectangle clip) {\n\n\t\t// Non-existing rectangle stands for the complete plane => nothing is outside of the complete plane.\n\t\t// We are \"outside\" of \"clip\", if we do not intersect with it.\n\t\treturn clip != null && ! clip.intersects(x, y, xlen, ylen);\n\t\t\n\t}\n",
    "741": "\tpublic boolean hasAlias() {\n\t\treturn (alias.length() > 0);\n\t}\n",
    "743": "\tpublic String getAlias() {\n\t\treturn alias;\n\t}\n",
    "746": "\tpublic void setAlias(String newAlias) {\n\t\talias = newAlias;\n\t}\n",
    "747": "\tpublic String getPath() {\n\t\treturn path;\n\t}\n",
    "750": "\tpublic String getName() {\n\t\tif (hasAlias()) {\n\t\t\treturn alias;\n\t\t}\n\t\treturn path;\n\t}\n",
    "752": "\tpublic String getDisplayName() {\n\t\tif (hasAlias()) {\n\t\t\treturn '[' + alias + ']';\n\t\t}\n\t\treturn path;\n\t}\n",
    "753": "\tprivate BufferedImage extractGraphicTwoCoordinates(BufferedImage entireGraphic, String graphicName) {\n\t\n\t\ttry {\n\t\t\tPoint graphicCoordinates = getPoint(graphicName);\n\t\t\tif(graphicCoordinates != null) {\n\t\t\t\treturn entireGraphic.getSubimage(graphicCoordinates.x * graphicWidth,\n\t\t\t\t\t\t                         graphicCoordinates.y * graphicHeight,\n\t\t\t\t\t\t                         graphicWidth, graphicHeight);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tif(Settings.isDebugModeActivated) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "754": "\tpublic Color getColor() {\n\t\treturn color;\n\t}\n",
    "755": "\tpublic void setColor(String color) {\n\t\tthis.color = parseColor(color);\n\t}\n",
    "756": "\tpublic void setBoardToDisplay(Board board) {\n\n\t\t// Save the reference.\n\t\tthis.board = board;\n\n\t\t// Create new array for storing information about which positions have to be drawn when repainting.\n\t\tgraphicStatus = new byte[board.size];\n\n\t\t// Initialize the debug array used for showing numbers on the board.\n\t\tArrays.fill(numbersToShow, -1);\n\n\t\t// Reset the transformation of the board.\n\t\ttransformBoard(-1);\n\t}\n",
    "758": "\tpublic String getColorString() {\n\t\treturn colorToString(color);\n\t}\n",
    "759": "\tprivate BufferedImage extractGraphicOneCoordinate(BufferedImage entireGraphic, String graphicName) {\n\t\n\t\ttry {\n\t\t\tint xCoordinate = getInt(graphicName, -1);\n\t\t\tif(xCoordinate == -1) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn entireGraphic.getSubimage(xCoordinate * graphicWidth, 0, graphicWidth, graphicHeight);\n\t\t} catch (Exception e) {\n\t\t\tif(Settings.isDebugModeActivated) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "764": "\tprivate String trimValue(String propertyValue) {\n\t\n\t\tif (propertyValue == null || propertyValue.length() == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\n\t\tint lastpos = propertyValue.indexOf('#');\n\t\tif (lastpos == -1) {\n\t\t\tlastpos = propertyValue.length() - 1;\n\t\t}\n\t\t\n\t\t\n\t\tfor(; lastpos >= 0 ; --lastpos ) {\n\t\t\tchar c = propertyValue.charAt(lastpos);\n\t\t\tif (c != ' ' && c != '\\t') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Now, \"lastpos\" indexes the last char to be retained (or -1 if there is none)\n\t\t\n\t\t// Return the trimmed value.\n\t\treturn propertyValue.substring(0, lastpos + 1);\n\t}\n",
    "772": "\tstatic public String getTransformationAsString() {\n\n\t\t// If the level isn't displayed transformed return an empty String.\n\t\tif (getRotationValue() == ROTATION_BY_0_DEGREES && isLevelFlippedHorizontally() == false) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// Build the transformation string and return it.\n\t\tString transformationString = \"View: Rotated \"\n\t\t\t                        + getRotationAsString()\n\t\t\t                        + \" degrees clockwise\";\n\t\tif (isLevelFlippedHorizontally()) {\n\t\t\ttransformationString += \", flipped horizontally.\";\n\t\t} else {\n\t\t\ttransformationString += \".\";\n\t\t}\n\n\t\treturn transformationString;\n\t}\n",
    "774": "\tpublic T generate() {\n\t\treturn base;\n\t}\n",
    "779": "\tfinal private JButton createToolBarButton(String iconName, String actionCommand, String toolTipText) {\n\n\t\t// Create and initialize the button.\n\t\tJButton button = new JButton(Utilities.getIcon(iconName, null));\n\t\tbutton.setActionCommand(actionCommand);\n\t\tbutton.setToolTipText(toolTipText);\n\t\tbutton.addActionListener(this);\n\n\t\t// The buttons must be clicked with the mouse.\n\t\tbutton.setFocusable(false);\n\n\t\treturn button;\n\t}\n",
    "781": "\tpublic Skin getCurrentSkin() {\n\t\treturn skin;\n\t}\n",
    "784": "\tprivate String getString(String name, String ... defaultValue) {\n\t\n\t\t// Get the value of the property.\n\t\tString propertyValue = trimValue(properties.getProperty(name));\n\t\n\t\t// If the the property couldn't be found set the default value.\n\t\tif (propertyValue == null) {\n\t\t\tif(defaultValue.length > 0) {\n\t\t\t\treturn defaultValue[0];\n\t\t\t}\n\t\t}\n\t\n\t\treturn propertyValue;\n\t}\n",
    "785": "\tfinal private JButton createToolBarButtonByKey(String iconName, String actionCommand, String toolTipTextKey) {\n\t\tString toolTipText = Texts.getText(toolTipTextKey);\n\t\treturn createToolBarButton(iconName, actionCommand, toolTipText);\n\t}\n",
    "787": "\tpublic void setSkinAnimationDelay(int delay) {\n\n\t\t// Save the delay in the settings.\n\t\tSettings.set(\"skinAnimationDelay\", \"\" + delay);\n\n\t\t// If a timer is running set the new delay value.\n\t\tif (animationTimer != null && animationTimer.isRunning()) {\n\t\t\tanimationTimer.setDelay(delay);\n\t\t}\n\t}\n",
    "793": "\tpublic void setViewDirection(int viewDirection) {\n\t\tthis.viewDirection = (byte) viewDirection;\n\t}\n",
    "800": "\tpublic void setMaximumScalingFactor(int maximumScalingFactor) {\n\n\t\tmaximumScaling = maximumScalingFactor;\n\n\t\trecalculateGraphicSizes();\n\t\trepaint();\n\n\t\t// Save the zooming factor.\n\t\tSettings.set(\"maximumScaling\", \"\" + maximumScaling);\n\t}\n",
    "805": "\tpublic void recalculateGraphicSizes() {\n\t\tisRecalculationNecessary = true;\n\t}\n",
    "806": "\tpublic void transformBoard(int transformationValue) {\n\n\t\t// Tell it to the Transformation class.\n\t\tTransformation.transform(transformationValue);\n\n\t\t// Since the transformation may have exchanged height and width, we force a\n\t\t// recalculation of the graphics, as if we had loaded a new level.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Show new graphics\n\t\trepaint();\n\t}\n",
    "808": "\tpublic void setLevelToDisplay(Level levelToBeDisplayed) {\n\t\t\n\t\t// Create an own board.\n\t\tboard = new Board(application);\n\t\t\n\t\t// Set the passed level on the board.\n\t\ttry {\n\t\t\tboard.setBoardFromString(levelToBeDisplayed.getBoardDataAsString());\n\t\t} catch (Exception e) {\n\t\t\t// Show the error message.\n\t\t\tUtilities.showExceptionError(this, e);\n\t\t}\n\n\t\t// Array containing the information which graphic has to be drawn at a specific position.\n\t\tgraphicStatus = new byte[board.height * board.width];\n\t\t\n\t\t// New level means every thing has to be recalculated to refresh the Panel.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Repaint this Panel.\n\t\trepaint();\n\t}\n",
    "810": "\tpublic void setBoardToDisplay(String boardAsString) {\n\t\t\n\t\t// Create an new board.\n\t\tboard = new Board(application);\n\t\t\n\t\t// Create an own board from the board of the level.\n\t\ttry {\n\t\t\tboard.setBoardFromString(boardAsString);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Array containing the information which graphic has to be drawn at a specific position.\n\t\tgraphicStatus = new byte[board.height * board.width];\n\t\t\n\t\t// New level means every thing has to be recalculated to refresh the Panel.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Repaint this Panel.\n\t\trepaint();\n\t}\n",
    "813": "\tpublic void setInfoBarVisible(boolean visibleStatus) {\n\t\tisInfoBarVisible = visibleStatus;\n\t}\n",
    "814": "\tpublic void setBoardToDisplay(Board board) {\n\t\t\n\t\tthis.board = board;\n\t\t\n\t\t// Array containing the information which graphic has to be drawn at a specific position.\n\t\tgraphicStatus = new byte[board.height * board.width];\n\t\t\n\t\t// New level means every thing has to be recalculated to refresh the Panel.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Repaint this Panel.\n\t\trepaint();\n\t}\n",
    "816": "\tpublic Board getBoard() {\n\t\treturn board;\n\t}\n",
    "819": "\tpublic Level getDisplayedLevel() {\n\t\treturn displayedLevel;\n\t}\n",
    "821": "\tpublic int getSquareWidth() {\n\t\tif (skin == null) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn skin.graphicWidth;\n\t}\n",
    "823": "\tpublic int getSquareHeight() {\n\t\tif (skin == null) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn skin.graphicHeight;\n\t}\n",
    "824": "\tfinal public void recalculateGraphicSizes() {\n\t\tisRecalculationNecessary = true;\n\t}\n",
    "827": "\tprivate void setInitialBoardPosition() {\n\t\tboard      = boardInitial.boardElements.clone();\n\t\tplayerPosX = boardInitial.playerPositionX;\n\t\tplayerPosY = boardInitial.playerPositionY;\n\t}\n",
    "835": "\tpublic void paintImmediately() {\n\t\tpaintImmediately(0, 0, getWidth(), getHeight());\n\t}\n",
    "840": "\tprivate void packBoxConfiguration(byte[] newPackedBoxConfiguration, byte[] unpackedBoxConfiguration) {\n\n\t\tint bytePosition = 0, bitPosition = 0;\n\n\t\t// Loop over all internal box positions.\n\t\tfor (int i = 0; i < boxPositionsCount; i++) {\n\n\t\t\tbytePosition = i >> 3;\n\t\t\tbitPosition  = i & 7;\n\n\t\t\tif ((unpackedBoxConfiguration[boxInternalToExternalPosition[i]] & BOX) == BOX)\n\t\t\t\tnewPackedBoxConfiguration[bytePosition] |= 1 << bitPosition;\n\t\t\telse\n\t\t\t\tnewPackedBoxConfiguration[bytePosition] &= (255 - (1 << bitPosition));\n\t\t}\n\t}\n",
    "856": "\tprivate void setVisited(int boardPositionIndex) {\n\t\tint bytePosition = (boardPositionIndex >>> 3), bitPosition = (boardPositionIndex & 7);\n\t\tvisitedData[bytePosition] |= (1 << bitPosition);\n\t}\n",
    "863": "\tfinal public void setCursor(int cursor) {\n\n\t\t// Set the specified predefined cursor.\n\t\tmainBoardDisplay.setCursor(Cursor.getPredefinedCursor(cursor));\n\t}\n",
    "865": "\tprotected void adjustToBoard(Point p) {\n\t\t\n\t\t// Clip both point coordinates at their allowed minimum (inclusive).\n\t\tif( p.x < xOffset ) {\n\t\t\tp.x = xOffset;\n\t\t}\n\t\tif( p.y < yOffset ) {\n\t\t\tp.y = yOffset;\n\t\t}\n\t\t\n\t\t// Compute maximal point coordinates, inclusive...\n\t\tint xmax = xOffset + Transformation.getOutputLevelWidth()  * skin.graphicWidth  - 1;\n\t\tint ymax = yOffset + Transformation.getOutputLevelHeight() * skin.graphicHeight - 1;\n\t\t\n\t\t// ... and use them to clip off larger values:\n\t\tif( p.x > xmax ) {\n\t\t\tp.x = xmax;\n\t\t}\n\t\tif( p.y > ymax ) {\n\t\t\tp.y = ymax;\t\n\t\t}\n\t}\n",
    "866": "\tprivate void paintExtSqRect(int xmin, int ymin, int extWidth, int extHeight) {\n\t\tint pixXmin   = xOffset + xmin * skin.graphicWidth;\n\t\tint pixYmin   = yOffset + ymin * skin.graphicHeight;\n\t\tint pixWidth  =      extWidth  * skin.graphicWidth;\n\t\tint pixHeight =      extHeight * skin.graphicHeight;\n\t\t\n\t\tif (pixWidth > 0 || pixHeight > 0) {\n\t\t\trepaint(pixXmin, pixYmin, pixWidth, pixHeight);\n\t\t\tpaintMovesPushes();\n\t\t}\n\t}\n",
    "870": "\tpublic int getInfluenceDistance(int startSquare, int targetSquare) {\n\t\treturn influenceDistances[startSquare][targetSquare];\n\t}\n",
    "871": "\tfinal public void setNewLanguage() {\n\n\t\t// Create a new menu bar and and a new tool bar according to the new language.\n\t\tapplication.setJMenuBar(createMenuBar());\n\t\tcreateToolBar();\n\t}\n",
    "872": "\tprivate boolean isVisited(int boardPositionIndex) {\n\t\tint i = (boardPositionIndex >>> 3), j = (boardPositionIndex & 7);\n\t\treturn (visitedData[i] & (1 << j)) > 0;\n\t}\n",
    "874": "\tfinal public void addPlayerMove(int direction) {\n\t\taddMovement(direction, -1);\n\t}\n",
    "876": "\t\tpublic void clear() {\n\t\t\tminX = Integer.MAX_VALUE;\n\t\t\tmaxX = Integer.MIN_VALUE;\n\t\t\tminY = Integer.MAX_VALUE;\n\t\t\tmaxY = Integer.MIN_VALUE;\n\t\t}\n",
    "877": "\tfinal public HistoryElement getSuccessorMovement() {\n\t\tif (hasSuccessorMovement() == false) {\n\t\t\treturn null;\n\t\t}\n\t\treturn movementHistory.get( ++currentMovementNo );\n\t}\n",
    "878": "\tfinal public HistoryElement getPrecedingMovement() {\n\t\tif (hasPrecedingMovement() == false) {\n\t\t\treturn null;\n\t\t}\n\t\treturn movementHistory.get( currentMovementNo-- );\n\t}\n",
    "881": "\tfinal public HistoryElement getMovement(int movementNo) {\n\n\t\tif (movementNo < 0 || movementNo > movementHistory.size() - 1) {\n\t\t\treturn null;\n\t\t}\n\t\treturn movementHistory.get(movementNo);\n\t}\n",
    "882": "\tfinal public int getCurrentMovementNo() {\n\t\treturn currentMovementNo;\t\n\t}\n",
    "883": "\t\tpublic boolean isEmpty() {\n\t\t\treturn (minX > maxX) || (minY > maxY);\n\t\t}\n",
    "884": "\tfinal public int getMovementsCount() {\n\t\treturn movementHistory.size();\n\t}\n",
    "885": "\tfinal public int getPushesCount() {\n\n\t\tint pushesCount = 0;\n\n\t\tfor (HistoryElement historyElement : movementHistory) {\n\t\t\tif (historyElement.pushedBoxNo != -1) {\n\t\t\t\tpushesCount++;\n\t\t\t}\n\t\t}\n\t\treturn pushesCount;\n\t}\n",
    "889": "\tfinal public String getLURDString() {\n\t\treturn getLURDString(0, currentMovementNo);\n\t}\n",
    "890": "\t\tpublic void add(int x, int y) {\n\t\t\tminX = Math.min(minX, x);\n\t\t\tmaxX = Math.max(maxX, x);\n\t\t\tminY = Math.min(minY, y);\n\t\t\tmaxY = Math.max(maxY, y);\n\t\t}\n",
    "891": "\tfinal public String getLURDStringTotal() {\n\t\treturn getLURDString(0, getMovementsCount() - 1);\n\t}\n",
    "893": "\tfinal public void setHistoryToStart() {\n\t\tcurrentMovementNo = -1;\n\t}\n",
    "895": "\tfinal public void setMovementNo(int movementNo) {\n\t\tcurrentMovementNo = movementNo;\n\t}\n",
    "897": "\tfinal public void setStartOfCombinedMovement() {\n\t\tisStartOfCombinedMovement = true;\n\t}\n",
    "898": "\t\tpublic void addExternal(int externalPos) {\n\t\t\tif (externalPos != -1) {\n\t\t\t\tint externalWidth = Transformation.getOutputLevelWidth();\n\t\t\t\tint extX = externalPos % externalWidth;\n\t\t\t\tint extY = externalPos / externalWidth;\n\t\t\t\t\n\t\t\t\tadd(extX, extY);\n\t\t\t}\n\t\t}\n",
    "900": "\tfinal public void goToPrecedingMovement() {\n\t\tcurrentMovementNo--;\n\t}\n",
    "903": "\tfinal public void goToNextMovement() {\n\t\t++currentMovementNo;\n\t}\n",
    "904": "\t\tpublic void addInternal(int internalPos) {\n\t\t\tif (internalPos != -1) {\n\t\t\t\tint externalPos = Transformation.getExternalPosition(internalPos);\n\t\t\t\t\n\t\t\t\taddExternal(externalPos);\n\t\t\t}\n\t\t}\n",
    "905": "\tfinal public boolean hasPrecedingMovement() {\n\t\treturn currentMovementNo >= 0;\n\t}\n",
    "908": "\tfinal public boolean hasSuccessorMovement() {\n\t\treturn (currentMovementNo + 1) < movementHistory.size();\n\t}\n",
    "910": "\tprivate void paintMovesPushes() {\n\t\t// Moves and pushes are displayed as part of the history slider panel.\n\t\tif (historySliderPanel != null) {\n\t\t\t// We have to include the textual representation, as well as the graphical\n\t\t\t// slider representation.  That includes most of the area.\n\t\t\tint w = historySliderPanel.getWidth();\n\t\t\tint h = historySliderPanel.getHeight();\n\t\t\t\n\t\t\t// Redraw the slider. This needn't to be done immediately. Repaint is much\n\t\t\t// faster then paintImmediately.\n\t\t\thistorySliderPanel.repaint(0, 0, w, h);\n\t\t}\n\t}\n",
    "911": "\tfinal public int combinedLengthPreceding() {\n\t\tint steps = 0;\n\t\t\n\t\tfor( int mNo = currentMovementNo; mNo >= 0 ; --mNo ) {\n\t\t\tHistoryElement histElem = getMovement(mNo);\n\t\t\t\n\t\t\tif( histElem == null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++steps;\n\t\t\tif( histElem.isStartOfCombinedMovement ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn steps;\n\t}\n",
    "913": "\tfinal public int combinedLengthSuccessor() {\n\t\tint steps = 0;\n\t\tint mNo = currentMovementNo;\n\t\t\n\t\tfor(;;) {\n\t\t\t++mNo;\n\t\t\t\n\t\t\tHistoryElement histElem = getMovement(mNo);\n\t\t\t\n\t\t\tif( histElem == null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++steps;\n\t\t\tif( histElem.isStartOfCombinedMovement ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn steps;\n\t}\n",
    "915": "\tfinal public int countCombinedForward() {\n\t\tint starts = 0;\n\t\tint mNo = currentMovementNo;\n\t\t\n\t\tfor(;;) {\n\t\t\tHistoryElement histElem = getMovement(mNo);\n\t\t\t\n\t\t\tif( histElem == null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( histElem.isStartOfCombinedMovement ) {\n\t\t\t\t++starts;\n\t\t\t} else if( starts == 0 ) {\n\t\t\t\t++starts;\n\t\t\t}\n\t\t\t++mNo;\n\t\t}\n\t\t\n\t\treturn starts;\n\t}\n",
    "918": "\tfinal public float averageLengthCombinedForward() {\n\t\tint len = getMovementsCount() - currentMovementNo;\n\t\tif( len <= 0 ) {\n\t\t\treturn 0.0f;\n\t\t}\n\t\tint cntcombined = countCombinedForward();\n\t\treturn (float)len / cntcombined;\n\t}\n",
    "932": "\tpublic boolean isABoxBeenMoved() {\n\t\treturn pushedBoxNo != -1;\n\t}\n",
    "939": "\tprivate MouseListener getMouseListener() {\n\t\treturn new MouseAdapter() {\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent e) {\n\t\t\t\tif(e.getClickCount() > 1) {\n\t\t\t\t\tint index = locationToIndex(e.getPoint());\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// This action can be disabled (for instance when the solver is running).\n\t\t\t\t\t\tif(!isTakeSolutionAsHistoryEnabled) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tSolution clickedSolution = (Solution) listModel.getElementAt(index);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Set the selected solution as new history in the game.\n\t\t\t\t\t\tapplication.takeSolutionForHistory(clickedSolution);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n",
    "941": "\tfinal public void setEditorMenuItemEnabled(boolean enabled) {\n\t\teditorMenuItem.setEnabled(enabled);\n\t}\n",
    "948": "\tfinal public JMenuItem getSaveLevelMenuItem() {\n\t\treturn saveLevelMenuItem;\n\t}\n",
    "954": "\tfinal public JButton getInfoButton() {\n\t\treturn infoButton;\n\t}\n",
    "960": "\tfinal public void setModeDependentObjectStatus() {\n\n\t\t// Ensure to change status on the EDT (event dispatcher thread),\n\t\t// because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component button : playModeDependentObjects) {\n\t\t\t\t\tbutton.setEnabled(application.isPlayModeActivated());\n\t\t\t\t}\n\n\t\t\t\tfor (AbstractButton button : editorModeDependentObjects) {\n\t\t\t\t\tbutton.setEnabled(application.isEditorModeActivated());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "966": "\tprivate void debugDisplayBoardPosition(BoxConfigurationStorageHashtable storage, int boardPositionIndex, final boolean graphicOutput, final boolean waitForEnter) {\n\t\tbyte[] temp = new byte[packedBoardByteSize];\n\t\tstorage.copyBoxConfiguration(temp, boardPositionIndex / playerSquaresCount);\n\t\tint playerPosition = boardPositionIndex % playerSquaresCount;\n\t\tdebugDisplayBoxConfiguration(temp, playerPosition, graphicOutput, waitForEnter);\n\t}\n",
    "969": "\tpublic void setSolutionColor(Solution solution, Color color) {\n\t\tif(color == null) {\n\t\t\tcoloredSolutions.remove(solution);\n\t\t} else {\n\t\t\tcoloredSolutions.put(solution, color);\n\t\t}\n\t}\n",
    "971": "\tfinal public void setSolverDependentObjectsEnabled(final boolean enabledStatus) {\n\t\t\n\t\t// Ensure to change status on the EDT (event dispatcher thread),\n\t\t// because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component component : solverModeDependentObjects) {\n\t\t\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "972": "\t\tpublic boolean isValidNewSolution() {\n\t\t\treturn this != INVALID_SOLUTION && this != DUPLICATE_SOLUTION;\n\t\t}\n",
    "973": "\tpublic void setAllSolutionsUncolored() {\n\t\tcoloredSolutions.clear();\n\t}\n",
    "974": "\tprivate void setSelectedViewRow(int viewrowindex) {\n\t\tif (       (viewrowindex >= 0)\n\t\t\t\t&& (tableModelSolutionData != null)\n\t\t\t\t&& (tableModelSolutionData.getRowCount() > 0)\n\t\t\t\t&& (tableSolutionData != null)) {\n\t\t\tListSelectionModel lsm = tableSolutionData.getSelectionModel();\n\t\t\tlsm.setSelectionInterval(viewrowindex, viewrowindex);\n\t\t}\n\t}\n",
    "976": "\tpublic void addActionListener(ActionListener actionListener) {\n\t\tactionListenerSet.register(actionListener);\n\t}\n",
    "979": "\tprotected void showNoSolutionsSelected() {\n\t\tUtilities.showInfoNoteTextKey(getParent(), \"solutionList.noSolutionSelected\");\n\t}\n",
    "980": "\tpublic void removeActionListener(ActionListener actionListener) {\n\t\tactionListenerSet.unregister(actionListener);\n\t}\n",
    "982": "\tprivate void debugDisplayBoardPosition(BoxConfigurationStorageHashtable storage, int boxConfigurationIndex, int playerPosition, final boolean graphicOutput, final boolean waitForEnter) {\n\t\tbyte[] temp = new byte[packedBoardByteSize];\n\t\tstorage.copyBoxConfiguration(temp, boxConfigurationIndex);\n\t\tdebugDisplayBoxConfiguration(temp,playerPosition, graphicOutput, waitForEnter);\n\t}\n",
    "984": "\tfinal public void setUndoButtonsEnabled(final boolean enabledStatus) {\n\n\t\t// Ensure to change status on the EDT, because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component component : undoButtons) {\n\t\t\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "985": "\t\tpublic void mouseDragged(MouseEvent evt) {\n\t\t\n\t\t\tif(isMouseDragged == false) {\n\t\t\t\n\t\t\t\tstartOfLastDrag = evt.getWhen();\n\t\t\t\t\n\t\t\t\t// Save the dragged status.\n\t\t\t\tisMouseDragged = true;\n\t\t\t}\n\t\t\t\n\t\t\tmousePressed(evt);\n\t\t}\t\t\n",
    "987": "\tprivate void informThemHere(final Solution solution, final String action) {\n\t\tactionListenerSet.informAllSync(makeActionGenerator(solution, action));\n\t}\n",
    "989": "\tprivate void informListeners(final Solution solution, final String action) {\n\t\n\t\t// The GUI should be updated in the EDT.\n\t\tif(SwingUtilities.isEventDispatchThread()) {\n\t\t\tinformThemHere(solution, action);\n\t\t}\n\t\telse {\n\t\t\t// Update the GUI before this thread continues. \n\t\t\ttry {\n\t\t\t\tSwingUtilities.invokeAndWait(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tinformThemHere(solution, action);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t} catch (InvocationTargetException e) { /* just continue */ }\n\t\t}\n\t}\n",
    "993": "\tpublic void setTakeSolutionAsHistoryVisible(boolean isVisible) {\n\t\tisTakeSolutionAsHistoryEnabled = isVisible;\n\t}\n",
    "996": "\tfinal public void setRedoButtonsEnabled(final boolean enabledStatus) {\n\n\t\t// Ensure to change status on the EDT, because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component component : redoButtons) {\n\t\t\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "1000": "\t\tpublic void addSolutionToBeHighlighted(Solution solution) {\n\t\t\thighlightedSolutions.put(solution, 10);\n\t\t\t\n\t\t\t// Inform this thread that new solutions are to be highlighted.\n\t\t\tsynchronized(this) {\n\t\t\t\tnotify();\n\t\t\t}\n\t\t}\n",
    "1002": "\t\tpublic void removeAllSolutionsToBeHighlighted() {\n\t\t\thighlightedSolutions.clear();\n\t\t}\n",
    "1006": "\t\tpublic Integer getHighlightIntensity(Solution solution) {\n\t\t\treturn highlightedSolutions.get(solution);\n\t\t}\n",
    "1014": "\tfinal public void setInvalidLevelModeDependentObjectsEnabled(boolean enabledStatus) {\n\n\t\tfor (Component component : invalidLevelModeDependentObjects) {\n\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t}\n\n\t\t// An invalid level can't have a movement history.\n\t\t// Hence, disable the undo/redo buttons.\n\t\tsetUndoButtonsEnabled(enabledStatus);\n\t\tsetRedoButtonsEnabled(enabledStatus);\n\n\t\t// Enable the editor menu item so the user can open the editor.\n\t\tsetEditorMenuItemEnabled(true);\n\t}\n",
    "1015": "\tpublic boolean isValidLastChanged() {\n\t\tif (lastChanged != null) {\n\t\t\tif (lastChanged.getTime() > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "1025": "\tfinal public void setDebugMenuVisible(boolean isToBeVisible) {\n\t\tfor (Component component : debugModeDependentObjects) {\n\t\t\tcomponent.setVisible(isToBeVisible);\n\t\t}\n\t}\n",
    "1035": "\tpublic SolutionsGUI getSolutionsView() {\n\t\treturn solutionsGUI;\n\t}\n",
    "1041": "\tfinal public void update(String expression) {\n\n\t\ttry {\n\t\t\tStatement st = conn.createStatement();\n\n\t\t\t// Run the query.\n\t\t\tif (st.executeUpdate(expression) == -1) {\n\t\t\t\tSystem.out.println(\"db error: \" + expression);\n\t\t\t}\n\n\t\t\t// Close the Statement object.\n\t\t\tst.close();\n\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n",
    "1046": "\tprivate void waitForDeadlockIdentification() {\n\t\ttry {\n\t\t\tif(deadlockIdentification.isAlive()) {\n\t\t\t\toptimizerGUI.setInfoText(Texts.getText(\"optimizer.waitingForDeadlockDetection\"));\n\t\t\t\tdeadlockIdentification.join();\n\t\t\t}\n\t\t} catch (InterruptedException e) {}\n\t}\n",
    "1049": "\tfinal public void saveLevel(Level level, String fileName) throws IOException {\n\n\t\t// Create a PrintWriter for writing the data to hard disk.\n\t\tPrintWriter levelFile = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));\n\n\t\t// Write the level data to the file.\n\t\twriteLevelToFile(level, levelFile);\n\n\t\t// Check the error status.\n\t\tboolean isFileSavingFailed = levelFile.checkError();\n\n\t\t// Close the file.\n\t\tlevelFile.close();\n\n\t\t// Throw exception in the case of an error.\n\t\tif (isFileSavingFailed) {\n\t\t\tthrow new IOException(Texts.getText(\"errorBySaving\"));\n\t\t}\n\t}\n",
    "1055": "\tfinal public int getSquareCharacter(int xPosition, int yPosition) {\n\n\t\t// Select the line by the Y coordinate\n\t\tif (yPosition < 0 || yPosition >= boardData.size()) {\n\t\t\treturn ' ';\n\t\t}\n\t\tfinal String line = boardData.get(yPosition);\n\t\t\n\t\t// The level lines need not be filled with spaces at the end.\n\t\t// Such a line may be shorter than the level width.\n\t\tif (xPosition < 0 || xPosition >= line.length()) {\n\t\t\treturn ' ';\n\t\t}\n\n\t\treturn line.charAt(xPosition);\n\t}\n",
    "1066": "\tprotected void refreshView() {\n\t\tactionPerformed(new ActionEvent(this, 0, \"refreshView\"));\n\t}\n",
    "1071": "\t\tpublic int getID() {\n\t\t\treturn ID;\n\t\t}\n",
    "1092": "\tprotected void updateComboBoxAuthors() {\n\t\t\n\t\t// Update all needed ComoboBoxes of this view.\n\t\tsuper.updateComboBoxAuthors(comboBoxAuthors, selectionAuthor);\n\t\t\n\t\t// When adding new items the combo boxes should not fire actions.\n\t\t// (If this isn't set the combo boxes refresh the views every time their content changes)\n\t\tdoNotFireActions = true;\n\t\t\n\t\t// The selection ComboBox's first item is always the wildcard \"*\".\n\t\tselectionAuthor.insertItemAt(new ComboBoxEntry(\"*\", 0), 0);\n\t\t\n\t\t// Set the wildcard as selected.\n\t\tselectionAuthor.setSelectedIndex(0);\n\t\t\n\t\t// Actions may be fired again.\n\t\tdoNotFireActions = false;\n\t}\n",
    "1097": "    protected void finalize() {\n    \tdatabaseViews.dispose();\n    \tdatabaseViews = null;\n    }\n",
    "1098": "    \tstatic public void authorsNamesChanged() {\n    \t\tfor(int i=0; i<changeInAuthorView.length; i++) {\n    \t\t\tchangeInAuthorView[i] = true;\n    \t\t}\n    \t}\n",
    "1100": "    \tstatic public void collectionNamesChanged() {\n    \t\tfor(int i=0; i<changeInCollectionView.length; i++) {\n    \t\t\tchangeInCollectionView[i] = true;\n    \t\t}\n    \t}\n",
    "1102": "    \tstatic public void changeInAssignmentView() {\n    \t\tfor(int i=0; i<changeInAssignmentView.length; i++) {\n    \t\t\tchangeInAssignmentView[i] = true;\n    \t\t}\n    \t}\n",
    "1103": "    \tstatic public void changeInLevelView() {\n    \t\tfor(int i=0; i<changeInLevelView.length; i++) {\n    \t\t\tchangeInLevelView[i] = true;\n    \t\t}\n    \t}\n",
    "1107": "    \tstatic public void resetUpdateFlags(int view) {\n    \t\tchangeInAuthorView[view]     = false;\n        \tchangeInCollectionView[view] = false;\n        \tchangeInAssignmentView[view] = false;\n        \tchangeInLevelView[view]      = false;\n    \t}\n",
    "1108": "    \tstatic public void setUpdateFlags(int view) {\n    \t\tchangeInAuthorView[view]     = true;\n        \tchangeInCollectionView[view] = true;\n        \tchangeInAssignmentView[view] = true;\n        \tchangeInLevelView[view]      = true;\n    \t}\n",
    "1114": "\tprotected void updateAdditionalInformation() {\n\t\tint firstSelectedRow = tableLevelData.convertRowIndexToModel(tableLevelData.getSelectionModel().getMinSelectionIndex());\n\t\tvalueChanged(new ListSelectionEvent(tableLevelData.getSelectionModel(), firstSelectedRow, firstSelectedRow, false));\n\t}\n",
    "1115": "\tfinal public int getNumberOfStoredBoardPositions() {\n\t\treturn count;\n\t}\n",
    "1120": "\tfinal public void clear() {\n\t\t// This code is similar to hash table.clear()\n\t\tEntry tab[] = table;\n\t\t\n\t\tfor (int index = tab.length; --index >= 0;) {\n\t\t\ttab[index] = null;\n\t\t}\n\t\tcount = 0;\n\t}\n",
    "1123": "\t\tpublic Object getBoardPosition() {\n\t\t\treturn boardPosition;\n\t\t}\n",
    "1125": "\tprotected Object getSelectedCollection() {\n\t\treturn selectionCollection.getSelectedItem();\n\t}\n",
    "1127": "\tprotected int bytesPerAtom() {\n\t\treturn (4);\n\t}\n",
    "1129": "\tprotected int bytesPerLine() {\n\t\treturn (72);\n\t}\n",
    "1135": "\t\tprotected int decodeLinePrefix(PushbackInputStream aStream, OutputStream bStream) throws IOException {\n\t\t\treturn (bytesPerLine());\n\t\t}\n",
    "1138": "\t\tprotected void decodeAtom(PushbackInputStream aStream, OutputStream bStream, int l) throws IOException {\n\t\t\tthrow new IOException();\n\t\t}\n",
    "1144": "\t\tpublic byte decodeBuffer(String inputString)[] throws IOException {\n\t\t\tbyte    inputBuffer[] = new byte[inputString.length()];\n\t\t\tByteArrayInputStream inStream;\n\t\t\tByteArrayOutputStream outStream;\n\n\t\t\tinputBuffer = inputString.getBytes();\n\t\t\tinStream = new ByteArrayInputStream(inputBuffer);\n\t\t\toutStream = new ByteArrayOutputStream();\n\t\t\tdecodeBuffer(inStream, outStream);\n\t\t\treturn (outStream.toByteArray());\n\t\t}\n",
    "1146": "\t\tpublic byte decodeBuffer(InputStream in)[] throws IOException {\n\t\t\tByteArrayOutputStream outStream = new ByteArrayOutputStream();\n\t\t\tdecodeBuffer(in, outStream);\n\t\t\treturn (outStream.toByteArray());\n\t\t}\n",
    "1150": "\tpublic void setStep(int msStep) {\n\t\tstepMillis = msStep;\n\t}\n",
    "1152": "\tpublic int getStep() {\n\t\treturn stepMillis;\n\t}\n",
    "1153": "\tpublic void setLength(int len) {\n\t\tintendedLength = len;\n\t}\n",
    "1155": "\tpublic int getLength() {\n\t\treturn intendedLength;\n\t}\n",
    "1157": "\tstatic public Delays makeDelayNormal() {\n\t\treturn makeDelayNormal(0);\n\t}\n",
    "1158": "\tstatic public Delays makeDelayNormal(int seqLength) {\n\t\treturn new Delays(Settings.delayValue, seqLength);\n\t}\n",
    "1159": "\tstatic public Delays makeDelayUndoRedo() {\n\t\treturn makeDelayUndoRedo(0);\n\t}\n",
    "1161": "\tprivate void saveButtonActionPerformed() {\n\n\t\t// Save properties to a file.\n\t\tsaveProperties(newLanguageProperties, getFilepathFromLanguageCode(newLanguageCode));\n\n\t\t// Make new backup copy of properties.\n\t\tlastSavedNewLanguageProperties = (Properties) newLanguageProperties.clone();\n\t}\n",
    "1162": "\tstatic public Delays makeDelayUndoRedo(int seqLength) {\n\t\treturn new Delays(Settings.delayValueUndoRedo, seqLength);\n\t}\n",
    "1163": "\tpublic void start() {\n\t\tif ( ! started ) {\n\t\t\tlastNow = System.currentTimeMillis();\n\t\t\tstarted = true;\n\t\t}\n\t}\n",
    "1164": "\tpublic void stop() {\n\t\tstarted = false;\n\t}\n",
    "1169": "\tprivate int effStepInt( boolean slowstep ) {\n\t\tfloat step = effStep(slowstep);\n\t\tint  istep = Math.round(step);\n\t\t\n\t\t// When we would tell a zero delay (or even less), but the original\n\t\t// intention was a positive delay, we shall return the smallest\n\t\t// possible positive value: 1.\n\t\tif( istep <= 0 ) {\n\t\t\tif( stepMillis > 0 ) {\n\t\t\t\tistep = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Never consider negative values\n\t\tif( istep < 0 ) {\n\t\t\tistep = 0;\n\t\t}\n\t\t\n\t\treturn istep;\n\t}\n",
    "1172": "\t\t\tpublic void run() {\n\n\t\t\t\ttry {\n\t\t\t\t\t// Start the backward search.\n\t\t\t\t\tbackwardSearch();\n\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\t// Stop the optimizer by setting the proper stop reason.\n\t\t\t\t\toptimizerStatus = OptimizerStatus.STOPPED_DUE_TO_OUT_OF_MEMORY;\n\t\t\t\t}\n\t\t\t}\n",
    "1173": "\tstatic public void main(String[] argv) {\n\n\t\t// Check for debug parameters.\n\t\tfor(String parameter : argv) {\n\t\t\tif(parameter.equalsIgnoreCase(\"-debug\")) {\n\t\t\t\tSettings.isDebugModeActivated = true;\t\n\t\t\t}\n\t\t\tif(parameter.equalsIgnoreCase(\"-debugSettings\")) {\n\t\t\t\tSettings.isSettingsDebugModeActivated = true;\n\t\t\t}\n\t\t\tif(parameter.equalsIgnoreCase(\"-debugTiming\")) {\n\t\t\t\tSettings.isTimingDebugModeActivated = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Save the information whether this program is started as \"web start application\".\n\t\tSettings.isStartedAsWebStartApplication =\n\t\t\t\t\t   (argv.length > 0 && argv[0].equals(\"-webstart\"))\n\t\t\t\t\t|| (argv.length > 1 && argv[1].equals(\"-webstart\"));\n\t\t\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tnew JSoko().startProgram();\n\t\t\t}\n\t\t});\n\t}\n",
    "1174": "\tpublic void sleep(boolean reassertIntr) {\n\t\tsleep(reassertIntr, false);\n\t}\n",
    "1177": "\tprivate char decryptCharcode(int c, int start, int end, int offset) {\n\t\t\n\t\tc+=offset;\n\t\tif(offset > 0 && c > end){\n\t\t\tc= (start+(c-end-1));\n\t\t}\n\t\telse if(offset < 0 && c < start){\n\t\t\tc= (end-(start-c-1));\n\t\t}\n\t\treturn (char) c;\n\t}\n",
    "1179": "\tprivate void restoreButtonActionPerformed(ActionEvent evt) {\n\t\tnewLanguageProperties = (Properties) lastSavedNewLanguageProperties.clone();\n\n\t\tloadLanguageTexts(NEW_LANGUAGE_COLUMN);\n\t\trefreshTranslationTextAreas();\n\t}\n",
    "1183": "\tprotected void stateChanged() {\n\t\tChangeEvent e = new ChangeEvent(this);\n\t\tfor (ChangeListener listener : changeListeners) {\n\t\t\tlistener.stateChanged(e);\n\t\t}\n\t}\n",
    "1186": "\tpublic void addValueListener(ChangeListener listener) {\n\t\tchangeListeners.add(listener);\n\t}\n",
    "1188": "\tpublic double getValueAsDouble() {\n\t\tObject currentValue = getValue();\n\t\tif (currentValue instanceof Double) {\n\t\t\treturn (Double) currentValue;\n\t\t}\n\t\tif (currentValue instanceof Integer) {\n\t\t\treturn ((Integer) currentValue).doubleValue();\n\t\t}\n\n\t\treturn 0;\n\t}\n",
    "1189": "\tpublic int getValueAsInteger() {\n\t\tObject currentValue = getValue();\n\t\tif (currentValue instanceof Double) {\n\t\t\treturn ((Double) currentValue).intValue();\n\t\t}\n\t\tif (currentValue instanceof Integer) {\n\t\t\treturn (Integer) currentValue;\n\t\t}\n\n\t\treturn 0;\n\t}\n",
    "1193": "\tpublic void setMinRAMinMiB(long minRAMinMiB) {\n\t\tthis.minRAMinMiB = minRAMinMiB;\n\t}\n",
    "1194": "\tprotected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n\t\tif (minRAMinMiB >= 0) {\n\t\t\t// We are limited...\n\t\t\tif (size() >= 2) {\n\t\t\t\t// We are large enough to loose an entry...\n\t\t\t\tif (Utilities.getMaxUsableRAMinMiB() < minRAMinMiB) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "1197": "\tpublic V getV(K key) {\n\t\treturn map.get(key);\n\t}\n",
    "1199": "\tpublic void add(K key, V value) {\n\t\tmap.put(key, value);\n\t}\n",
    "1200": "\tpublic void trimToSize() {\n\t\t// we cannot do anything useful, here\n\t}\n",
    "1215": "\tfinal public Object clone() {\n\t\treturn new BoxData(this);\n\t}\n",
    "1216": "\tfinal public void setBoxStartPosition(int boxNo, int boxPosition) {\n\t\tboxPositions[boxNo] = boxPosition;\n\t}\n",
    "1218": "\tfinal public void setBoxPosition(int boxNo, int boxPosition) {\n\t\tboxPositions[boxNo] = boxPosition;\n\t}\n",
    "1219": "\tfinal public void setBoxPositions(int[] newBoxPositions) {\n\n\t\t// We must use a copy of the the array!\n\t\t// The caller does not donate this object, he will continue\n\t\t// to use and modify that array, while we expect to own this array.\n\t\tboxPositions = newBoxPositions.clone();\n\t}\n",
    "1221": "\tfinal public void setBoxActive(int boxNo) {\n\t\tisBoxInactive[boxNo] = false;\n\t}\n",
    "1223": "\tfinal public void setBoxInactive(int boxNo) {\n\t\tisBoxInactive[boxNo] = true;\n\n\t\t// An inactive box cannot be part of a corral\n\t\tisBoxInCorral[boxNo] = false;\n\t}\n",
    "1224": "\tfinal public boolean isBoxActive(int boxNo) {\n\t\treturn isBoxInactive[boxNo] == false;\n\t}\n",
    "1225": "\tfinal public boolean isBoxInactive(int boxNo) {\n\t\treturn isBoxInactive[boxNo];\n\t}\n",
    "1226": "\tfinal public void setBoxFrozen(int boxNo) {\n\t\tisBoxFrozen[boxNo] = true;\n\t}\n",
    "1227": "\tpublic void setLevelForPlaying(int levelNo) {\n\t\tsetLevelForPlaying(currentLevelCollection.getLevel(levelNo));\n\t}\n",
    "1228": "\tfinal public boolean isBoxFrozen(int boxNo) {\n\t\treturn isBoxFrozen[boxNo];\n\t}\n",
    "1230": "\tfinal public void setBoxUnfrozen(int boxNo) {\n\t\tisBoxFrozen[boxNo] = false;\n\t}\n",
    "1231": "\tfinal public void setBoxInCorral(int boxNo) {\n\t\tisBoxInCorral[boxNo] = true;\n\t}\n",
    "1232": "\tfinal public void removeBoxFromCorral(int boxNo) {\n\t\tisBoxInCorral[boxNo] = false;\n\t}\n",
    "1233": "\tfinal public boolean isBoxInCorral(int boxNo) {\n\t\treturn isBoxInCorral[boxNo];\n\t}\n",
    "1234": "\tfinal public int getBoxPosition(int boxNo) {\n\t\treturn boxPositions[boxNo];\n\t}\n",
    "1236": "\tfinal public boolean isEveryBoxOnAGoal() {\n\n\t\t// Check all boxes for \"on goal\"\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\t// ignore deactivated boxes\n\t\t\tif (isBoxInactive(boxNo))\n\t\t\t\tcontinue;\n\n\t\t\tif (board.isBoxOnGoal(boxPositions[boxNo]) == false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "1237": "\tpublic int getBoxesOnGoalsCount() {\n\t\tint boxesOnGoalsCount = 0;\n\t\tfor(int boxNo=0; boxNo<boxCount; boxNo++) {\n\t\t\t// TODO: explain why inactive boxes are not ignored Answer: bad programming. this method\n\t\t\t// is only used when a new level is loaded and all boxes are active. Inactive boxes are\n\t\t\t// only there during deadlock detection. Nevertheless, I think it's better to check for \n\t\t\t// inactive boxes here, too. I will have a look at this at some time. \n\t\t\tif(board.isGoal(getBoxPosition(boxNo))) {\n\t\t\t\tboxesOnGoalsCount++;\n\t\t\t}\n\t\t}\n\t\treturn boxesOnGoalsCount;\n\t}\n",
    "1238": "\tfinal public boolean isEveryBoxOnABackwardGoal() {\n\n\t\tint[] backwardGoalPositions = board.getGoalPositionsBackward();\n\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tif (isBoxInactive(boxNo)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (board.isBox(backwardGoalPositions[boxNo]) == false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "1239": "\tfinal public boolean isEveryCorralBoxOnAGoal() {\n\n\t\t// check all boxes\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\t// ignore deactivated and non-corral boxes\n\t\t\tif (isBoxInactive(boxNo) || isBoxInCorral(boxNo) == false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (board.isBoxOnGoal(boxPositions[boxNo]) == false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "1242": "\tfinal public void setAllBoxesNotFrozen() {\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tisBoxFrozen[boxNo] = false;\n\t\t}\n\t}\n",
    "1243": "\tpublic long length() {\n\t\treturn size;\n\t}\n",
    "1244": "\tpublic byte getAt(long lax) {\n\t\tif ((lax < 0) || (lax >= size)) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\"lax=\"+lax+\",size=\"+size);\n\t\t}\n\t\tif (lax < blocksize) {\n\t\t\t// the simple case: one flat array\n\t\t\treturn (arrvec[0][ (int)lax ]);\n\t\t}\n\t\tlong blockno = lax / blocksize;\n\t\tlong eleminx = lax % blocksize;\n\t\treturn (arrvec[(int)blockno][(int)eleminx]);\n\t}\n",
    "1246": "\tpublic byte putAt(long lax, byte val) {\n\t\tif (lax < blocksize) {\n\t\t\t// the simple case: one flat array\n\t\t\treturn (arrvec[0][ (int)lax ] = val);\n\t\t}\n\t\tlong blockno = lax / blocksize;\n\t\tlong eleminx = lax % blocksize;\n\t\t// FFS/hm: index out of range\n\t\treturn (arrvec[(int)blockno][(int)eleminx] = val);\n\t}\n",
    "1248": "\tpublic byte orAt(long lax, byte val) {\n\t\tif (lax < blocksize) {\n\t\t\t// the simple case: one flat array\n\t\t\treturn (arrvec[0][ (int)lax ] |= val);\n\t\t}\n\t\tlong blockno = lax / blocksize;\n\t\tlong eleminx = lax % blocksize;\n\t\t// FFS/hm: index out of range\n\t\treturn (arrvec[(int)blockno][(int)eleminx] |= val);\n\t}\n",
    "1253": "\tpublic long getNumBitsAt( long bitlax, int totbits ) {\n\t\tif (totbits > 64 || totbits < 0) {\n\t\t\tthrow new java.lang.UnsupportedOperationException(\"bits=\"+totbits);\n\t\t}\n\t\t// asserted: 0 <= totbits <= 64\n\t\tlong result = 0;\n\t\t\n\t\tint  resoff = 0;\n\t\twhile (totbits > resoff) {\n\t\t\tint  toget  = totbits - resoff;\n\t\t\tbyte bitoff = (byte)(bitlax & 0x07);\t// [0..7]\n\t\t\tlong lax    = bitlax >>> 3;\n\n\t\t\tint bitlen = 8 - bitoff;\t\t// so many in this byte [1..8]\n\t\t\tif (bitlen > toget) {\n\t\t\t\tbitlen = toget;\n\t\t\t}\n\t\t\tlong v    = getAt(lax) & 0xffL;\n\t\t\tv      >>>= bitoff;\n\t\t\tv        &= (1L << bitlen) - 1;\n\n\t\t\tresult |= (v << resoff);\n\t\t\tresoff += bitlen;\n\t\t\tbitlax += bitlen;\n\t\t}\n\t\treturn result;\n\t}\n",
    "1257": "\tpublic void showMissingFileDialog(String filePath, int messageType) {\n\t\tJOptionPane.showMessageDialog(\n\t\t\t\tparent,\n\t\t\t\t\"File: \" + filePath + \" is missing!\",\n\t\t\t\t\"Error\",\n\t\t\t\tmessageType);\n\n\t\tif (messageType == JOptionPane.ERROR_MESSAGE) {\n\t\t\tsetBlankProject();\n\t\t}\n\t}\n",
    "1258": "\tpublic boolean isEmpty() {\n\t\treturn root == null;\n\t}\n",
    "1259": "\tpublic void clear() {\n\t\tthis.root      = null;\n\t\tthis.elemcount = 0;\n\t}\n",
    "1264": "\tprivate Properties loadPropertiesByFilename(String fileName) throws IOException {\n\n\t\t// Create new properties.\n\t\tProperties tempProp = new Properties();\n\n\t\t// Get input stream to the property file.\n\t\tInputStream inPropFile = Utilities.getInputStream(fileName);\n\t\t\n\t\ttry {\n\t\t\t// Load properties.\n\t\t\ttempProp.load(inPropFile);\n\t\t\t\n\t\t\t// Close file.\n\t\t\tinPropFile.close();\n\t\t}\n\t\tcatch(Exception e) {\n\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t}\n\n\t\t// Return the read properties.\n\t\treturn tempProp;\n\n\t}\n",
    "1268": "\tprivate Properties loadPropertiesByLanguageCode(String languageCode) throws IOException {\n\n\t\t// Return the read properties.\n\t\treturn loadPropertiesByFilename(getFilepathFromLanguageCode(languageCode));\n\n\t}\n",
    "1275": "\tpublic V rd(long inx) {\n\t\treturn rd(root, MAX_DEP, inx);\n\t}\n",
    "1277": "\tprivate void paput(Inner<V> pa, byte painx, Node<V> nref) {\n\t\tif (pa == null) {\n\t\t\troot = nref;\n\t\t} else {\n\t\t\t// Store leaf where we found the null in the last step\n\t\t\tpa.iput(painx, nref);\n\t\t}\n\t}\n",
    "1278": "\tprivate void reloadGUI() {\n\t\tchangeLanguageComboBoxes();\n\n\t\tloadLanguageTexts(NEW_LANGUAGE_COLUMN);\n\t\tloadLanguageTexts(HINT_LANGUAGE_COLUMN);\n\n\t\t// Set new and hint language combo boxes for default values.\n\t\tString language = (new Locale(Settings.get(\"newTranslationLanguage\"))).getDisplayLanguage(getUserLocale());\n\n\t\tnewLanguageComboBox.setSelectedItem(language);\n\n\t\tlanguage = (new Locale(Settings.get(\"hintTranslationLanguage\"))).getDisplayLanguage(getUserLocale());\n\t\thintLanguageComboBox.setSelectedItem(language);\n\n\t\t// By default select the first row of the table.\n\t\tif (table.getRowCount() > 0) {\n\t\t\ttable.changeSelection(0, NEW_LANGUAGE_COLUMN, false, false);\n\t\t}\n\t}\n",
    "1279": "\tpublic void redraw(boolean waitForEnter) {\n\n\t\t// Draw the new GUI.\n\t\tapplicationGUI.mainBoardDisplay.repaint();\n\n\t\t// For debugging purposes wait for \"Enter\"\n\t\tif (waitForEnter) {\n\t\t\tJDialog dialog = new JOptionPane(\"\").createDialog(null, \"Waiting for Enter\");\n\t\t\tdialog.setLocation(getX() + getWidth() + 45, getY() + 10);\n\t\t\tdialog.setVisible(true);\n\t\t\t// Beginners explanation: The above dialog is \"modal\", and hence freezes\n\t\t\t// all other graphics activity.  That way \"we wait\" by being frozen.\n\t\t\t// When \"setVisible(true)\" returns, the dialog is done!\n\t\t}\n\t}\n",
    "1281": "\tpublic V wr(long inx, V val) {\n\t\treturn wr(root, MAX_DEP, inx, val);\n\t}\n",
    "1283": "\tfinal public void removeBox(int position) {\n\t\tboxesArray[position] = false;\n\t}\n",
    "1287": "\tprivate void calculateLowerboundOfAllLevel() {\n\n\t\tfinal int maxLevelNo = currentLevelCollection.getNumberOfLevels();\n\t\tint[] lowerbounds = new int[1 + maxLevelNo];\n\n\t\tfor (int levelNo = 1; levelNo <= maxLevelNo; levelNo++) {\n\t\t\tsetLevelForPlaying(levelNo);\n\t\t\tlowerbounds[levelNo] = board.lowerbound.calculateLowerbound(SearchDirection.FORWARD);\n\t\t}\n\n\t\tfor (int levelNo = 1; levelNo <= maxLevelNo; levelNo++) {\n\t\t\tSystem.out.printf(\"Level: %3d  Name: %-60s Lowerbound: %3d \\n\",\n\t\t\t\t\tlevelNo, currentLevelCollection.getLevel(levelNo).getTitle(), lowerbounds[levelNo]);\n\t\t}\n\t}\n",
    "1290": "\t\t\tpublic void run() {\n\n\t\t\t\ttry {\n\t\t\t\t\t// Start a new forward search.\n\t\t\t\t\tforwardSearch();\n\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\t// Stop the optimizer by setting the proper stop reason.\n\t\t\t\t\toptimizerStatus = OptimizerStatus.STOPPED_DUE_TO_OUT_OF_MEMORY;\n\t\t\t\t}\n\n\t\t\t}\n",
    "1291": "\tfinal public void removeBoxByNumber(int boxNo) {\n\t\tboxesArray[boxData.getBoxPosition(boxNo)] = false;\n\t}\n",
    "1296": "\tpublic boolean isPlayModeActivated() {\n\t\treturn gameMode == GameMode.PLAY;\n\t}\n",
    "1300": "\tfinal public void removeBox(int x, int y) {\n\t\tboxesArray[x + width * y] = false;\n\t}\n",
    "1304": "\tpublic boolean isEditorModeActivated() {\n\t\treturn gameMode == GameMode.EDITOR;\n\t}\n",
    "1308": "\tfinal public void removeWall(int position) {\n\t\twallsArray[position] -= ((wallsArray[position] > 0) ? 1 : 0);\n\t}\n",
    "1313": "\tprivate void setInvalidLevelMode() {\n\t\tapplicationGUI.setInvalidLevelModeDependentObjectsEnabled(false);\n\t\tgameMode = GameMode.INVALID_LEVEL;\n\t}\n",
    "1319": "\tfinal public void removeWall(int x, int y) {\n\t\twallsArray[x + width * y] -= ((wallsArray[x + width * y] > 0) ? 1 : 0);\n\t}\n",
    "1344": "\tfinal public void removeGoal(int position) {\n\t\tgoalsArray[position] = false;\n\t}\n",
    "1373": "\tfinal public void removeGoal(int x, int y) {\n\t\tgoalsArray[x + width * y] = false;\n\t}\n",
    "1378": "\tpublic long firstInx() {\n\t\tif (isEmpty()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tArrEntry<V> e = findFiLa(true, true, null);\n\t\treturn e.inx;\n\t}\n",
    "1384": "\tpublic long lastInx() {\n\t\tif (isEmpty()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tArrEntry<V> e = findFiLa(false, true, null);\n\t\treturn e.inx;\n\t}\n",
    "1393": "\tfinal public void removePlayer() {\n\t\tplayerPosition = NO_PLAYER;\n\t}\n",
    "1453": "\tfinal public void setBox(int position) {\n\t\tboxesArray[position] = true;\n\t}\n",
    "1496": "    public String send(){\n        //do real logic\n        return (\"success\");\n    }\n",
    "1503": "\tfinal public void setBox(int x, int y) {\n\t\tboxesArray[x + width * y] = true;\n\t}\n",
    "1518": "\tprivate int nextLockId() {\n\t\tif (nextLockId==Integer.MAX_VALUE) nextLockId = Integer.MIN_VALUE;\n\t\treturn nextLockId++;\n\t}\n",
    "1519": "\tprivate void decrementLock(Object key, Lock lock) throws CacheException {\n\t\t//decrement the lock\n\t\tlock.unlock( cache.nextTimestamp() );\n\t\tif ( cache instanceof ClusterCache)\n\t\t\t((ClusterCache)cache).putQuiet(key, lock);\n\t\telse\n\t\t\tcache.put(key, lock);\n\t}\n",
    "1534": "    public Object get(Object key) throws CacheException {\n        try {\n            if ( log.isDebugEnabled() ) {\n                log.debug(\"key: \" + key);\n            }\n            if (key == null) {\n                return null;\n            } \n            else {\n                Element element = cache.get( (Serializable) key );\n                if (element == null) {\n                    if ( log.isDebugEnabled() ) {\n                        log.debug(\"Element for \" + key + \" is null\");\n                    }\n                    return null;\n                } \n                else {\n                    return element.getValue();\n                }\n            }\n        } \n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1536": "\tfinal public void setBoxWithNo(int boxNo, int position) {\n\t\tboxesArray[position] = true;\n\t\tboxNumbers[position] = boxNo;\n\t}\n",
    "1537": "    public void put(Object key, Object value) throws CacheException {\n        try {\n            Element element = new Element( (Serializable) key, (Serializable) value );\n            cache.put(element);\n        } \n        catch (IllegalArgumentException e) {\n            throw new CacheException(e);\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n\n    }\n",
    "1538": "    public void remove(Object key) throws CacheException {\n        try {\n            cache.remove( (Serializable) key );\n        } \n        catch (ClassCastException e) {\n            throw new CacheException(e);\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1540": "    public void clear() throws CacheException {\n        try {\n            cache.removeAll();\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        } \n        catch (IOException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1542": "    public void destroy() throws CacheException {\n        try {\n            CacheManager.getInstance().removeCache( cache.getName() );\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        } \n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1543": "    public void lock(Object key) throws CacheException {\n    }\n",
    "1545": "    public void unlock(Object key) throws CacheException {\n    }\n",
    "1546": "\tprivate void setUndoRedoFromHistory() {\n\t\tapplicationGUI.setUndoButtonsEnabled(movementHistory.hasPrecedingMovement());\n\t\tapplicationGUI.setRedoButtonsEnabled(movementHistory.hasSuccessorMovement());\n\t}\n",
    "1547": "\t\tpublic long getFreshTimestamp() {\n\t\t\treturn freshTimestamp;\n\t\t}\n",
    "1548": "    public long nextTimestamp() {\n        return Timestamper.next();\n    }\n",
    "1549": "    public int getTimeout() {\n        // 60 second lock timeout\n        return Timestamper.ONE_MS * 60000;\n    }\n",
    "1550": "\t\tpublic Object getValue() {\n\t\t\treturn value;\n\t\t}\n",
    "1552": "\t\tpublic Lock lock(long timeout, int id) {\n\t\t\treturn new Lock(timeout, id, version);\n\t\t}\n",
    "1554": "\t\tpublic boolean isLock() {\n\t\t\treturn false;\n\t\t}\n",
    "1555": "\t\tpublic boolean isGettable(long txTimestamp) {\n\t\t\treturn freshTimestamp < txTimestamp;\n\t\t}\n",
    "1558": "\t\tpublic boolean isPuttable(long txTimestamp, Object newVersion, Comparator comparator) {\n\t\t\t// we really could refresh the item if it  \n\t\t\t// is not a lock, but it might be slower\n\t\t\t//return freshTimestamp < txTimestamp\n\t\t\treturn  ( version!=null && newVersion!=null)&& comparator.compare(version, newVersion) < 0;\n\t\t}\n",
    "1561": "\tfinal public void setBoxWithNo(int boxNo, int x, int y) {\n\t\tboxesArray[x + width * y] = true;\n\t\tboxNumbers[x + width * y] = boxNo;\n\t}\n",
    "1563": "\tpublic boolean greaterThan(LockMode mode) {\n\t\treturn level > mode.level;\n\t}\n",
    "1564": "\tpublic boolean lessThan(LockMode mode) {\n\t\treturn level < mode.level;\n\t}\n",
    "1572": "\t\tpublic Lock lock(long timeout, int id) {\n\t\t\tconcurrentLock = true;\n\t\t\tmultiplicity++;\n\t\t\tthis.timeout = timeout;\n\t\t\treturn this;\n\t\t}\n",
    "1579": "\t\tpublic void unlock(long currentTimestamp) {\n\t\t\tif ( --multiplicity == 0 ) {\n\t\t\t\tunlockTimestamp = currentTimestamp;\n\t\t\t}\n\t\t}\n",
    "1587": "\t\tpublic boolean isPuttable(long txTimestamp, Object newVersion, Comparator comparator) {\n\t\t\tif (timeout < txTimestamp) return true;\n\t\t\tif (multiplicity>0) return false;\n\t\t\treturn version==null || newVersion==null? \n\t\t\t\tunlockTimestamp < txTimestamp :\n\t\t\t\tcomparator.compare(version, newVersion) < 0; //by requiring <, we rely on lock timeout in the case of an unsuccessful update!\n\t\t}\n",
    "1592": "\t\tpublic boolean wasLockedConcurrently() {\n\t\t\treturn concurrentLock;\n\t\t}\n",
    "1599": "\t\tpublic boolean isLock() {\n\t\t\treturn true;\n\t\t}\n",
    "1605": "\t\tpublic boolean isGettable(long txTimestamp) {\n\t\t\treturn false;\n\t\t}\n",
    "1617": "\tfinal public void setBoxOnGoal(int position) {\n\t\tboxesArray[position] = true;\n\t\tgoalsArray[position] = true;\n\t}\n",
    "1634": "    public Mapper createMapper() throws BuildException {\n        if (_mapper != null) {\n            throw new BuildException(\"Cannot define more than one mapper\");\n        }\n        _mapper = new Mapper(this.getProject());\n        return _mapper;\n    }\n",
    "1638": "\tprivate void exportLevelToClipboard(boolean withRLE) {\n\t\texportLevelToClipboard(withRLE, false);\n\t}\n",
    "1647": "\tfinal public void setBoxOnGoal(int x, int y) {\n\t\tboxesArray[x + width * y] = true;\n\t\tgoalsArray[x + width * y] = true;\n\t}\n",
    "1665": "\tfinal public void setGoal(int position) {\n\t\tgoalsArray[position] = true;\n\t}\n",
    "1680": "\tfinal public void setGoal(int x, int y) {\n\t\tgoalsArray[x + width * y] = true;\n\t}\n",
    "1692": "\tfinal public void setWall(int position) {\n\t\twallsArray[position]++;\n\t}\n",
    "1704": "\tfinal public void setWall(int x, int y) {\n\t\twallsArray[x + width * y]++;\n\t}\n",
    "1716": "\tfinal public void setBoxNo(int boxNo, int position) {\n\t\tboxNumbers[position] = boxNo;\n\t}\n",
    "1727": "\tfinal public void setBoxNo(int boxNo, int x, int y) {\n\t\tboxNumbers[x + width * y] = boxNo;\n\t}\n",
    "1738": "\tfinal public void setAdvancedSimpleDeadlock(int position) {\n\t\tadvancedSimpleDeadlockSquareForwards[position] = true;\n\t}\n",
    "1761": "\tfinal public void setPlayerPosition(int position) {\n\t\tplayerPosition = position;\n\t}\n",
    "1778": "\tfinal public void setPlayerPosition(int x, int y) {\n\t\tplayerPosition = x + width * y;\n\t}\n",
    "1808": "\tfinal public boolean isCorralForcerSquare(int position) {\n\t\treturn corralForcer[position];\n\t}\n",
    "1837": "\tfinal public boolean isCorralForcerSquare(int x, int y) {\n\t\treturn corralForcer[x + width * y];\n\t}\n",
    "1865": "\tfinal public boolean isBox(int position) {\n\t\treturn boxesArray[position];\n\t}\n",
    "1889": "\tfinal public boolean isBox(int x, int y) {\n\t\treturn boxesArray[x + width * y];\n\t}\n",
    "1911": "\tfinal public boolean isWall(int position) {\n\t\treturn wallsArray[position] > 0;\n\t}\n",
    "1916": "\tpublic boolean isABoxSelected() {\n\t\treturn isABoxSelected;\n\t}\n",
    "1931": "\tfinal public boolean isWall(int x, int y) {\n\t\treturn wallsArray[x + width * y] > 0;\n\t}\n",
    "1946": "\tpublic boolean isHighLightingOfPlayerReachableSquaresActivated() {\n\t\treturn isHighLightOfPlayerSquaresActivated;\n\t}\n",
    "1956": "\tpublic void setAntInstallLib(File antInstallLib) {\n\t\tthis.antInstallLib = antInstallLib;\n\t\tFileSet set = new FileSet();\n\t\tset.setFile(new File(antInstallLib,\"tikal-antinstaller.jar\"));\n\t\tset.setFile(new File(antInstallLib,\"sysout.jar\"));\n\t\taddZipGroupFileset(set);\n\t}\n",
    "1958": "\tpublic void setAntLib(File antLib) {\n\t\tthis.antLib = antLib;\n\t\tFileSet set = new FileSet();\n\t\tset.setFile(new File(antLib,\"tikal-ant.jar\"));\n\t\tset.setFile(new File(antLib,\"ant-launcher.jar\"));\n\t\taddZipGroupFileset(set);\n\t}\n",
    "1959": "\tfinal public boolean isGoal(int position) {\n\t\treturn goalsArray[position];\n\t}\n",
    "1991": "\tpublic int getSelectedBoxPosition() {\n\t\treturn selectedBoxPosition;\n\t}\n",
    "2003": "\tfinal public boolean isGoal(int x, int y) {\n\t\treturn goalsArray[x + width * y];\n\t}\n",
    "2086": "\tpublic boolean isGoalOrWall(int position) {\n\t\treturn goalsArray[position] || wallsArray[position] > 0;\n\t}\n",
    "2156": "\tprivate void redoMovementInOwnThread(final boolean redoAllMovements) {\n\t\t\n\t\tmovePlayerThread = new Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tredoMovement(redoAllMovements);\n\n\t\t\t\t// The \"setUndoRedoFromHistory()\" has happened already.\n\n\t\t\t\t// This thread has finished its work. The thread isn't needed any more.\n\t\t\t\tmovePlayerThread = null;\n\t\t\t}\n\t\t};\n\t\tmovePlayerThread.start();\n\t}\n",
    "2159": "\tfinal public boolean isCorralForcer(int position) {\n\t\treturn corralForcer[position] == true;\n\t}\n",
    "2165": "    public List getKeysWithExpiryCheck() throws IllegalStateException, CacheException {\n        List allKeyList = getKeys();\n        //remove keys of expired elements\n        ArrayList nonExpiredKeys = new ArrayList(allKeyList.size());\n        int allKeyListSize = allKeyList.size();\n        for (int i = 0; i < allKeyListSize; i++) {\n            Serializable key = (Serializable) allKeyList.get(i);\n            Element element = getQuiet(key);\n            if (element != null) {\n                nonExpiredKeys.add(key);\n            }\n        }\n        nonExpiredKeys.trimToSize();\n        return nonExpiredKeys;\n    }\n",
    "2169": "\tfinal public boolean isGoalBackwardsSearch(int position) {\n\t\treturn goalSquareBackwardsSearch[position];\n\t}\n",
    "2175": "    public long getMemoryStoreSize() throws IllegalStateException {\n        checkStatus();\n        return memoryStore.getSize();\n    }\n",
    "2177": "    public int getDiskStoreSize() throws IllegalStateException {\n        checkStatus();\n        if (overflowToDisk) {\n            return diskStore.getSize();\n        } else {\n            return 0;\n        }\n    }\n",
    "2180": "\tfinal public boolean isGoalBackwardsSearch(int x, int y) {\n\t\treturn goalSquareBackwardsSearch[x + width * y];\n\t}\n",
    "2181": "    public Status getStatus() {\n        return status;\n    }\n",
    "2186": "\tprivate void undoMovementInOwnThread() {\n\n\t\tmovePlayerThread = new Thread() {\n\t\t\t@SuppressWarnings(\"synthetic-access\")\n\t\t\tpublic void run() {\n\t\t\t\tundoMovement();\n\n\t\t\t\t// Enable / disable the undo / redo button depending on the history status.\n\t\t\t\tsetUndoRedoFromHistory();\t\t\t}\n\t\t};\n\t\tmovePlayerThread.start();\n\t}\n",
    "2187": "    public void setDocumentLocator(Locator locator) {\n        this.locator = locator;\n    }\n",
    "2191": "    public int getMemoryStoreHitCount() throws IllegalStateException {\n        checkStatus();\n        return memoryStoreHitCount;\n    }\n",
    "2193": "\tfinal public boolean isEmptySquare(int position) {\n\t\treturn ! (boxesArray[position] || wallsArray[position] > 0 || goalsArray[position]);\n\t}\n",
    "2195": "    public int getDiskStoreHitCount() throws IllegalStateException {\n        checkStatus();\n        return diskStoreHitCount;\n    }\n",
    "2196": "    private Method findCreateMethod(Class objClass, String name) {\n        final String methodName = makeMethodName(\"create\", name);\n        final Method[] methods = objClass.getMethods();\n        for (int i = 0; i < methods.length; i++) {\n            final Method method = methods[i];\n            if (!method.getName().equals(methodName)) {\n                continue;\n            }\n            if (Modifier.isStatic(method.getModifiers())) {\n                continue;\n            }\n            if (method.getParameterTypes().length != 0) {\n                continue;\n            }\n            if (method.getReturnType().isPrimitive() || method.getReturnType().isArray()) {\n                continue;\n            }\n            return method;\n        }\n\n        return null;\n    }\n",
    "2197": "    private String makeMethodName(final String prefix, final String name) {\n        return prefix + Character.toUpperCase(name.charAt(0)) + name.substring(1);\n    }\n",
    "2198": "    public int getMissCountNotFound() throws IllegalStateException {\n        checkStatus();\n        return missCountNotFound;\n    }\n",
    "2203": "    public int getMissCountExpired() throws IllegalStateException {\n        checkStatus();\n        return missCountExpired;\n    }\n",
    "2205": "\tfinal public boolean isEmptySquare(int x, int y) {\n\t\treturn ! (   boxesArray[x + width * y]\n\t\t          || wallsArray[x + width * y] > 0\n\t\t          || goalsArray[x + width * y]     );\n\t}\n",
    "2207": "    public String getName() {\n        return name;\n    }\n",
    "2208": "    private String getLocation() {\n        return locator.getSystemId() + ':' + locator.getLineNumber();\n    }\n",
    "2209": "    public long getTimeToIdleSeconds() {\n        return timeToIdleSeconds;\n    }\n",
    "2211": "    public long getTimeToLiveSeconds() {\n        return timeToLiveSeconds;\n    }\n",
    "2213": "\tfinal public boolean isAccessible(int position) {\n\t\treturn ! (wallsArray[position] > 0 || boxesArray[position]);\n\t}\n",
    "2219": "    public boolean isOverflowToDisk() {\n        return overflowToDisk;\n    }\n",
    "2221": "    public int getMaxElementsInMemory() {\n        return maxElementsInMemory;\n    }\n",
    "2223": "\tfinal public boolean isAccessible(int x, int y) {\n\t\treturn ! (wallsArray[x + width * y] > 0 || boxesArray[x + width * y]);\n\t}\n",
    "2224": "    public MemoryStoreEvictionPolicy getMemoryStoreEvictionPolicy() {\n        return memoryStoreEvictionPolicy;\n    }\n",
    "2225": "    public String getDiskCachePath() {\n        if (diskStore != null) {\n            return diskStore.path;\n        } else {\n            return null;\n        }\n    }\n",
    "2227": "    public Set getCacheKeySet() {\n        return caches.keySet();\n    }\n",
    "2229": "    public boolean isExpired(Element element) throws IllegalStateException, NullPointerException {\n        checkStatus();\n        boolean expired;\n        synchronized (element) {\n            if (element.getValue() == null) {\n                expired = true;\n            }\n            if (!eternal) {\n                expired = checkExpirationForNotEternal(element);\n            } else {\n                expired = false;\n            }\n            if (LOG.isDebugEnabled()) {\n                Serializable key = null;\n                if (element != null) {\n                    key = element.getKey();\n                }\n                LOG.debug(getName() + \": Is element with key \" + key + \" expired?: \" + expired);\n            }\n            return expired;\n        }\n    }\n",
    "2233": "\tfinal public boolean isAccessibleBox(int position) {\n\t\treturn ! (   wallsArray[position] > 0\n\t\t\t\t  || boxesArray[position]\n\t\t\t\t  || simpleDeadlockSquareForwards[position]\n\t\t\t\t  || advancedSimpleDeadlockSquareForwards[position] );\n\t}\n",
    "2235": "    public Object clone() throws CloneNotSupportedException {\n        if (!(memoryStore == null && diskStore == null)) {\n            throw new CloneNotSupportedException(\"Cannot clone an initialized cache.\");\n        }\n        //added by yanai\n        Cache cache = (Cache) super.clone();\n        cache.cacheEventNotificationService = new CacheEventNotificationService(cache);\n        return cache;\n       //end of add\n    }\n",
    "2238": "        public void setClass(String fullyQualifiedClassPath) {\n            this.fullyQualifiedClassPath = fullyQualifiedClassPath;\n        }\n",
    "2241": "\tfinal public boolean isAccessibleBox(int x, int y) {\n\t\treturn ! (   wallsArray[x + width * y] > 0\n\t\t\t\t  || boxesArray[x + width * y]\n\t\t\t\t  || simpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t  || advancedSimpleDeadlockSquareForwards[x + width * y] );\n\t}\n",
    "2242": "        public void setName(String name) {\n            this.name = name;\n        }\n",
    "2243": "    public CacheEventNotificationService getCacheEventNotificationService() {\n        return cacheEventNotificationService;\n    }\n",
    "2244": "        public void setMaxElementsInMemory(int maxElementsInMemory) {\n            this.maxElementsInMemory = maxElementsInMemory;\n        }\n",
    "2247": "    public void notifyElementRemoved(Element element) {\n        Iterator iterator = cacheEventListeners.iterator();\n        while (iterator.hasNext()) {\n            CacheEventListener cacheEventListener = (CacheEventListener) iterator.next();\n            cacheEventListener.notifyElementRemoved(cache, element);\n        }\n    }\n",
    "2248": "        public void setMemoryStoreEvictionPolicy(String memoryStoreEvictionPolicy) {\n            this.memoryStoreEvictionPolicy = MemoryStoreEvictionPolicy.fromString(memoryStoreEvictionPolicy);\n        }\n",
    "2251": "    public void notifyElementExpiry(Element element) {\n        Iterator iterator = cacheEventListeners.iterator();\n        while (iterator.hasNext()) {\n            CacheEventListener cacheEventListener =  (CacheEventListener) iterator.next();\n            cacheEventListener.notifyElementExpired(cache, element);\n        }\n    }\n",
    "2252": "    public boolean registerListener(CacheEventListener cacheEventListener) {\n        return cacheEventListeners.add(cacheEventListener);\n    }\n",
    "2253": "    public boolean unregisterListener(CacheEventListener cacheEventListener) {\n        return cacheEventListeners.remove(cacheEventListener);\n    }\n",
    "2254": "    public Set getCacheEventListeners() {\n        return cacheEventListeners;\n    }\n",
    "2255": "\tfinal public boolean isWallOrIllegalSquare(int position) {\n\t\treturn     wallsArray[position] > 0\n\t\t\t\t|| simpleDeadlockSquareForwards[position]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[position];\n\t}\n",
    "2261": "        public void setEternal(boolean eternal) {\n            this.eternal = eternal;\n        }\n",
    "2266": "\tpublic boolean isLevelValid() {\n\n\t\tStringBuilder validityMessage = new StringBuilder();\n\n\t\t// Let the board check if it is valid.\n\t\tboolean levelIsValid = board.isValid(validityMessage);\n\n\t\t// If the level is invalid the editor mustn't be left and the\n\t\t// reason for the invalidity is displayed.\n\t\tif (levelIsValid == false) {\n\t\t\tdisplayInfotext(validityMessage.toString());\n\t\t\tapplicationGUI.setEditorMenuItemEnabled(false);\n\t\t} else {\n\t\t\tdisplayInfotext(\"\");\n\t\t\tapplicationGUI.setEditorMenuItemEnabled(true);\n\t\t}\n\n\t\treturn levelIsValid;\n\t}\n",
    "2268": "\tpublic void sendNotification(ClusterNotification message) {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"sendNotification : \" + message);\n\t\tbus.sendNotification(message);\n\t}\n",
    "2270": "        public void setTimeToIdleSeconds(int timeToIdleSeconds) {\n            this.timeToIdleSeconds = timeToIdleSeconds;\n        }\n",
    "2272": "\tpublic Serializable getCache() {\n\t\treturn \"BroadcastingManager: \" + bus.getLocalAddress();\n\t}\n",
    "2273": "\tpublic void memberJoined(Address address) {\n\t\tif (log.isInfoEnabled()) {\n\t\t\tlog.info(\"A new member at address '\" + address + \"' has joined the cluster\");\n\t\t}\n\t}\n",
    "2274": "\tpublic void memberLeft(Address address) {\n\t\tif (log.isInfoEnabled()) {\n\t\t\tlog.info(\"Member at address '\" + address + \"' left the cluster\");\n\t\t}\n\t}\n",
    "2278": "        public void setTimeToLiveSeconds(int timeToLiveSeconds) {\n            this.timeToLiveSeconds = timeToLiveSeconds;\n        }\n",
    "2280": "\tfinal public boolean isWallOrIllegalSquare(int x, int y) {\n\t\treturn     wallsArray[x + width * y] > 0\n\t\t\t\t|| simpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[x + width * y];\n\t}\n",
    "2281": "    public void shutdown() {\n        if (status.equals(Status.STATUS_SHUTDOWN)) {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(\"CacheManager already shutdown\");\n            }\n            return;\n        }\n        synchronized (CacheManager.class) {\n            allCacheManagersDiskStorePaths.remove(diskStorePath);\n            Enumeration allCaches = caches.elements();\n            while (allCaches.hasMoreElements()) {\n                Cache cache = (Cache) allCaches.nextElement();\n                if (cache != null) {\n                    cache.dispose();\n                }\n            }\n            if ( getBroadcastingManager()!=null) getBroadcastingManager().stop();\n            status = Status.STATUS_SHUTDOWN;\n            \n            //only delete singleton if the singleton is shutting down.\n            if (this == singleton) {\n                singleton = null;\n            }\n        }\n    }\n",
    "2283": "        public void setOverflowToDisk(boolean overflowToDisk) {\n            this.overflowToDisk = overflowToDisk;\n        }\n",
    "2285": "        public void setDiskPersistent(boolean diskPersistent) {\n            this.diskPersistent = diskPersistent;\n        }\n",
    "2288": "        public void setDiskExpiryThreadIntervalSeconds(int diskExpiryThreadIntervalSeconds) {\n            this.diskExpiryThreadIntervalSeconds = diskExpiryThreadIntervalSeconds;\n        }\n",
    "2291": "\tfinal public boolean isOuterSquareOrWall(int position) {\n\t\treturn    ! playersReachableSquaresOnlyWallsAtLevelStart[position]\n\t\t       || wallsArray[position] > 0;\n\t}\n",
    "2311": "\tfinal public boolean isSimpleDeadlockSquare(int position) {\n\t\treturn     simpleDeadlockSquareForwards[position]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[position]\n\t\t\t\t|| simpleDeadlockSquareBackwards[position];\n\t}\n",
    "2329": "\tpublic void start(BundleContext context) throws Exception {\n\t\tsuper.start(context);\n\t}\n",
    "2331": "\tpublic void stop(BundleContext context) throws Exception {\n\t\tsuper.stop(context);\n\t\tplugin = null;\n\t}\n",
    "2338": "    protected void giveFocusToProjectsNames() {\n        projectsNamesCombo.setFocus();\n    }\n",
    "2351": "\tfinal public boolean isSimpleDeadlockSquare(int x, int y) {\n\t\treturn     simpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t|| simpleDeadlockSquareBackwards[x + width * y];\n\t}\n",
    "2362": "\tpublic void setCurrentCollection(LevelCollection levelCollection) {\n\n\t\tcurrentLevelCollection = levelCollection;\n\n\t\t// Update the combo box showing all levels.\n\t\tupdateLevelComboBox();\n\t\t\n//\t\tif (Settings.isDebugModeActivated) {\n//\t\t\tSystem.out.println( \"Set collection with \"\n//\t\t\t\t\t            + levelCollection.getNumberOfLevels() + \" levels\" );\n//\t\t\tSystem.out.println( \"  ID = \" + levelCollection.getDatabaseID());\n//\t\t\tSystem.out.println( \"  title = \" + levelCollection.getTitle());\n//\t\t}\n\t}\n",
    "2377": "\tprotected String handleDirectoryBrowse(String path) {\n\t\tDirectoryDialog directoryDialog = new DirectoryDialog(getShell());\n\t\tif (path != null && !\"\".equals(path)) {\n\t\t\tdirectoryDialog.setFilterPath(path);\n\t\t}\n\t\tString dirName = directoryDialog.open();\n\n\t\treturn dirName;\n\t}\n",
    "2378": "\tfinal public boolean isSimpleDeadlockSquareForwardsDebug(int position) {\n\t\treturn simpleDeadlockSquareForwards[position];\n\t}\n",
    "2418": "\tfinal public boolean isSimpleDeadlockSquareForwardsDebug(int x, int y) {\n\t\treturn simpleDeadlockSquareForwards[x + width * y];\n\t}\n",
    "2441": "\tfinal public boolean isSimpleDeadlockSquareBackwardsDebug(int position) {\n\t\treturn simpleDeadlockSquareBackwards[position];\n\t}\n",
    "2449": "\tpublic String collectionTitleOfLevelID(int levelID) {\n\t\tif (findLevelByID(levelID) != null) {\n\t\t\treturn currentLevelCollection.getTitle();\n\t\t}\n\t\treturn null;\n\t}\n",
    "2455": "    public Serializable save(Object obj) throws HibernateException {\n\n        if (obj==null) throw new NullPointerException(\"attempted to save null\");\n\n        Object object = unproxy(obj); //throws exception if uninitialized\n\n        EntityEntry e = getEntry(object);\n        if ( e!=null ) {\n            if ( e.status==DELETED ) {\n                forceFlush(e);\n            }\n            else {\n                log.trace( \"object already associated with session\" );\n                return e.id;\n            }\n        }\n\n        Serializable id = saveWithGeneratedIdentifier(object, Cascades.ACTION_SAVE_UPDATE, null); //id might be generated by SQL insert\n        reassociateProxy(obj, id); //TODO: move into saveWithGeneratedIdentifier()?\n        return id;\n\n    }\n",
    "2463": "\tfinal public boolean isSimpleDeadlockSquareBackwardsDebug(int x, int y) {\n\t\treturn simpleDeadlockSquareBackwards[x + width * y];\n\t}\n",
    "2478": "\tfinal public boolean isAdvancedSimpleDeadlockSquareForwards(int position) {\n\t\treturn advancedSimpleDeadlockSquareForwards[position];\n\t}\n",
    "2488": "\tfinal public boolean isAdvancedSimpleDeadlockSquareForwards(int x, int y) {\n\t\treturn advancedSimpleDeadlockSquareForwards[x + width * y];\n\t}\n",
    "2500": "\tfinal public boolean isBoxOnGoal(int position) {\n\t\treturn boxesArray[position] && goalsArray[position];\n\t}\n",
    "2512": "\tfinal public boolean isBoxOnGoal(int x, int y) {\n\t\treturn boxesArray[x + width * y] && goalsArray[x + width * y];\n\t}\n",
    "2521": "\tfinal public boolean isPlayerInLevel() {\n\t\treturn playerPosition != NO_PLAYER;\n\t}\n",
    "2528": "\tfinal public boolean isMarked(int position) {\n\t\treturn marked[position];\n\t}\n",
    "2543": "\tfinal public boolean isMarked(int x, int y) {\n\t\treturn marked[x + width * y];\n\t}\n",
    "2552": "\tfinal public void removeMarking(int position) {\n\t\tmarked[position] = false;\n\t}\n",
    "2561": "\tfinal public void removeMarking(int x, int y) {\n\t\tmarked[x + width * y] = false;\n\t}\n",
    "2569": "\tfinal public void removeAllMarking() {\n\t\tArrays.fill(marked, false);\t\t\t// this is not time critical\n\t}\n",
    "2576": "\tfinal public void setMarking(int position) {\n\t\tmarked[position] = true;\n\t}\n",
    "2580": "    private void reassociateProxy(LazyInitializer li, HibernateProxy proxy) throws MappingException {\n        if ( li.getSession()!=this ) {\n            ClassPersister persister = getClassPersister( li.getPersistentClass() );\n            Key key = new Key( li.getIdentifier(), persister );\n            if ( !proxiesByKey.containsKey(key) ) proxiesByKey.put(key, proxy); // any earlier proxy takes precedence\n            HibernateProxyHelper.getLazyInitializer( proxy ).setSession(this);\n        }\n    }\n",
    "2583": "\tfinal public void setMarking(int x, int y) {\n\t\tmarked[x + width * y] = true;\n\t}\n",
    "2591": "\tfinal public void assignMarking(int position, boolean markValue) {\n\t\tmarked[position] = markValue;\n\t}\n",
    "2600": "\tfinal public void flipMarking(int position) {\n\t\tmarked[position] = ! marked[position];\n\t}\n",
    "2608": "\tfinal public int getBoxNo(int position) {\n\t\treturn boxNumbers[position];\n\t}\n",
    "2616": "\tfinal public int getGoalNo(int position) {\n\t\treturn goalsNumbers[position];\n\t}\n",
    "2625": "\tfinal public int getGoalPosition(int goalNo) {\n\t\treturn goalsPositions[goalNo];\n\t}\n",
    "2633": "\tfinal public int getPlayerDistance(int fromSquare, int toSquare) {\n\t\treturn playerDistances[fromSquare][toSquare];\n\t}\n",
    "2641": "\tfinal public void setBoardPosition(IBoardPosition position) {\n\t\tsetBoardPosition(position.getPositions());\n\t}\n",
    "2650": "\tfinal public void setBoardPosition(int[] positions) {\n\n\t\t// remove all boxes from the board\n\t\tremoveAllBoxes();\n\n\t\t// store the new box positions in our box data object\n\t\tboxData.setBoxPositions(positions);\n\n\t\t// Put the new boxes into the board\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tsetBoxWithNo(boxNo, positions[boxNo]);\n\t\t}\n\n\t\t// set up the new player location\n\t\tplayerPosition = positions[boxCount];\n\t}\n",
    "2659": "\tfinal public void removeAllBoxes() {\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tremoveBox(boxData.getBoxPosition(boxNo));\n\t\t}\n\t}\n",
    "2668": "\tfinal public void setGoalsBackwardsSearch() {\n\n\t\tint goalNo = 0;\n\n\t\t// Set up the new goals for backwards search, and clear the old ones\n\t\tfor (int position = firstRelevantSquare; position < lastRelevantSquare; position++) {\n\t\t\tif (isBox(position) && isOuterSquareOrWall(position) == false) {\n\t\t\t\tgoalSquareBackwardsSearch[position] = true;\n\t\t\t\tgoalsPositionsBackwardsSearch[goalNo++] = position;\n\t\t\t} else {\n\t\t\t\tgoalSquareBackwardsSearch[position] = false;\n\t\t\t}\n\t\t}\n\t}\n",
    "2683": "    public List find(String query) throws HibernateException {\n        return find(query, NO_ARGS, NO_TYPES);\n    }\n",
    "2781": "\t\tpublic int getBoxDistanceForwardsPlayerPositionIndependentNo(int boxNo, int goalNo) {\n\t\t\treturn getBoxDistanceForwardsPlayerPositionIndependent(boxData.getBoxPosition(boxNo), goalsPositions[goalNo]);\n\t\t}\n",
    "2880": "\tpublic void run(IAction action) {\n\t\tUpdateManagerDialog d = new UpdateManagerDialog(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell());\n\t\td.open();\n\t}\n",
    "2881": "\tpublic void selectionChanged(IAction action, ISelection selection) {\n\t}\n",
    "2882": "\tpublic void dispose() {\n\t}\n",
    "2883": "\tpublic void init(IWorkbenchWindow window) {\n\t\tthis.window = window;\n\t}\n",
    "2930": "    protected boolean allowNewContainerName() {\n        return false;\n    }\n",
    "2961": "    public void aboutToOpen() {\n        determineWhiteCheckedDescendents(root);\n        checkNewTreeElements(treeContentProvider.getElements(root));\n\n        //select the first element in the list\n        Object[] elements = treeContentProvider.getElements(root);\n        Object primary = elements.length > 0 ? elements[0] : null;\n        if (primary != null) {\n            treeViewer.setSelection(new StructuredSelection(primary));\n        }\n        treeViewer.getControl().setFocus();\n    }\n",
    "2963": "    public void addCheckStateListener(ICheckStateListener listener) {\n        addListenerObject(listener);\n    }\n",
    "2964": "    private ITreeContentProvider getResourceProvider(final int resourceType) {\n        return new WorkbenchContentProvider() {\n            @SuppressWarnings(\"unchecked\")\n\t\t\tpublic Object[] getChildren(Object o) {\n                //input element case\n                if (o instanceof ArrayList) {\n                    return ((ArrayList) o).toArray();\n                } \n               return new Object[0];            \t\n            }\n        };\n    }\n",
    "2965": "    protected boolean areAllChildrenWhiteChecked(Object treeElement) {\n        Object[] children = treeContentProvider.getChildren(treeElement);\n        for (int i = 0; i < children.length; ++i) {\n            if (!whiteCheckedTreeItems.contains(children[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n        }\n\n        return true;\n    }\n",
    "2970": "    protected boolean areAllElementsChecked(Object treeElement) {\n        List checkedElements = (List) checkedStateStore.get(treeElement);\n        if (checkedElements == null) {\n\t\t\treturn false;\n\t\t}\n        return true;\n    }\n",
    "2971": "    protected void checkNewTreeElements(Object[] elements) {\n        for (int i = 0; i < elements.length; ++i) {\n            Object currentElement = elements[i];\n            boolean checked = checkedStateStore.containsKey(currentElement);\n            treeViewer.setChecked(currentElement, checked);\n            treeViewer.setGrayed(currentElement, checked\n                    && !whiteCheckedTreeItems.contains(currentElement));\n        }\n    }\n",
    "2972": "    protected Iterator getSelectedResourcesIterator() {\n        return this.resourceGroup.getAllCheckedListItems().iterator();\n    }\n",
    "2974": "    public void checkStateChanged(final CheckStateChangedEvent event) {\n\n        //Potentially long operation - show a busy cursor\n        BusyIndicator.showWhile(treeViewer.getControl().getDisplay(),\n            new Runnable() {\n                public void run() {\n                    if (event.getCheckable().equals(treeViewer)) {\n\t\t\t\t\t\ttreeItemChecked(event.getElement(), event\n                                .getChecked());\n\t\t\t\t\t}\n\n                    notifyCheckStateChangeListeners(event);\n                }\n            });\n    }\n",
    "2975": "    protected List getTypesToExport() {\n        return selectedTypes;\n    }\n",
    "2980": "    protected List getWhiteCheckedResources() {\n        return this.resourceGroup.getAllWhiteCheckedItems();\n    }\n",
    "2981": "    protected void createTreeViewer(Composite parent, boolean useHeightHint) {\n        Tree tree = new Tree(parent, SWT.CHECK | SWT.BORDER);\n        GridData data = new GridData(GridData.FILL_BOTH);\n        if (useHeightHint) {\n\t\t\tdata.heightHint = PREFERRED_HEIGHT;\n\t\t}\n        tree.setLayoutData(data);\n        tree.setFont(parent.getFont());\n\n        treeViewer = new CheckboxTreeViewer(tree);\n        treeViewer.setContentProvider(treeContentProvider);\n        treeViewer.setLabelProvider(treeLabelProvider);\n        treeViewer.addTreeListener(this);\n        treeViewer.addCheckStateListener(this);\n        treeViewer.addSelectionChangedListener(this);\n    }\n",
    "2986": "    protected boolean hasExportableExtension(String resourceName) {\n        if (selectedTypes == null) {\n\t\t\treturn true;\n\t\t}\n\n        int separatorIndex = resourceName.lastIndexOf(\".\"); //$NON-NLS-1$\n        if (separatorIndex == -1) {\n\t\t\treturn false;\n\t\t}\n\n        String extension = resourceName.substring(separatorIndex + 1);\n\n        Iterator it = selectedTypes.iterator();\n        while (it.hasNext()) {\n            if (extension.equalsIgnoreCase((String) it.next())) {\n\t\t\t\treturn true;\n\t\t\t}\n        }\n\n        return false;\n    }\n",
    "2987": "    protected boolean determineShouldBeWhiteChecked(Object treeElement) {\n        return areAllChildrenWhiteChecked(treeElement)\n                && areAllElementsChecked(treeElement);\n    }\n",
    "2990": "    protected void determineWhiteCheckedDescendents(Object treeElement) {\n        // always go through all children first since their white-checked\n        // statuses will be needed to determine the white-checked status for\n        // this tree element\n        Object[] children = treeContentProvider.getElements(treeElement);\n        for (int i = 0; i < children.length; ++i) {\n\t\t\tdetermineWhiteCheckedDescendents(children[i]);\n\t\t}\n\n        // now determine the white-checked status for this tree element\n        if (determineShouldBeWhiteChecked(treeElement)) {\n\t\t\tsetWhiteChecked(treeElement, true);\n\t\t}\n    }\n",
    "2991": "    protected void saveWidgetValues() {\n        // allow subclasses to save values\n        internalSaveWidgetValues();\n    }\n",
    "2992": "    public void expandAll() {\n        treeViewer.expandAll();\n    }\n",
    "2993": "    protected void setupBasedOnInitialSelections() {\n\n        Iterator it = this.initialResourceSelection.iterator();\n        while (it.hasNext()) {\n            IResource currentResource = (IResource) it.next();\n            if (currentResource.getType() != IResource.FILE) {\n\t\t\t\tthis.resourceGroup.initialCheckTreeItem(currentResource);\n\t\t\t}\n        }\n    }\n",
    "2995": "\t\tfinal public boolean isSquareReachable(int position) {\n\t\t\treturn playersReachableSquaresArray[position] == indicatorReachableSquare;\n\t\t}\n",
    "3005": "    protected boolean saveDirtyEditors() {\n        return IDEWorkbenchPlugin.getDefault().getWorkbench().saveAllEditors(\n                true);\n    }\n",
    "3008": "    public List getAllCheckedListItems() {\n\n        final ArrayList returnValue = new ArrayList();\n\n        IElementFilter passThroughFilter = new IElementFilter() {\n\n            @SuppressWarnings(\"unchecked\")\n\t\t\tpublic void filterElements(Collection elements,\n                    IProgressMonitor monitor) {\n                returnValue.addAll(elements);\n            }\n\n            @SuppressWarnings(\"unchecked\")\n\t\t\tpublic void filterElements(Object[] elements,\n                    IProgressMonitor monitor) {\n                for (int i = 0; i < elements.length; i++) {\n                    returnValue.add(elements[i]);\n                }\n            }\n        };\n\n        try {\n            getAllCheckedListItems(passThroughFilter, null);\n        } catch (InterruptedException exception) {\n            return new ArrayList();\n        }\n        return returnValue;\n\n    }\n",
    "3009": "    protected void updateWidgetEnablements() {\n\n        boolean pageComplete = determinePageCompletion();\n        setPageComplete(pageComplete);\n        if (pageComplete) {\n\t\t\tsetMessage(null);\n\t\t}\n        super.updateWidgetEnablements();\n    }\n",
    "3010": "\t\tfinal public PlayersReachableSquares getClone() {\n\t\t\treturn new PlayersReachableSquares(playersReachableSquaresArray, indicatorReachableSquare);\n\t\t}\n",
    "3012": "    public Object instantiate(ClassPersister persister, Serializable id) throws HibernateException {\n        Object result = interceptor.instantiate( persister.getMappedClass(), id );\n        if (result==null) result = persister.instantiate(id);\n        return result;\n    }\n",
    "3013": "    protected void addDestinationItem(String value) {\n        destinationNameField.add(value);\n    }\n",
    "3017": "    public List getAllWhiteCheckedItems() {\n\n        List result = new ArrayList();\n\n        //Iterate through the children of the root as the root is not in the store\n        Object[] children = treeContentProvider.getChildren(root);\n        for (int i = 0; i < children.length; ++i) {\n            findAllWhiteCheckedItems(children[i], result);\n        }\n\n        return result;\n    }\n",
    "3018": "    public int getCheckedElementCount() {\n        return checkedStateStore.size();\n    }\n",
    "3022": "    protected void createDirectoryStructureOptions(Composite optionsGroup, Font font) {\n        // create directory structure radios\n        createDirectoryStructureButton = new Button(optionsGroup, SWT.RADIO\n                | SWT.LEFT);\n        createDirectoryStructureButton.setText(DataTransferMessages.FileExport_createDirectoryStructure);\n        createDirectoryStructureButton.setSelection(false);\n        createDirectoryStructureButton.setFont(font);\n\n        // create directory structure radios\n        createSelectionOnlyButton = new Button(optionsGroup, SWT.RADIO\n                | SWT.LEFT);\n        createSelectionOnlyButton.setText(DataTransferMessages.FileExport_createSelectedDirectories);\n        createSelectionOnlyButton.setSelection(true);\n        createSelectionOnlyButton.setFont(font);\n    }\n",
    "3024": "\t\tfinal public int getPlayerPositionTopLeft() {\n\n\t\t\t// Calculate squares reachable by the player.\n\t\t\tupdate();\n\n\t\t\t// This is just the square with the smallest index.\n\t\t\tfor (int position = firstRelevantSquare; position < lastRelevantSquare; position++) {\n\t\t\t\tif (isSquareReachable(position)) {\n\t\t\t\t\treturn position;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// The player can't reach any square.\n\t\t\treturn -1;\n\t\t}\n",
    "3028": "    private void grayUpdateHierarchy(Object treeElement) {\n\n        boolean shouldBeAtLeastGray = determineShouldBeAtLeastGrayChecked(treeElement);\n\n        treeViewer.setGrayChecked(treeElement, shouldBeAtLeastGray);\n\n        if (whiteCheckedTreeItems.contains(treeElement)) {\n\t\t\twhiteCheckedTreeItems.remove(treeElement);\n\t\t}\n\n        // proceed up the tree element hierarchy\n        Object parent = treeContentProvider.getParent(treeElement);\n        if (parent != null) {\n            grayUpdateHierarchy(parent);\n        }\n    }\n",
    "3029": "    public void initialCheckTreeItem(Object element) {\n        treeItemChecked(element, true);\n        selectAndReveal(element);\n    }\n",
    "3030": "    protected boolean ensureDirectoryExists(File directory) {\n        if (!directory.exists()) {\n            if (!queryYesNoQuestion(DataTransferMessages.DataTransfer_createTargetDirectory)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n            if (!directory.mkdirs()) {\n                displayErrorDialog(DataTransferMessages.DataTransfer_directoryCreationError);\n                giveFocusToDestination();\n                return false;\n            }\n        }\n\n        return true;\n    }\n",
    "3032": "    protected boolean ensureTargetIsValid(File targetDirectory) {\n        if (targetDirectory.exists() && !targetDirectory.isDirectory()) {\n            displayErrorDialog(DataTransferMessages.FileExport_directoryExists);\n            giveFocusToDestination();\n            return false;\n        }\n\n        return ensureDirectoryExists(targetDirectory);\n    }\n",
    "3035": "    protected boolean executeExportOperation(FileSystemExportOperation op) {\n        op.setCreateLeadupStructure(createDirectoryStructureButton\n                .getSelection());\n        op.setOverwriteFiles(overwriteExistingFilesCheckbox.getSelection());\n\n        try {\n            getContainer().run(true, true, op);\n        } catch (InterruptedException e) {\n            return false;\n        } catch (InvocationTargetException e) {\n            displayErrorDialog(e.getTargetException());\n            return false;\n        }\n\n        IStatus status = op.getStatus();\n        if (!status.isOK()) {\n            ErrorDialog.openError(getContainer().getShell(),\n                    DataTransferMessages.DataTransfer_exportProblems,\n                    null, // no special message\n                    status);\n            return false;\n        }\n\n        return true;\n    }\n",
    "3038": "\t\tfinal public PlayersReachableSquaresOnlyWalls getClone() {\n\t\t\treturn new PlayersReachableSquaresOnlyWalls(playersReachableSquaresOnlyWallsArray, reachableSquareIndicatorOnlyWalls);\n\t\t}\n",
    "3043": "    protected String getDestinationLabel() {\n        return DataTransferMessages.FileExport_toDirectory;\n    }\n",
    "3044": "    public void removeCheckStateListener(ICheckStateListener listener) {\n        removeListenerObject(listener);\n    }\n",
    "3046": "    protected String getDestinationValue() {\n        return destinationNameField.getText().trim();\n    }\n",
    "3050": "    protected void giveFocusToDestination() {\n        destinationNameField.setFocus();\n    }\n",
    "3053": "\t\tfinal public boolean isSquareReachable(int position) {\n\t\t\treturn playersReachableSquaresOnlyWallsArray[position] == reachableSquareIndicatorOnlyWalls;\n\t\t}\n",
    "3054": "    protected void handleDestinationBrowseButtonPressed() {\n        DirectoryDialog dialog = new DirectoryDialog(getContainer().getShell(),\n                SWT.SAVE);\n        dialog.setMessage(SELECT_DESTINATION_MESSAGE);\n        dialog.setText(SELECT_DESTINATION_TITLE);\n        dialog.setFilterPath(getDestinationValue());\n        String selectedDirectoryName = dialog.open();\n\n        if (selectedDirectoryName != null) {\n            setErrorMessage(null);\n            setDestinationValue(selectedDirectoryName);\n        }\n    }\n",
    "3055": "    public void setRoot(Object newRoot) {\n        this.root = newRoot;\n        initialize();\n    }\n",
    "3056": "    public void handleEvent(Event e) {\n        Widget source = e.widget;\n\n        if (source == destinationBrowseButton) {\n\t\t\thandleDestinationBrowseButtonPressed();\n\t\t}\n\n        updatePageCompletion();\n    }\n",
    "3057": "    protected void setTreeChecked(Object treeElement, boolean state) {\n\n        if (!state) {\n\t\t\tcheckedStateStore.remove(treeElement);\n\t\t}\n\n        setWhiteChecked(treeElement, state);\n        treeViewer.setChecked(treeElement, state);\n        treeViewer.setGrayed(treeElement, false);\n\n        // now logically check/uncheck all children as well if it has been expanded\n        if (expandedTreeNodes.contains(treeElement)) {\n            Object[] children = treeContentProvider.getChildren(treeElement);\n            for (int i = 0; i < children.length; ++i) {\n                setTreeChecked(children[i], state);\n            }\n        }\n    }\n",
    "3060": "    private void internalSaveWidgetValues() {\n        // update directory names history\n        IDialogSettings settings = getDialogSettings();\n        if (settings != null) {\n            String[] directoryNames = settings\n                    .getArray(STORE_DESTINATION_NAMES_ID);\n            if (directoryNames == null) {\n\t\t\t\tdirectoryNames = new String[0];\n\t\t\t}\n\n            directoryNames = addToHistory(directoryNames, getDestinationValue());\n            settings.put(STORE_DESTINATION_NAMES_ID, directoryNames);\n\n            // options\n            settings.put(STORE_OVERWRITE_EXISTING_FILES_ID,\n                    overwriteExistingFilesCheckbox.getSelection());\n\n            settings.put(STORE_CREATE_STRUCTURE_ID,\n                    createDirectoryStructureButton.getSelection());\n\n        }\n    }\n",
    "3061": "    public Object narrowProxy(Object proxy, ClassPersister persister, Key key, Object object) throws HibernateException {\n\n        if ( !persister.getConcreteProxyClass().isAssignableFrom( proxy.getClass() ) ) {\n\n            if ( log.isWarnEnabled() ) log.warn(\n                \"Narrowing proxy to \" + persister.getConcreteProxyClass() + \" - this operation breaks ==\"\n            );\n\n            if (object!=null) {\n                proxiesByKey.remove(key);\n                return object; //return the proxied object\n            }\n            else {\n                proxy = persister.createProxy( key.getIdentifier(), this );\n                proxiesByKey.put(key, proxy); //overwrite old proxy\n                return proxy;\n            }\n\n        }\n        else {\n            return proxy;\n        }\n    }\n",
    "3062": "    public void setTreeSorter(ViewerSorter sorter) {\n        treeViewer.setSorter(sorter);\n    }\n",
    "3063": "    protected void restoreWidgetValues() {\n        IDialogSettings settings = getDialogSettings();\n        if (settings != null) {\n            String[] directoryNames = settings\n                    .getArray(STORE_DESTINATION_NAMES_ID);\n            if (directoryNames == null) {\n\t\t\t\treturn; // ie.- no settings stored\n\t\t\t}\n\n            // destination\n            setDestinationValue(directoryNames[0]);\n            for (int i = 0; i < directoryNames.length; i++) {\n\t\t\t\taddDestinationItem(directoryNames[i]);\n\t\t\t}\n\n            // options\n            overwriteExistingFilesCheckbox.setSelection(settings\n                    .getBoolean(STORE_OVERWRITE_EXISTING_FILES_ID));\n\n            boolean createDirectories = settings\n                    .getBoolean(STORE_CREATE_STRUCTURE_ID);\n            createDirectoryStructureButton.setSelection(createDirectories);\n            createSelectionOnlyButton.setSelection(!createDirectories);\n        }\n    }\n",
    "3066": "\t\tfinal public boolean isSquareReachable(int x, int y) {\n\t\t\treturn playersReachableSquaresOnlyWallsArray[x + width * y] == reachableSquareIndicatorOnlyWalls;\n\t\t}\n",
    "3067": "    public void treeCollapsed(TreeExpansionEvent event) {\n        // We don't need to do anything with this\n    }\n",
    "3068": "    protected void setDestinationValue(String value) {\n        destinationNameField.setText(value);\n    }\n",
    "3069": "    public void treeExpanded(TreeExpansionEvent event) {\n        expandTreeElement(event.getElement());\n    }\n",
    "3070": "    protected boolean validateDestinationGroup() {\n        String destinationValue = getDestinationValue();\n        if (destinationValue.length() == 0) {\n            setMessage(destinationEmptyMessage());\n            return false;\n        }\n\n        String conflictingContainer = getConflictingContainerNameFor(destinationValue);\n        if (conflictingContainer == null) {\n\t\t\tsetErrorMessage(null);\n\t\t} else {\n            setErrorMessage(NLS.bind(DataTransferMessages.FileExport_conflictingContainer, conflictingContainer));\n            giveFocusToDestination();\n            return false;\n        }\n\n        return true;\n    }\n",
    "3072": "    public Object proxyFor(ClassPersister persister, Key key, Object impl) throws HibernateException {\n        if ( !persister.hasProxy() ) return impl;\n        Object proxy = proxiesByKey.get(key);\n        if (proxy!=null) {\n            return narrowProxy(proxy, persister, key, impl);\n        }\n        else {\n            return impl;\n        }\n    }\n",
    "3073": "    protected void treeItemChecked(Object treeElement, boolean state) {\n\n        // recursively adjust all child tree elements appropriately\n        setTreeChecked(treeElement, state);\n\n        Object parent = treeContentProvider.getParent(treeElement);\n        if (parent == null) {\n\t\t\treturn;\n\t\t}\n\n        // now update upwards in the tree hierarchy \n        if (state) {\n\t\t\tgrayCheckHierarchy(parent);\n\t\t} else {\n\t\t\tungrayCheckHierarchy(parent);\n\t\t}\n\n        //Update the hierarchy but do not white select the parent\n        grayUpdateHierarchy(parent);\n    }\n",
    "3075": "    protected void ungrayCheckHierarchy(Object treeElement) {\n        if (!determineShouldBeAtLeastGrayChecked(treeElement)) {\n\t\t\tcheckedStateStore.remove(treeElement);\n\t\t}\n\n        Object parent = treeContentProvider.getParent(treeElement);\n        if (parent != null) {\n\t\t\tungrayCheckHierarchy(parent);\n\t\t}\n    }\n",
    "3077": "    protected void updateHierarchy(Object treeElement) {\n\n        boolean whiteChecked = determineShouldBeWhiteChecked(treeElement);\n        boolean shouldBeAtLeastGray = determineShouldBeAtLeastGrayChecked(treeElement);\n\n        treeViewer.setChecked(treeElement, shouldBeAtLeastGray);\n        setWhiteChecked(treeElement, whiteChecked);\n        if (whiteChecked) {\n\t\t\ttreeViewer.setGrayed(treeElement, false);\n\t\t} else {\n\t\t\ttreeViewer.setGrayed(treeElement, shouldBeAtLeastGray);\n\t\t}\n\n        // proceed up the tree element hierarchy but gray select all of them\n        Object parent = treeContentProvider.getParent(treeElement);\n        if (parent != null) {\n            grayUpdateHierarchy(parent);\n        }\n    }\n",
    "3078": "    protected String destinationEmptyMessage() {\n        return DataTransferMessages.FileExport_destinationEmpty;\n    }\n",
    "3081": "    protected String getConflictingContainerNameFor(String targetDirectory) {\n\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IPath testPath = new Path(targetDirectory);\n\n        if (root.getLocation().isPrefixOf(testPath)) {\n\t\t\treturn DataTransferMessages.FileExport_rootName;\n\t\t}\n\n\t    IContainer[] containers = root.findContainersForLocation(testPath);\n\t    if (containers.length > 0){\n    \t\treturn containers[0].getName();\n\t    }\n\n        return null;\n\n    }\n",
    "3082": "    public void setFocus() {\n        this.treeViewer.getTree().setFocus();\n    }\n",
    "3095": "    protected int countSelectedResources() throws CoreException {\n        int result = 0;\n        Iterator resources = resourcesToExport.iterator();\n\n        while (resources.hasNext()) {\n\t\t\tresult += countChildrenOf((IResource) resources.next());\n\t\t}\n\n        return result;\n    }\n",
    "3096": "    protected void createLeadupDirectoriesFor(IResource childResource) {\n        IPath resourcePath = childResource.getFullPath().removeLastSegments(1);\n        makePathTree(resourcePath);\n    }\n",
    "3098": "    protected void createLeadupDirectoriesFor(IPath childPath) {\n        IPath resourcePath = childPath.removeLastSegments(1);\n        makePathTree(resourcePath);\n    }\n",
    "3100": "    private void makePathTree(IPath tree) {\n        IPath targetPath = tree.removeLastSegments(tree.segmentCount() - 1);\n        for (int i = 1; i < tree.segmentCount(); i++) {\n        \ttargetPath = targetPath.append(tree.segment(i));\n            if (!targetPath.toFile().exists())\n            \ttargetPath.toFile().mkdir();\n        }    \t\n    }\n",
    "3107": "    public void addUninitializedEntity(Key key, Object object, LockMode lockMode) {\n        addEntity(key, object);\n        addEntry( object, LOADING, null, key.getIdentifier(), null, lockMode, true, null /*getPersister(object)*/, false ); //temporary\n    }\n",
    "3116": "    protected boolean isDescendent(List resources, IResource child) {\n        if (child.getType() == IResource.PROJECT) {\n\t\t\treturn false;\n\t\t}\n\n        IResource parent = child.getParent();\n        if (resources.contains(parent)) {\n\t\t\treturn true;\n\t\t}\n\n        return isDescendent(resources, parent);\n    }\n",
    "3122": "    public void setCreateContainerDirectories(boolean value) {\n        createContainerDirectories = value;\n    }\n",
    "3124": "    public void setCreateLeadupStructure(boolean value) {\n        createLeadupStructure = value;\n    }\n",
    "3126": "    public void setOverwriteFiles(boolean value) {\n        if (value) {\n\t\t\toverwriteState = OVERWRITE_ALL;\n\t\t}\n    }\n",
    "3127": "    public void postHydrate(ClassPersister persister, Serializable id, Object[] values, Object object, LockMode lockMode) throws HibernateException {\n        //persister.setIdentifier(object, id);\n        Object version = Versioning.getVersion(values, persister);\n        addEntry(object, LOADING, values, id, version, lockMode, true, persister, false);\n\n        if ( log.isTraceEnabled() && version!=null ) log.trace(\"Version: \" + version);\n    }\n",
    "3129": "\t\tfinal public boolean isSquareReachable(int position) {\n\t\t\treturn boxReachableSquaresArray[position] == indicatorReachableSquare;\n\t\t}\n",
    "3135": "    private ZipFile getSpecifiedSourceFile(String fileName) {\n        if (fileName.length() == 0)\n            return null;\n\n        try {\n            return new ZipFile(fileName);\n        } catch (ZipException e) {\n           addError(DataTransferMessages.ZipImport_badFormat, e);\n        } catch (IOException e) {\n           addError(DataTransferMessages.ZipImport_couldNotRead, e);\n        }\n\n        return null;\n    }\n",
    "3137": "    protected boolean closeZipFile(ZipFile file) {\n        try {\n            file.close();\n        } catch (IOException e) {\n            addError(NLS.bind(DataTransferMessages.ZipImport_couldNotClose, file.getName()), e);\n            return false;\n        }\n\n        return true;\n    }\n",
    "3189": "\tprivate void initializeValues() {\n\t\tfinal IPreferenceStore store = getPreferenceStore();\n\t\tfor (Iterator iter = fFields.iterator(); iter.hasNext();) {\n\t\t\t((Field)iter.next()).initializeValue(store);\n\t\t}\n\t}\n",
    "3200": "\tprotected IPreferenceStore doGetPreferenceStore() {\n\t\treturn CVSUIPlugin.getPlugin().getPreferenceStore();\n\t}\n",
    "3201": "\tprotected void createImageDescriptor(String id) {\n\t\tURL url = FileLocator.find(CVSUIPlugin.getPlugin().getBundle(), new Path(ICVSUIConstants.ICON_PATH + id), null);\n\t\tImageDescriptor desc = ImageDescriptor.createFromURL(url);\n\t\timageDescriptors.put(id, desc);\n\t}\n",
    "3205": "\tpublic void setCompressionLevel(int level) {\n\t\tcompressionLevel = level;\n\t}\n",
    "3207": "\tpublic int getCompressionLevel() {\n\t\treturn compressionLevel;\n\t}\n",
    "3209": "\tpublic ImageDescriptor getImageDescriptor(String id) {\n\t\treturn (ImageDescriptor)imageDescriptors.get(id);\n\t}\n",
    "3211": "\tpublic void setDefaultTextKSubstOption(KSubstOption ksubst) {\n\t\tdefaultTextKSubstOption = ksubst;\n\t}\n",
    "3214": "\tpublic KSubstOption getDefaultTextKSubstOption() {\n\t\treturn defaultTextKSubstOption;\n\t}\n",
    "3215": "\tprivate String getPreviousBugId(String string){\n\t\tif(string.startsWith(BUG_ID_INITIAL)){\n\t\t\tint newLineIndex = string.indexOf(LINE_SEPARATOR);\n\t\t\treturn string.substring(BUG_ID_INITIAL.length(), newLineIndex);\n\t\t}\n\t\treturn \"\";\t\n\t}\n",
    "3217": "\tpublic boolean getPruneEmptyDirectories() {\n\t\treturn pruneEmptyDirectories;\n\t}\n",
    "3218": "\tprivate String getPreviousComment(String string){\n\t\tif(string.startsWith(BUG_ID_INITIAL)){\n\t\t\tint newLineIndex = string.indexOf(LINE_SEPARATOR);\n\t\t\treturn string.substring(newLineIndex+LINE_SEPARATOR.length(), string.length());\n\t\t}\n\t\treturn string;\t\t\n\t}\n",
    "3221": "\tpublic void setPruneEmptyDirectories(boolean prune) {\n\t\tpruneEmptyDirectories = prune;\n\t}\n",
    "3226": "\tpublic int getTimeout() {\n\t\treturn communicationsTimeout;\n\t}\n",
    "3230": "\tpublic void setTimeout(int timeout) {\n\t\tthis.communicationsTimeout = Math.max(0, timeout);\n\t}\n",
    "3231": "\tprivate Label createLabel(Composite parent, String text, int horizontalSpan) {\n\t\tLabel label = new Label(parent, SWT.LEFT);\n\t\tlabel.setText(text);\n\t\tGridData data = new GridData();\n\t\tdata.horizontalSpan = horizontalSpan;\n\t\tdata.horizontalAlignment = GridData.FILL;\n\t\tlabel.setLayoutData(data);\n\t\treturn label;\n\t}\n",
    "3232": "\tprivate Button createCheckBox(Composite group, String label) {\n\t\tButton button = new Button(group, SWT.CHECK | SWT.LEFT);\n\t\tbutton.setText(label);\n\t\tGridData data = new GridData();\n\t\tdata.horizontalSpan = 2;\n\t\tbutton.setLayoutData(data);\n\t\treturn button;\n\t}\t\n",
    "3233": "\tpublic void setQuietness(QuietOption option) {\n\t\t\tthis.quietness = option;\n\t}\n",
    "3237": "\tpublic QuietOption getQuietness() {\n\t\treturn quietness;\n\t}\n",
    "3243": "\tpublic void setConsoleListener(IConsoleListener consoleListener) {\n\t    ConsoleListeners.getInstance().addListener(consoleListener);\n\t}\n",
    "3253": "\tprotected void performDefaults() {\n\t\tsuper.performDefaults();\n        initializeValues();\n\t\t\n        verifyValidation();\n\t}\n",
    "3254": "\tpublic String getCvsRshCommand() {\n\t\treturn cvsRshCommand;\n\t}\n",
    "3258": "\tpublic void setCvsRshCommand(String cvsRshCommand) {\n\t\tthis.cvsRshCommand = cvsRshCommand;\n\t}\n",
    "3260": "\tpublic boolean isUseProjectNameOnCheckout() {\n\t\treturn getPreferenceStore().getBoolean(ICVSUIConstants.PREF_USE_PROJECT_NAME_ON_CHECKOUT);\n\t}\n",
    "3262": "\tpublic String getCvsRshParameters() {\n\t\treturn cvsRshParameters;\n\t}\n",
    "3265": "\tpublic void setCvsRshParameters(String cvsRshParameters) {\n\t\tthis.cvsRshParameters = cvsRshParameters;\n\t}\n",
    "3270": "\tpublic String getCvsServer() {\n\t\treturn cvsServer;\n\t}\n",
    "3271": "\tprivate void initializeValues() {\n\t\t\n\t\t// populate the previous comment list\n\t\tfor (int i = 0; i < comments.length; i++) {\n\t\t\tpreviousCommentsCombo.add(flattenText(comments[i]));\n\t\t}\n\t\t\n\t\t// We don't want to have an initial selection\n\t\t// (see bug 32078: http://bugs.eclipse.org/bugs/show_bug.cgi?id=32078)\n\t\tpreviousCommentsCombo.setText(\"\"); //$NON-NLS-1$\n\t\t\n\t\tif (commentProperties == null && oldComment == null) text.setText(\"\"); //$NON-NLS-1$\n\t\tcomment = text.getText();\n\t}\n",
    "3275": "\tpublic void setCvsServer(String cvsServer) {\n\t\tthis.cvsServer = cvsServer;\n\t}\n",
    "3277": "\tprivate void signalCtrlEnter() {\n\t\tfirePropertyChangeChange(OK_REQUESTED, null, null);\n\t}\n",
    "3278": "\tpublic String getComment() {\n\t\tIPreferenceStore store = SVNUIPlugin.getPlugin().getPreferenceStore();\n\t\tif(store.getBoolean(ISVNUIConstants.PREF_BUG_ID_FIELD)){\n\t\t\tif(comment.length() > 0 && bugId.length() > 0)\n\t\t\tcomment = bugId + comment;\n\t\t}\n\t\tif (comment != null && comment.length() > 0) finished();\n\t\tif(store.getBoolean(ISVNUIConstants.PREF_BUG_ID_FIELD)){\n\t\t\tif(comment.length() > 0 && bugId.length() == 0)\n\t\treturn comment;\n\t}\n\t\treturn comment;\t\n\t}\n",
    "3280": "\tpublic boolean getFetchAbsentDirectories() {\n\t\treturn fetchAbsentDirectories;\n\t}\n",
    "3288": "\tpublic void setFetchAbsentDirectories(boolean fetchAbsentDirectories) {\n\t\tthis.fetchAbsentDirectories = fetchAbsentDirectories;\n\t}\n",
    "3296": "    private void setSvnClientInterface(String clientInterface) {\n        if (CmdLineClientAdapterFactory.COMMANDLINE_CLIENT.equals(clientInterface))\n            clientInterface = JavaSvnClientAdapterFactory.JAVASVN_CLIENT;\n        SVNProviderPlugin.getPlugin().getSVNClientManager().setSvnClientInterface(clientInterface);\n    }\n",
    "3297": "    private void setSvnClientConfigDir(String configDir) {\n        SVNProviderPlugin plugin = SVNProviderPlugin.getPlugin();\n        SVNClientManager svnClientManager = plugin.getSVNClientManager();\n        if (\"\".equals(configDir)) { //$NON-NLS-1$\n        \tsvnClientManager.setConfigDir(null);\n        } else {\n        \tFile configDirFile = new File(configDir);\n            svnClientManager.setConfigDir(configDirFile);\n        }\n    }\n",
    "3305": "\t\tpublic IProject getProject() {\n\t\t\treturn project;\n\t\t}\n",
    "3306": "\t\tpublic void setProject(IProject project) {\n\t\t\tthis.project = project;\n\t\t}\n",
    "3308": "\tpublic boolean isReplaceUnmanaged() {\n\t\treturn replaceUnmanaged;\n\t}\n",
    "3313": "\tpublic void setReplaceUnmanaged(boolean replaceUnmanaged) {\n\t\tthis.replaceUnmanaged = replaceUnmanaged;\n\t}\n",
    "3321": "\tpublic void addRepositoryListener(ICVSListener listener) {\n\t\tKnownRepositories.getInstance().addRepositoryListener(listener);\n\t}\n",
    "3327": "\t\tstatic public InstallerProject create(IJavaProject javaProject) {\n\t\t\tInstallerProject result = null;\n\t\t\ttry {\n\t\t\t\tInstallerProject.addTikalInstallerNature(javaProject);\n\t\t\t\tresult = (InstallerProject)javaProject.getProject().getNature(InstallerPlugin.NATURE_ID);\n\t\t\t\tif(result != null)\n\t\t\t\t\tresult.setJavaProject(javaProject);\n\t\t\t} catch(CoreException ex) {\n\t\t\t\tex.printStackTrace();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n",
    "3329": "\tpublic void addDecoratorEnablementListener(ICVSDecoratorEnablementListener listener) {\n\t\tsynchronized(decoratorEnablementListeners) {\n\t\t\tdecoratorEnablementListeners.add(listener);\n\t\t}\n\t}\n",
    "3332": "\t\tstatic public InstallerProject create(IProject project) {\n\n\t\t\tIJavaProject javaProject = JavaCore.create(project);\n\t\t\tif(javaProject != null) {\n\t\t\t\treturn InstallerProject.create(javaProject);\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\t\n",
    "3350": "    private void doLoadByObject(Object object, Serializable id, LockMode lockMode) throws HibernateException {\n\n        Class clazz = object.getClass();\n        if ( getEntry(object)!=null ) throw new PersistentObjectException(\n            \"attempted to load into an instance that was already associated with the Session: \" +\n            MessageHelper.infoString(clazz, id)\n        );\n        Object result = doLoad(clazz, id, object, lockMode, true);\n        ObjectNotFoundException.throwIfNull(result, id, clazz);\n        if (result!=object) throw new NonUniqueObjectException(id, clazz);\n\n    }\n",
    "3370": "\tpublic boolean isDetermineVersionEnabled() {\n\t\treturn determineVersionEnabled;\n\t}\n",
    "3377": "\tpublic void setDetermineVersionEnabled(boolean determineVersionEnabled) {\n\t\tthis.determineVersionEnabled = determineVersionEnabled;\n\t}\n",
    "3379": "\tpublic String getComment() {\n\t    if ((projectProperties != null) && (issue != null) && (issue.length() > 0)) {\n\t        if (projectProperties.isAppend()) \n\t            return commitCommentArea.getComment() + \"\\n\" + projectProperties.getResolvedMessage(issue) + \"\\n\"; //$NON-NLS-1$ //$NON-NLS-2$\n\t        else\n\t            return projectProperties.getResolvedMessage(issue) + \"\\n\" + commitCommentArea.getComment(); //$NON-NLS-1$\n\t    }\n\t\treturn commitCommentArea.getComment();\n\t}\n",
    "3383": "\tpublic FileModificationManager getFileModificationManager() {\n\t\treturn fileModificationManager;\n\t}\n",
    "3475": "\tpublic void setExcludesDirs(String[] excludesDirs) {\n\t\tthis.excludesDirs = excludesDirs;\n\t}\n",
    "3478": "\tpublic void setIncludesDirs(String[] includesDirs) {\n\t\tthis.includesDirs = includesDirs;\n\t}\n",
    "3498": "\tprivate void scan(File fromDir, File toDir, String[] files, String[] toFiles) {\n\t\tFileNameMapper mapper = null;\n\t\tmapper = new IdentityMapper();\n\t\tbuildMap(fromDir, toDir, files, mapper, toFiles);\n\n\t}\n",
    "3520": "\tprivate void scan(File fromDir, File toDir, String[] files, String[] dirs) {\n\t\tboolean flatten = false;\n\t\tFileNameMapper mapper = null;\n\t\tif (mapperElement != null) {\n\t\t\tmapper = mapperElement.getImplementation();\n\t\t} else if (flatten) {\n\t\t\tmapper = new FlatFileNameMapper();\n\t\t} else {\n\t\t\tmapper = new IdentityMapper();\n\t\t}\n\t\tbuildMap(fromDir, toDir, files, mapper);\n\n\t}\n",
    "3543": "\tprivate void scan(File fromDir, File toDir, String[] files, String[] dirs) {\n\t\tFileNameMapper mapper = null;\n\t\tmapper = new IdentityMapper();\n\t\tbuildMap(fromDir, toDir, files, mapper);\n\n\t}\n",
    "3589": "    public void setOptional(boolean optional) {\n        this.optional = optional;\n    }\n",
    "3590": "    public void setFile(String file) {\n        // I don't think we can use File - different rules\n        // for relative paths.\n        this.file = file;\n    }\n",
    "3597": "    public void setClasspath(Path classpath) {\n        if (this.classpath == null) {\n            this.classpath = classpath;\n        } else {\n            this.classpath.append(classpath);\n        }\n    }\n",
    "3599": "    public Path createClasspath() {\n        if (this.classpath == null) {\n            this.classpath = new Path(getProject());\n        }\n        return this.classpath.createPath();\n    }\n",
    "3600": "    public void setClasspathRef(Reference r) {\n        createClasspath().setRefid(r);\n    }\n",
    "3611": "\tpublic URL getResource(String resourceName) {\n\t\tURL result = null;\n\n\t\twhile (_policy .hasNext() && result == null) {\n\t\t\tresult = _policy.next().getResource(resourceName);\n\t\t}\n\n\t\treturn result;\n\t}\n",
    "3612": "\tpublic Class loadClass(String className) throws ClassNotFoundException {\n\t\tClass result = null;\n\n\t\twhile (_policy .hasNext() && result == null) {\n\t\t\ttry {\n\t\t\t\tresult = _policy.next().loadClass(className);\n\t\t\t} catch (ClassNotFoundException ignore) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\n\t\tif (result == null) {\n\t\t\tthrow new ClassNotFoundException(className);\n\t\t}\n\n\t\treturn result;\n\t}\n",
    "3613": "\tpublic boolean hasNext() {\n\t\treturn _iterator.hasNext();\n\t}\n",
    "3614": "\tpublic ClassLoader next() {\n\t\treturn (ClassLoader) _iterator.next();\n\t}\n",
    "3615": "\tpublic void reset() {\n\t\tinit();\n\t}\n",
    "3648": "\tpublic boolean isDebugEnabled() {\n\t\tLevel l = Level.DEBUG;\n\t\tif (!_log.isEnabledFor(l)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn l.isGreaterOrEqual(_log.getEffectiveLevel());\n\t}\n",
    "3651": "\tpublic void debug(Object message) {\n\t\t_log.log(Level.DEBUG, message, null);\n\t}\n",
    "3653": "\tpublic void debug(Object message, Throwable t) {\n\t\t_log.log(Level.DEBUG, message, t);\n\t}\n",
    "3655": "\tpublic boolean isInfoEnabled() {\n\t\tLevel l = Level.INFO;\n\t\tif (!_log.isEnabledFor(l)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn l.isGreaterOrEqual(_log.getEffectiveLevel());\n\t}\n",
    "3659": "\tpublic void info(Object message) {\n\t\t_log.log(Level.INFO, message, null);\n\t}\n",
    "3665": "\tpublic void info(Object message, Throwable t) {\n\t\t_log.log(Level.INFO, message, t);\n\t}\n",
    "3670": "\tpublic void warn(Object message) {\n\t\t_log.log(Level.WARN, message, null);\n\t}\n",
    "3674": "\tpublic void warn(Object message, Throwable t) {\n\t\t_log.log(Level.WARN, message, t);\n\t}\n",
    "3679": "\tpublic void error(Object message) {\n\t\t_log.log(Level.ERROR, message, null);\n\t}\n",
    "3685": "\tpublic void error(Object message, Throwable t) {\n\t\t_log.log(Level.ERROR, message, t);\n\t}\n",
    "3689": "\tpublic void fatal(Object message) {\n\t\t_log.log(Level.FATAL, message, null);\n\t}\n",
    "3695": "\tpublic void fatal(Object message, Throwable t) {\n\t\t_log.log(Level.FATAL, message, t);\n\t}\n",
    "3701": "\tpublic void log(Level l, Object message) {\n\t\t_log.log(l, message, null);\n\t}\n",
    "3704": "    public String getJHObject(String target) {\n        // crack the definition string.\n        if (!definition.startsWith(VIEWER_TAG)) {\n            logger.warn(\"Called with a incorrect definition: \" + definition);\n            return definition; // do nothing\n        }\n        String text = null;\n        try {\n            text = definition.substring(VIEWER_TAG.length());\n            PopupObject popup = new PopupObject(props);\n            text = popup.getJHObject(target, text);\n        }\n        catch (IndexOutOfBoundsException e) {\n            logger.warn(\"Error handling definition. \" + definition + \" : \" + e.getMessage());\n            text = definition;\n        }\n        return text;\n    }\n",
    "3705": "\tpublic void log(Level l, Object message, Throwable t) {\n\t\t_log.log(l, message, t);\n\t}\n",
    "3708": "    public String getProjectName() {\n        return projectName;\n    }\n",
    "3709": "    private String paramStr(String name, String value) {\n        return \"<param name=\\\"\" + name +\"\\\" value=\\\"\" + value + \"\\\">\\n\"; \n    }\n",
    "3711": "    private boolean setPlayerMediaLocation() { \n        \n        String location = null;\n        if (baseDoc.getBase().getProtocol() != \"file\")\n            messages.append(\"Unable to handle the \" + baseDoc.getBase().getProtocol() + \" protocol.\\r\\n\");\n        else {\n            try {\n                URL linkUrl = new URL(baseDoc.getBase(), strUrl);\n                location = linkUrl.toString().replaceFirst(\"file:/\", \"file://\");\n            }\n            catch (MalformedURLException e) {\n                messages.append(\"Couldn't form URL \" + e.getMessage() + \"\\r\\n\");\n            }\n        }\n        \n        if (location != null) {\n            messages.append(\"Media file: \" + location + \"\\r\\n\");\n            player.setMediaLocation(location);\n            return true;\n        }\n        return false; // can' handle this yet\n    }\n",
    "3712": "    public String getSourceFolder() {\n        return sourceFolder;\n    }\n",
    "3715": "    public void setSourceFolder(String sourceFolder) {\n        this.sourceFolder = sourceFolder;\n    }\n",
    "3716": "    private String getParent(URL url) {\n        int end = url.getPath().lastIndexOf(\"/\");\n        if (end >= 0)\n            return url.getPath().substring(0, end + 1);\n        else\n            return url.getPath();  \n    }\n",
    "3717": "    public String getTargetFolder() {\n        return targetFolder;\n    }\n",
    "3720": "    public void setViewData(View view) {\n        baseDoc = (HTMLDocument)view.getDocument();\n        super.setViewData(view);\n    }\n",
    "3721": "    public String getSourceName() {\n        return sourceName;\n    }\n",
    "3722": "    private void createTempObject(String url) {\n        // File fin = new File();\n    }\n",
    "3723": "    public void setSourceName(String sourceName) {\n        this.sourceName = sourceName;\n    }\n",
    "3724": "    public void actionPerformed(ActionEvent event) {\n        strUrl = this.getContent();\n        if (jd == null)\n            createDialog();\n        showVideo();\n    }\n",
    "3726": "    public boolean accept(File f) { \n        if (f.isDirectory())\n            return true;\n        String ext = FileManager.getExtension(f);\n        return (ext.equals(\".hhp\"));\n    }\n",
    "3727": "    public String getDescription() {\n        return (\"hhp - HTML Help project files\");\n    }\n",
    "3729": "    private void createDialog() {\n        // set up the messages area\n        jd = new JDialog();\n        contentPane = jd.getContentPane();\n\n        messages = new JTextArea();\n        messages.setLineWrap(true);\n        messages.setWrapStyleWord(true);\n        messages.setEditable(false);\n        messagePanel = new JScrollPane();\n        \n        messagePanel.setOpaque(false);\n        messagePanel.setRequestFocusEnabled(false);\n        messagePanel.setPreferredSize(new java.awt.Dimension(400, 200));\n        messagePanel.setViewportView(messages);\n        contentPane.add(messagePanel, BorderLayout.NORTH);\n        northComponent = messagePanel;\n        \n        jd.pack();\n        jd.show();\n        jd.requestFocusInWindow();        \n    }\n",
    "3736": "    private void centre() {\n        Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();\n        Dimension winSize = getSize();\n        setLocation((screen.width - winSize.width)/2, (screen.height - winSize.height)/2);\n    }\n",
    "3737": "        public void realizeComplete(RealizeCompleteEvent event) {\n            Component vc = player.getVisualComponent();\n            messagePanel.setVisible(false);\n           \n            if (vc != null) {\n                contentPane.add(vc,BorderLayout.CENTER);\n                centerComponent = vc;\n            } else {\n                if (centerComponent != null) {\n                    contentPane.remove(centerComponent);\n                    contentPane.validate();\n                }\n            }\n            Component cpc = player.getControlPanelComponent();\n            if (cpc != null) {\n                contentPane.add(cpc, BorderLayout.SOUTH);\n                southComponent = cpc;\n            } else {\n                if (southComponent != null) {\n                    contentPane.remove(southComponent);\n                    contentPane.validate();\n                }\n            }\n            jd.addWindowListener(new WindowHandler());\n            jd.pack();\n            jd.setTitle(strUrl);\n            jd.show();           \n        }\n",
    "3738": "    private void setLicenceText() {\n        URL url = getClass().getResource(\"/resources/licence.html\");\n        try {\n            informationArea.setPage(url);\n        }\n        catch (IOException e) {\n            informationArea.setText(\"Unable to open licence page. This program is copyrighted.  Please do not use and re-install.\");\n        }\n    }\n",
    "3742": "    public void display() {\n        setLicenceText();\n        pack();\n        centre();\n        setVisible(true); \n        toFront();\n        \n    }\n",
    "3743": "        public void windowClosing(WindowEvent e) {\n            if (player != null) {\n                player.stopAndDeallocate();\n                player.close();\n            }\n            \n            jd.dispose();\n        }\n",
    "3745": "    public void init() {\n        logger.debug(\"Initialise the application.\");\n        configProps = new PropertyManager(\"configuration.properties\");\n        window = new MainFrame(this);\n        window.pack();\n        window.setVisible(true);   \n    }\n",
    "3746": "    public void close() {\n        // nothing to do\n    }\n",
    "3747": "    public String getDefaultSource() {\n        return configProps.getProperty(\"defaultSource\", \"\");\n    }\n",
    "3748": "        protected void checkNamespace(String uri) {\n\n        }\n",
    "3749": "    public boolean requiresLayout() {\n        return true;\n    }\n",
    "3750": "    public void setDefaultSource(String defaultSource) {\n        configProps.setProperty(\"defaultSource\", defaultSource);\n    }\n",
    "3751": "    public void append(LoggingEvent event) {\n        if (textArea != null) {\n            Level level = event.getLevel();\n            if (level == Level.FATAL)\n                textArea.append(\"[FATAL] \");\n            else if (level == Level.WARN)\n                textArea.append(\"[WARN] \");\n            else if (level == Level.INFO)\n                textArea.append(\"[INFO] \");\n            else if (level == Level.DEBUG)\n                textArea.append(\"[DEBUG] \");\n            else \n                textArea.append(\"[----] \");\n            \n            textArea.append(event.getRenderedMessage());\n            textArea.append(\"\\n\");\n            \n        }\n    }\n",
    "3753": "    public String getDefaultTarget() {\n        return configProps.getProperty(\"defaultTarget\", \"\");\n    }\n",
    "3754": "    public void setTextArea(JTextArea argTextArea) {\n        textArea = argTextArea;\n    }\n",
    "3756": "    public void saveConfig() {\n        logger.debug(\"Save the configuration properties.\");\n        configProps.store();\n    }\n",
    "3760": "     static public void copyFile(File in, File out) throws Exception {\n        FileInputStream fis  = new FileInputStream(in);\n        FileOutputStream fos = new FileOutputStream(out);\n        byte[] buf = new byte[1024];\n        int i = 0;\n        while((i=fis.read(buf))!=-1) {\n            fos.write(buf, 0, i);\n        }\n        fis.close();\n        fos.close();\n    }\n",
    "3764": "        public AntHandler getCurrentAntHandler() {\n            return currentHandler;\n        }\n",
    "3765": "     static public String makeAbsolute(String currentPath, String defaultDir) {\n         File file = new File(currentPath);\n         if (file.isAbsolute())\n             return currentPath;\n         else\n             return combine(defaultDir, file.getName());\n     }\n",
    "3768": "     static public String buildPath(String dir, String fileName, String ext) {\n         return combine(dir, fileName + ext);\n     }\n",
    "3769": "    public String getLanguage(int encType) {\n        if (encType == INDEX) {\n            return m_props.getProperty(\"index_lang\", \"en\");\n        }\n        else if (encType == MAP) {\n            return m_props.getProperty(\"map_lang\", \"en\");\n        }\n        else if (encType == TOC) {\n            return m_props.getProperty(\"toc_lang\", \"en\");\n        }\n        else if (encType == HS) {\n            return m_props.getProperty(\"hs_lang\", \"en\");\n        }        \n        return \"en\";\n    }\n",
    "3770": "    static public String changeDirectory(String path, String newDir) {\n        String fileName = \"\";\n        try {\n            File file = new File(path);\n            fileName = file.getName();\n        }\n        catch (NullPointerException e) {\n            // okay\n        }\n        \n        return combine(newDir, fileName);\n    }\n",
    "3772": "    static public String getDirectory(String path) {\n        String dir = path;\n        try {\n            File file = new File(path);\n            dir = file.getParent();\n        }\n        catch (NullPointerException e) {\n            // okay\n        }\n        return dir;\n    }\n",
    "3773": "    public String getInputEncoding(int encType) {\n        if (encType == HTML) {\n            return m_props.getProperty(\"html_in\", \"UTF-8\");\n        }\n        else if (encType == CSS) {\n            return m_props.getProperty(\"css_in\", \"UTF-8\");\n        }\n        else if (encType == HPP) {\n            return m_props.getProperty(\"hpp_in\", \"UTF-8\");\n        }\n        else if (encType == JS) {\n            return m_props.getProperty(\"js_in\", \"UTF-8\");\n        }\n        else if (encType == HCC) {\n            return m_props.getProperty(\"hcc_in\", \"UTF-8\");\n        }\n        m_logger.warn(\"Attempted to get input encoding for unrecognised encoding type.\");\n        return \"UTF-8\";\n    }\n",
    "3774": "    static public String getName(String path) {\n        String name = path;\n        try {\n            File file = new File(path);\n            name = file.getName();\n        }\n        catch (NullPointerException e) {\n            // okay\n        }\n        return name;\n        \n    }\n",
    "3777": "    public int getEncodingJTidyR7(String enc) {\n        if (enc.equalsIgnoreCase(\"ASCII\")) {\n            return org.w3c.tidy.Configuration.ASCII;\n        }\n        else if (enc.equalsIgnoreCase(\"ISO2022\")) {\n            return org.w3c.tidy.Configuration.ISO2022;\n        }\n        else if (enc.equalsIgnoreCase(\"LATIN1\")) {\n            return org.w3c.tidy.Configuration.LATIN1;\n        }\n        else if (enc.equalsIgnoreCase(\"MACROMAN\")) {\n            return org.w3c.tidy.Configuration.MACROMAN;\n        }\n        else if (enc.equalsIgnoreCase(\"RAW\")) {\n            return org.w3c.tidy.Configuration.RAW;\n        }\n        else if (enc.equalsIgnoreCase(\"UTF8\")) {\n            return org.w3c.tidy.Configuration.UTF8;\n        }\n        else {\n            return org.w3c.tidy.Configuration.UTF8;\n        }\n    \n    }\n",
    "3778": "    static public String getExtension(File f) {\n        return getExtension(f.getPath());\n    }\n",
    "3780": "    static public String getExtension(String path) {\n        int extStart = path.lastIndexOf(\".\");\n        if (extStart >= 0)\n            return path.substring(extStart).toLowerCase();\n        else\n            return \"\";  \n    }\n",
    "3782": "    static public String changeExtension(String path, String newExtension) {\n        String retStr;\n        int extStart = path.lastIndexOf(\".\");\n        if (extStart >= 0)\n            retStr = path.substring(0, extStart);\n        else\n            retStr = path;\n        if (newExtension.length() > 0) \n            retStr += (newExtension.charAt(0) == '.' ? newExtension : \".\" + newExtension);\n        return retStr;\n    }\n",
    "3787": "    static public boolean isExistingDirectory(String name) {\n        File file = new File(name);\n        return file != null && file.exists() && file.isDirectory();\n    }\n",
    "3788": "    public BufferedReader getBufferedFileReader(String inname, int encType) throws java.io.FileNotFoundException {\n        String enc = getInputEncoding(encType);\n        boolean encodingValid = false;\n        try {\n            encodingValid = Charset.isSupported(enc);\n        }\n        catch (Exception e) {\n            m_logger.warn(\"Unable to use encoding \" + enc + \".  \" + e.getMessage());\n        }\n        if (encodingValid) {\n            m_logger.info(\"Reader created with encoding \" + enc);\n            return new BufferedReader(new InputStreamReader(new FileInputStream(inname), Charset.forName(enc)));\n        }\n        else {\n            return new BufferedReader(new InputStreamReader(new FileInputStream(inname)));\n        }\n    }\n",
    "3791": "    static public boolean isExistingFile(String name) {\n        File file = new File(name);\n        return file != null && file.exists() && file.isFile();\n    }\n",
    "3792": "    public BufferedReader getBufferedReader(InputStream in, int encType) {\n        String enc = getInputEncoding(encType);\n        boolean encodingValid = false;\n        try {\n            encodingValid = Charset.isSupported(enc);\n        }\n        catch (Exception e) {\n            m_logger.warn(\"Unable to use encoding \" + enc + \".  \" + e.getMessage());\n        }\n        if (encodingValid) {\n            m_logger.info(\"Reader created with encoding \" + enc);\n            return new BufferedReader(new InputStreamReader(in, Charset.forName(enc)));\n        }\n        else {\n            return new BufferedReader(new InputStreamReader(in));\n        }\n    }\n",
    "3793": "    public String parse(HTMLDoc doc, Node node) {\n        if (node.getNodeName().equals(\"a\"))\n            return parseAnchor(doc, node);\n        else if (node.getNodeName().equals(\"script\"))\n            return parseScript(doc, node);\n        \n        return null;\n            \n    }\n",
    "3794": "    static public String toUri(String name) {\n        File file = new File(name);\n        String uri;\n        // Convert the file object to a URL\n        URL url = null;\n        try {\n            // The file need not exist. It is made into an absolute path\n            // by prefixing the current working directory\n            url = file.toURL();          // file:/d:/almanac1.4/java.io/filename\n            uri = url.toString();\n        } \n        catch (MalformedURLException e) {\n            uri = \"\";\n        }\n        return uri;\n    }\n",
    "3796": "    public boolean run() {\n        return true;\n    }\n",
    "3798": "   protected void logRunHeader(String header) {\n        logger.info(header);\n        logger.info(\"Source name: \" + sourceName);\n        logger.info(\"Target folder: \" + project.getTargetFolder());\n    }\n",
    "3800": "    protected void logRunFooter() {\n        // do nothing\n    }\n",
    "3801": "        public void setDocumentLocator(Locator locator) {\n            context.setLocator(locator);\n        }\n",
    "3802": "    private boolean createHTMLFile(String text, String targetName, String source) {\n        String htmlOut = \"<html><head><title>popup</title></head><body>\" + text + \"</body></html>\";\n        ByteArrayInputStream in = new ByteArrayInputStream(htmlOut.getBytes());\n        ParserHTML parser = new ParserHTML(project, source); \n        return parser.run((InputStream)in, targetName);\n    }\n",
    "3803": "    protected void logMessageAtLine(String message) {\n        logger.info(\"Line \" + lineNumber + \": \" + message);\n    }\n",
    "3805": "    protected void logWarningAtLine(String message) {\n        logger.warn(\"Line \" + lineNumber + \": \" + message);\n    }\n",
    "3806": "    private String getPopupIdName(String text) {\n        int start;\n        int end;\n        try {\n            start = text.indexOf(popupSignature);\n            end = start + popupSignature.length();\n            \n            while (CharUtility.isAsciiVariable(text.charAt(end)) ) {\n                end++;\n            }\n        }\n        catch (IndexOutOfBoundsException e) {\n            logger.warn(\"Could not decode popup id from \" + text);\n            return null;\n        }\n        if (start >= 0 && end > start) \n            return text.substring(start, end);\n        return null;\n        \n    }\n",
    "3807": "    protected boolean startReader(int encType) {\n        boolean bOkay = true;\n        reader = null;\n        lineNumber = 0;\n        try {\n            // reader = new BufferedReader(new FileReader(sourceName));\n            reader = EncodingManager.getInstance().getBufferedFileReader(sourceName, encType);\n        }\n        catch(FileNotFoundException e) {\n            logger.warn(\"Cannot open file \" + sourceName + \": \" + e.toString());\n            \n            bOkay = false;\n        }\n        return bOkay;\n    }\n",
    "3809": "    private void processSource(String name) {\n        if (sourceFiles.contains(name)) {\n            logger.debug(\"Already handled \" + name);\n            return;\n        }\n\n        sourceFiles.add(name);\n        \n        File f = new File(name);\n        String line;\n        boolean processing = true;\n        while (processing) {\n            processing = false;\n        }\n    \n    }\n",
    "3810": "    protected String getLine() {\n        String retLine = null;\n        try {\n            retLine = reader.readLine();\n            lineNumber++;\n        }\n        \n        catch (IOException e) {\n            logger.warn(\"IO error reading \" + sourceName + \"at line \" + lineNumber + \": \" + e.toString());\n            \n        }\n        return retLine;\n    }\n",
    "3814": "    private void handleAssignments(String line) {\n        String[] elements = line.split(\"=\");\n        if (elements.length > 1) {\n            String attribute = elements[0].trim().toUpperCase();\n            String value = elements[1].trim();\n            if (attribute.equals(\"TITLE\")) {\n                title = value;\n                logger.debug(\"Set attribute \" + attribute + \" to \" + value );\n            } \n            else if (attribute.equals(\"INDEX FILE\")) {\n                indexName = value;\n                logger.debug(\"Set attribute \" + attribute + \" to \" + value );\n            }\n            else if (attribute.equals(\"CONTENTS FILE\")) {\n                contentsName = value;\n                logger.debug(\"Set attribute \" + attribute + \" to \" + value);\n            }\n            else if (attribute.equals(\"DEFAULT TOPIC\")) {\n                defaultTopic = value;\n                logger.debug(\"Set attribute \" + attribute + \" to \" + value);\n            }\n        }\n    }\n",
    "3816": "    public void setMap(HashMap argMap) {\n        map = argMap;\n    }\n",
    "3818": "    public String getIndexName() {\n        return indexName;\n    }\n",
    "3819": "        public void endElement(String uri, String name, String qName) throws SAXException {\n            currentHandler.onEndElement(uri, name, context);\n            AntHandler prev = (AntHandler) antHandlers.pop();\n            currentHandler = prev;\n            if (currentHandler != null) {\n                currentHandler.onEndChild(uri, name, qName, context);\n            }\n        }\n",
    "3821": "    public void buildMap(XMLDoc doc) {\n        org.w3c.dom.Node node;\n        org.w3c.dom.Element element;\n        element = doc.addElement(null, \"maps\");\n        doc.addElement((org.w3c.dom.Node)element, \"homeID\", defaultTopicId);\n        element = doc.addElement((org.w3c.dom.Node)element, \"mapref\");\n        doc.setAttribute(element, \"location\", project.getProjectName() + \".jhm\");\n    }\n",
    "3822": "    public String getQuotedText(String text, boolean toHTML) {\n        StringBuffer out = new StringBuffer(100);\n        int end = text.length();\n        try {\n            int start = text.indexOf('\\\"');\n            start++;\n            while (start < end) {\n                if (text.charAt(start) == '\\\"')\n                    break;\n                if (text.charAt(start) == '\\\\')\n                    out.append(unescape(text.charAt(++start), toHTML));\n                else\n                    out.append(text.charAt(start));\n                start++;\n            }\n        }\n        catch (IndexOutOfBoundsException e) {\n            logger.warn(\"Error finding javascript quoted line: \" + e.getMessage());\n            return null;\n        }\n        return out.toString();\n    }\n",
    "3823": "    public String getContentsName() {\n        return contentsName;\n    }\n",
    "3824": "    private String unescape(char esc, boolean toHTML) {\n        if (esc == 'n')\n            return toHTML ? \"<br>\" : \"\\n\";\n        else if (esc == 'r')\n            return toHTML ? \"\" : \"\\r\"; // ignored as only handle \\n\n        else if (esc == 't')\n            return toHTML ? \"&nbsp;&nbsp;&nbsp;&nbsp;\" : \"\\r\";\n        else if (esc == '\\\\')\n            return \"\\\\\";\n        else if (esc == 'f')\n            return toHTML ? \"<hr>\" : \"\\f\";\n        else if (esc == '\\'')\n            return \"\\'\";\n        else if (esc == '\\\"')\n            return \"\\\"\";\n        else\n            return String.valueOf(esc); // ignore the escaping\n    }\n",
    "3825": "    public void buildView(XMLDoc doc, String merge, String name, String label, String typeName, String data ) {\n        org.w3c.dom.Node node;\n        org.w3c.dom.Element element;\n        \n        element = doc.addElement(null, \"view\");\n     \n        doc.setAttribute(element, \"xml:lang\", EncodingManager.getInstance().getLanguage(EncodingManager.HS));\n        doc.setAttribute(element, \"mergetype\", merge);\n        doc.addElement((org.w3c.dom.Node)element, \"name\", name);\n        doc.addElement((org.w3c.dom.Node)element, \"label\", label);\n        doc.addElement((org.w3c.dom.Node)element, \"type\", typeName);\n        doc.addElement((org.w3c.dom.Node)element, \"data\", data);\n      \n        \n    }\n",
    "3826": "    public String getTitle() {\n        return title;\n    }\n",
    "3829": "    public HashMap getLinks() {\n        return links;\n    }\n",
    "3831": "    public String getDefaultTopic() {\n        return defaultTopic;\n    }\n",
    "3833": "    public void setDefaultTopicId(String id) {\n        defaultTopicId = id;\n    }\n",
    "3835": "    public String getDefaultTopicId() {\n        return defaultTopicId;\n    }\n",
    "3837": "    public HashSet getHtmlFiles() {\n        return htmlFiles;\n    }\n",
    "3838": "    public boolean write(BufferedWriter writer) throws IOException {\n        logger.debug(\"Writing the HTMLDoc to file.\");\n        if (htmlDoc == null) {\n            logger.warn(\"Attempt to write a null XML document.\");\n            return false;\n        }\n        // writer.write(\"<?xml version='1.0' encoding='ISO-8859-1' ?>\");\n        writer.write(NEW_LINE);\n        writer.write(getDocTypeString());\n        String rawText = getDocumentNode(htmlDoc.getDocumentElement(), \" \");\n        writer.write(replaceText(rawText));\n        return true;\n    }\n",
    "3839": "    public  void setLinks(HashMap argLinks) {\n        links = argLinks;\n    }\n",
    "3840": "    public String getFileName() {\n        return fileName;\n    }\n",
    "3844": "     private void buildDocument(XMLDoc doc) {\n        org.w3c.dom.Node node;\n        org.w3c.dom.Element element;\n        doc.setAttribute(null, \"version\", \"2.0\");\n        doc.setAttribute(null, \"xml:lang\", EncodingManager.getInstance().getLanguage(EncodingManager.MAP));\n        doc.addComment(null, \"Map IDs\");\n\n        // iterate through the map adding the links\n        Set set = links.entrySet();\n        Iterator it = set.iterator();\n        while (it.hasNext()) {\n            Map.Entry ent = (Map.Entry)it.next();\n            String target = (String)ent.getValue();\n            String url = (String)ent.getKey();\n            addID(doc, target, url);\n        }\n    }\n",
    "3845": "    public boolean run() {\n        logRunHeader(\"Parsing css file.\");\n        FileInputStream in = null;\n\n        try {\n            in = new FileInputStream(sourceName);\n        }\n        catch (FileNotFoundException e) {\n            logger.warn(\"Error reading css file: \" + e.getMessage());\n            return false;\n        }\n       \n        return run(in, sourceName);\n    }\n",
    "3846": "     private void addID(XMLDoc doc, String target, String url) {\n        org.w3c.dom.Element element;\n        element = doc.addElement(null, \"mapID\");\n        doc.setAttribute(element, \"target\", target);\n        doc.setAttribute(element, \"url\", url); \n     }\n",
    "3848": "        public void startPrefixMapping(String prefix, String uri) {\n            context.startPrefixMapping(prefix, uri);\n        }\n",
    "3851": "    public boolean run() {\n        logRunHeader(\"Parsing HTML file.\");\n        FileInputStream in = null;\n\n        try {\n            in = new FileInputStream(sourceName);\n        }\n        catch (FileNotFoundException e) {\n            logger.warn(\"Error reading HTML file: \" + e.getMessage());\n            return false;\n        }\n       \n        return run(in, sourceName);\n        \n        \n    }\n",
    "3852": "    public String replaceQuotes(String str) {\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == QUOTE) \n                buf.append(QUOTE_ENTITY);\n            else\n                buf.append(str.charAt(i));\n        }\n        return buf.toString();\n    } \n",
    "3853": "    private void copyImageFile(String image) {\n        File fin =new File(FileManager.buildPath(sourceFolder, image, \"\"));\n        File fout = new File(FileManager.buildPath(project.getTargetFolder(), image, \"\"));\n        if (!fin.exists()) \n            logger.warn(\"Image \" + fin.getPath() + \"does not exist.\");\n        else {\n            logger.info(\"Copy \" + fin.getPath() + \" to \" + fout.getPath());\n            try {\n                FileManager.copyFile(fin, fout);\n            }\n            catch (Exception e) {\n                logger.warn(\"Error copying files. \" + e.toString());\n            }\n        }\n    }\n",
    "3856": "    private String replaceElement(org.w3c.dom.Node node) {\n        String nodeName = node.getNodeName();\n        // handle any popup information\n        String popup = popupParser.parse(this, node); \n        if (popup != null)\n            return popup;\n        \n        if (nodeName.equals(\"object\")) {\n            return objectParser.parse(this, node);\n        }\n        else if (nodeName.equals(\"embed\")) {\n            objectParser.handleEmbed(this, node);\n        }\n        \n        if (replaceElements == null)\n            return null;\n        return replaceElements.getProperty(nodeName);\n    }\n",
    "3857": "    private void createFullIndexItem(org.w3c.dom.Element parentIndexItem) {\n        if (!skipElement(currentIndexItem, currentName)) {\n            currentIndexItem = xmlDoc.addElement(parentIndexItem, \"indexitem\");\n            xmlDoc.setAttribute(currentIndexItem, \"text\", currentName);\n            String mapID = (String)map.get(currentTarget);\n            if (mapID == null) {\n                // couldn't find the mapID\n                mapID = handleUnknownTarget(currentTarget);\n            }\n            xmlDoc.setAttribute(currentIndexItem, \"target\", mapID);\n        }\n    }\n",
    "3859": "        public void endPrefixMapping(String prefix) {\n            context.endPrefixMapping(prefix);\n        }\n",
    "3860": "    private String handleUnknownTarget(String url) {\n        String id = null;\n        logger.debug(\"Unknown target \" + url);\n        String[] parts = url.split(\"#\");\n        if (parts.length > 1) {\n            logger.debug(\"Anchor so add to map.\");\n            id = (String)map.get(parts[0]);\n            if (id != null) {\n                // okay the target document does exist so we can add the anchor\n                id = id + \"#\" + parts[1] + \"_\"; // form a new map id\n                map.put(url, id);\n            }\n            else\n                logger.warn(\"Anchor to missing target file found. \" + url);\n        }\n        \n        return id;\n    }\n",
    "3862": "    private String replaceText(String str) {\n        return TextReplacer.replaceText(replaceText, str);\n    }\n",
    "3864": "    private void createTargetlessIndexItem(org.w3c.dom.Element parentIndexItem) {\n        if (!skipElement(currentIndexItem, currentName)) {\n            currentIndexItem = xmlDoc.addElement(parentIndexItem, \"indexitem\");\n            xmlDoc.setAttribute(currentIndexItem, \"text\", currentName);\n        }\n    }\n",
    "3865": "    public void handleEmbed(HTMLDoc doc, Node node) {\n       if (currentNode != null) {\n           source = doc.getAttribute(node, \"src\");\n       } \n    }\n",
    "3866": "    private String getLinkText(String classID) {\n        if (classID == null) \n            return \"\";\n        String classText = null;\n        \n        classText = props.getProperty(classID, props.getProperty(\"unknownClass\", \"Unknown object.  Not supported in JavaHelp\"));\n        if (source == null)\n           return classText;\n        \n        if (classText.startsWith(PopupSecondaryViewer.VIEWER_TAG)) {\n            PopupSecondaryViewer sv = new PopupSecondaryViewer(props, classText.replace(\"__SOURCE__\", source));\n            return sv.getJHObject(source);\n        }\n        else\n            return classText.replace(\"__SOURCE__\", source);\n    }\n",
    "3867": "    private String handleWrapperTag(org.w3c.dom.Node node, StringBuffer nodeStr) {\n        String endWrapper = \"\";\n        if (node.getNodeName().equals(\"table\")) {\n            String color = getAttribute(node, \"bgcolor\");\n            if (color != null) {\n                nodeStr.append(\"<div style=\\\"background-color:\" +  color + \"\\\">\\n\");\n                endWrapper = \"</div>\\n\";\n            }\n        }\n        return endWrapper;\n    }\n",
    "3869": "    public String getDocTypeString() {\n        StringBuffer buffer = new StringBuffer(1000);\n        String str;\n        buffer.append(\"<!DOCTYPE \");\n        buffer.append(docType.getName());\n        if ((str = docType.getSystemId()) != null)\n            buffer.append(\"\\n   SYSTEM \\\"\" + str + \"\\\"\");\n        if ((str = docType.getPublicId()) != null)\n            buffer.append(\"\\n   PUBLIC \\\"\" + str + \"\\\"\");\n        if ((str = docType.getInternalSubset()) != null)\n            buffer.append(\"\\n   [\" + str + \"]\");\n        if (namespace != null)\n            buffer.append(\"\\n   \\\"\" + namespace + \"\\\"\");\n        \n        buffer.append(\">\\n\");\n        return buffer.toString();\n        \n    }\n",
    "3870": "    private String additionalChildren(org.w3c.dom.Node node) {\n        if (node.getNodeName().equals(\"head\")) {\n            // we need to put the encoding string at the top or JavaHelp seems to ignore it.\n            return EncodingManager.getInstance().getEncodingTag(EncodingManager.HTML) + \"\\n\";\n        }\n        return \"\";\n    } \n",
    "3871": "    private boolean skipElement(org.w3c.dom.Element prev, String text) {\n        String oldText = xmlDoc.getAttribute(prev, \"text\");\n        if (oldText == null)\n            return false;\n        return oldText.equals(text);\n    }\n",
    "3872": "    public boolean write(BufferedWriter writer, String tag) throws IOException {\n        if (doc == null) {\n            logger.warn(\"Attempt to write a null XML document.\");\n            return false;\n        }\n        writer.write(tag);\n        writer.write(NEW_LINE);\n        writer.write(getDocTypeString());\n        writer.write(getDocumentNode(doc.getDocumentElement(), \"\"));\n        return true;\n    }\n",
    "3881": "    public HashMap getMap() {\n        return map;\n    }\n",
    "3883": "    public String replaceQuotes(String str) {\n        if (str == null) {\n            return \"\";\n        }\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == QUOTE) \n                buf.append(QUOTE_ENTITY);\n            else\n                buf.append(str.charAt(i));\n        }\n        return buf.toString();\n    }\n",
    "3971": "        public void onEndElement(String uri, String tag, AntXMLContext context) {\n            context.setCurrentTarget(context.getImplicitTarget());\n        }\n",
    "4041": "        public void onEndElement(String uri, String tag, AntXMLContext context) {\n            context.popWrapper();\n        }\n",
    "4413": "\tpublic boolean accept(File f){\n\t\tif(f.isDirectory()){\n\t\t\treturn true;\n\t\t}\n\t\tString extension = f.getName();\n\t\tint index = extension.lastIndexOf('.');\n\t\tif(index == -1){\n\t\t\treturn false;\n\t\t}\n\t\textension = extension.substring(index).toLowerCase();\n\t\tif (extension != null) {\n\t    \tif (extension.equals(WEIGHTS_EXTENSION)) {\n\t\t        return true;\n\t    \t} else {\n\t    \t\treturn false;\n\t    \t}\n\t    }\n\n\t    return false;\n\t}\n",
    "4415": "\tpublic String getDescription(){\n\t\treturn WEIGHTS_DESCRIPTION;\n\t}\n",
    "4417": "\tpublic boolean accept(File f){\n\t\tif(f.isDirectory()){\n\t\t\treturn true;\n\t\t}\n\t\tString extension = f.getName();\n\t\tint index = extension.lastIndexOf('.');\n\t\tif(index == -1){\n\t\t\treturn false;\n\t\t}\n\t\textension = extension.substring(index).toLowerCase();\n\t\tif (extension != null) {\n\t\t\tif (extension.equals(LOG_FILE_EXTENSION)) {\n\t\t        return true;\n\t\t\t} else {\n\t\t\t    return false;\n\t\t\t}\n\t    }\n\n\t    return false;\n\t}\n",
    "4419": "\tpublic String getDescription(){\n\t\treturn LOG_FILE_DESCRIPTION;\n\t}\n",
    "4421": "\tpublic boolean accept(File f){\n\t\tif(f.isDirectory()){\n\t\t\treturn true;\n\t\t}\n\t\tString extension = f.getName();\n\t\tint index = extension.lastIndexOf('.');\n\t\tif(index == -1){\n\t\t\treturn false;\n\t\t}\n\t\textension = extension.substring(index).toLowerCase();\n\t\tif (extension != null) {\n\t    \tif (extension.equals(PERFORMANCE_CONFIG_EXTENSION)) {\n\t\t        return true;\n\t    \t} else {\n\t    \t\treturn false;\n\t    \t}\n\t    }\n\n\t    return false;\n\t}\n",
    "4422": "\tpublic String getDescription(){\n\t\treturn PERFORMANCE_CONFIG_DESCRIPTION;\n\t}\n",
    "4437": "\tpublic boolean accept(File f){\n\t\tif(f.isDirectory()){\n\t\t\treturn true;\n\t\t}\n\t\tString extension = f.getName();\n\t\tint index = extension.lastIndexOf('.');\n\t\tif(index == -1){\n\t\t\treturn false;\n\t\t}\n\t\textension = extension.substring(index).toLowerCase();\n\t    if (extension != null) {\n\t    \tif (extension.equals(CASEBASE_EXTENSION)) {\n\t\t        return true;\n\t    \t} else {\n\t    \t\treturn false;\n\t    \t}\n\t    }\n\n\t    return false;\n\t}\n",
    "4438": "\tpublic String getDescription(){\n\t\treturn CASEBASE_DESCRIPTION;\n\t}\n",
    "4448": "    public void TeamNameMissing(CaseEvent ce){\n\tSystem.err.println(\"The Log File doesn't contain initialization messages.\");\n\tSystem.err.println(\"Please run again with the third parameter.\");\n\tSystem.err.println(\" \");\n\tdisplayUsage();\n\tSystem.exit(1);\n    }\n",
    "4451": "    public void GotInputs(CaseEvent ce){\n\tm_lastInputs=ce.getAgentInputs();\n    }\n",
    "4453": "    public void GotActions(CaseEvent ce){\n\tm_actionList=ce.getAgentActions();\n\tCase c = new Case(m_lastInputs,m_actionList);\n\tm_casebase.addCase(c);\n    }\n",
    "4459": "    public CaseBase getCaseBase(){\n\treturn new CaseBase(this.m_casebase);\n    }\n",
    "4462": "    public void writeCaseBaseFile() throws IOException {\n\t\t\n\tCaseBaseIO.saveCaseBase(this.m_casebase,this.m_outputFileName);\n\t\t\n    }\n",
    "4464": "\tpublic void setHorizontalPosition(String pos){\n\t\t//check params\n\t\tif(pos == null){\n\t\t\tthrow new IllegalArgumentException(\"Horizonal position of a flag set to a null value.\");\n\t\t}\n\t\t\n\t\t//make sure a valid value was given\n\t\tif(!pos.equals(FlagFeature.c_LEFT) && !pos.equals(FlagFeature.c_RIGHT) && !pos.equals(FlagFeature.c_CENTER) && !pos.equals(FlagFeature.c_TOP) && !pos.equals(FlagFeature.c_BOTTOM)){\n\t\t\tthrow new IllegalArgumentException(\"Horizonal position of a flag set to an invalid value: \" + pos);\n\t\t}\n\t\t\n\t\tthis.m_horizontal = pos;\n\t}\n",
    "4467": "\tpublic String getHorizontalPosition(){\n\t\treturn this.m_horizontal;\n\t}\n",
    "4471": "\tpublic void setVerticalPosition(String pos){\n\t\t//check params\n\t\tif(pos == null){\n\t\t\tthrow new IllegalArgumentException(\"Vertical position of a flag set to a null value.\");\n\t\t}\n\t\t\n\t\t//make sure a valid value was given\n\t\tif(!pos.equals(FlagFeature.c_TOP) && !pos.equals(FlagFeature.c_BOTTOM) && !pos.equals(FlagFeature.c_CENTER) && !pos.equals(FlagFeature.c_LEFT) && !pos.equals(FlagFeature.c_RIGHT)){\n\t\t\tthrow new IllegalArgumentException(\"Vertical position of a flag set to an invalid value: \" + pos);\n\t\t}\n\t\t\n\t\tthis.m_vertical = pos;\n\t}\n",
    "4472": "\tpublic String getVerticalPosition(){\n\t\treturn this.m_vertical;\n\t}\n",
    "4473": "        public String toString(){\n\t    String result=super.toString()+\":\";\n\t    result+=Float.toString(this.m_distanceChange)+\":\";\n\t    result+=Float.toString(this.m_directionChange);\n\t    return result;\n\t}\n",
    "4476": "        public RoboCupSimulation2DSpatialObject copyOfThis(){\n\t    RoboCupSimulation2DSpatialObject copy=new RoboCupSimulation2DSpatialObject(this.getFeatureName());\n\t    copy.setDistance(this.getDistance());\n\t    copy.setDirection(this.getDirection());\n\t    copy.setDistanceChange(this.m_distanceChange);\n\t    copy.setDirectionChange(this.m_directionChange);\n\t    return copy;\n\t}\n",
    "4477": "\tpublic void setOutOfBounds(boolean out){\n\t\tthis.m_outOfBounds = out;\n\t}\n",
    "4478": "\tpublic void setDistanceChange(float distChange){\n\t\tthis.m_distanceChange = distChange;\n\t}\n",
    "4479": "\tpublic boolean isOutOfBounds(){\n\t\treturn this.m_outOfBounds;\n\t}\n",
    "4480": "\tpublic void setDirectionChange(float dirChange){\n\t\tthis.m_directionChange = dirChange;\n\t}\n",
    "4481": "\tpublic void setFlagNumber(int num){\n\t\tthis.m_flagNumber = num;\n\t}\n",
    "4483": "\tpublic float getDistanceChange(){\n\t\treturn this.m_distanceChange;\n\t}\n",
    "4485": "\tpublic float getDirectionChange(){\n\t\treturn this.m_directionChange;\n\t}\n",
    "4486": "\tpublic int getFlagNumber(){\n\t\treturn this.m_flagNumber;\n\t}\n",
    "4488": "\tpublic void setLocation(String s){\n\t\t//check parameters\n\t\tif(s == null){\n\t\t\tthrow new IllegalArgumentException(\"Null parameter given.\");\n\t\t}\n\t\t//check for invalid locations\n\t\tString lowerside = s.toLowerCase();\n\t\tif( !(lowerside.equals(LineFeature.c_LOCATION_LEFT)) && !(lowerside.equals(LineFeature.c_LOCATION_RIGHT)) && !(lowerside.equals(LineFeature.c_LOCATION_TOP)) && !(lowerside.equals(LineFeature.c_LOCATION_BOTTOM))){\n\t\t\tthrow new IllegalArgumentException(\"Illegal line position: \" + lowerside);\n\t\t}\n\t\t\n\t\tthis.m_location = lowerside;\n\t}\n",
    "4489": "\tprivate String browseForExistingFile(int fileType) {\n\t\tthis.fileChooser.resetChoosableFileFilters();\n\t\tswitch(fileType){\n\t\tcase CASE_BASE_FILE:\n\t\t\tthis.fileChooser.addChoosableFileFilter(new CaseBaseFileFilter());\n\t\t\tbreak;\n\t\tcase WEIGHTS_FILE:\n\t\t\tthis.fileChooser.addChoosableFileFilter(new WeightsFileFilter());\n\t\t\tbreak;\n\t\tcase CONFIG_FILE:\n\t\t\tthis.fileChooser.addChoosableFileFilter(new PerformanceConfigFileFilter());\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint returnVal = this.fileChooser.showOpenDialog(this);\n\t\t\n\t\tif(returnVal == JFileChooser.APPROVE_OPTION){\n\t\t\treturn fileChooser.getSelectedFile().getAbsolutePath();\n\t\t}\n        else {\n            return \"\";\n        }\n\t}\n",
    "4490": "\tpublic void setBox(String box){\n\t\t//check params\n\t\tif(box == null){\n\t\t\tthrow new IllegalArgumentException(\"Box location of a flag set to a null value.\");\n\t\t}\n\t\t\n\t\t//make sure a valid value was given\n\t\tif(!box.equals(FlagFeature.c_GOAL_BOX) && !box.equals(FlagFeature.c_PENALTY_BOX) ){\n\t\t\tthrow new IllegalArgumentException(\"Box location of a flag set to an invalid value: \" + box);\n\t\t}\n\t\t\n\t\tthis.m_box = box;\n\t}\n",
    "4491": "\tpublic String getLocation(){\n\t\treturn new String(this.m_location);\n\t}\n",
    "4494": "\tpublic float getBodyDirection() {\n\t\treturn this.m_bodyDirection;\n\t}\n",
    "4495": "\tpublic String getBox(){\n\t\treturn this.m_box;\n\t}\n",
    "4496": "\tpublic void setBodyDirection(float direction) {\n\t\tthis.m_bodyDirection = direction;\n\t}\n",
    "4498": "\tpublic float getHeadDirection() {\n\t\treturn this.m_headDirection;\n\t}\n",
    "4500": "\tpublic void setHeadDirection(float direction) {\n\t\tthis.m_headDirection = direction;\n\t}\n",
    "4501": "\tpublic boolean isGoalie() {\n\t\treturn this.m_isGoalie;\n\t}\n",
    "4502": "\tpublic void setSide(String side){\n\t\t//test the params\n\t\tif(side == null){\n\t\t\tthrow new IllegalArgumentException(\"Null parameter given.\");\n\t\t}\n\t\t//make sure a valid side selected\n\t\tString lowerside = side.toLowerCase();\n\t\tif( !(lowerside.equals(GoalFeature.c_SIDE_LEFT)) && !(lowerside.equals(GoalFeature.c_SIDE_RIGHT))){\n\t\t\tthrow new IllegalArgumentException(\"Invalid side given for goal.\");\n\t\t}\n\t\t\n\t\t//save the side\n\t\tthis.m_side = lowerside;\n\t}\n",
    "4503": "\tpublic void setIsGoalie(boolean goalie) {\n\t\tthis.m_isGoalie = goalie;\n\t}\n",
    "4505": "\tpublic String getSide(){\n\t\treturn new String(this.m_side);\n\t}\n",
    "4506": "\tpublic int getUniformNumber() {\n\t\treturn this.m_uniformNumber;\n\t}\n",
    "4509": "\tpublic void setUniformNumber(int number) {\n\t\tthis.m_uniformNumber = number;\n\t}\n",
    "4511": "        public TurnNeckAction copyThis(){\n\t    return new TurnNeckAction(this);\n\t}\n",
    "4512": "        public DashAction copyThis(){\n\t    return new DashAction(this);\n\t}\n",
    "4513": "\tpublic float getDashPower(){\n\t\treturn this.m_power;\n\t}\n",
    "4515": "\tpublic float getTurnNeckAngle(){\n\t\treturn this.m_angle;\n\t}\n",
    "4516": "        public String getAttrib(String attrib){\n\t    if(attrib.compareTo(\"power\") == 0)\n\t\treturn Float.toString(this.m_power);\n\t    return \"\";\n\t}\n",
    "4517": "        public CatchAction copyThis(){\n\t    return new CatchAction(this);\n\t}\n",
    "4518": "        public String getAttrib(String attrib){\n\t    if(attrib.compareTo(\"angle\") == 0)\n\t\treturn Float.toString(this.m_angle);\n\t    return \"\";\n\t}\n",
    "4520": "\tpublic float getCatchAngle(){\n\t\treturn this.m_angle;\n\t}\n",
    "4521": "        public KickAction copyThis(){\n\t    return new KickAction(this);\n\t}\n",
    "4523": "\tprivate void runLog2CaseBase(){\n\t\tString input = this.jInputFileName.getText();\n\t\tString output = this.jOutputFileName.getText();\n\t\tString team = this.jTeamName.getText();\n\t\ttry{\n\t\t\tLogFile2CaseBase builder = new LogFile2CaseBase(input, output, team);\n\t\t\tbuilder.parseLogFile();\n\t\t\tbuilder.writeCaseBaseFile();\n\t\t\tJOptionPane.showMessageDialog(this, \"Case base written to \" + output, \"Complete\", JOptionPane.INFORMATION_MESSAGE);\n\t\t}catch(Exception e){\n\t\t\tJOptionPane.showMessageDialog(this, \"Error: \" + e.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\n\t\t}\n\t}\n",
    "4525": "\tpublic float getKickPower(){\n\t\treturn this.m_power;\n\t}\n",
    "4527": "        public TurnAction copyThis(){\n\t    return new TurnAction(this);\n\t}\n",
    "4528": "\tpublic float getKickAngle(){\n\t\treturn this.m_angle;\n\t}\n",
    "4530": "        public String getAttrib(String attrib){\n\t    if(attrib.compareTo(\"power\") == 0)\n\t\treturn Float.toString(this.m_power);\n\t    if(attrib.compareTo(\"angle\") == 0)\n\t\treturn Float.toString(this.m_angle);\n\t    return \"\";\n\t}\n",
    "4531": "\tpublic float getTurnAngle(){\n\t\treturn this.m_angle;\n\t}\n",
    "4533": "\tpublic void see(AgentInputs inputs){\n\t\t  this.m_vision.store(inputs);\n\t  }\n",
    "4535": "\tpublic void setTimeOver(boolean b) {\n\t\tthis.m_timeOver = b;\n\t}\n",
    "4539": "\tprivate void displayAboutMessage(){\n\t\tJOptionPane.showMessageDialog(this, this.c_ABOUTMESSAGE, \"About RCSImitate\", JOptionPane.PLAIN_MESSAGE);\n\t}\n",
    "4541": "    public void run(){\n\ttry {\n\t    execute();\n\t} catch (Exception e) {\n\t    System.out.println(\"Fatal Error: \" + e.getMessage());\n\t}\n    }\n",
    "4542": "    private void initAgent(CaseBase cb) {\n\t    CaseBaseSearch cbSearch = new NearestNeighbourSearch(1);\n\t    ActionEstimation ae = new LastActionEstimate();\n\t    ActionSelection actionSelection = new ClosestNeighbourSelection(ae);\n\t    \n\t    // Create an agent with the dummy case base\n\t    agent = new Agent(cb,cbSearch,actionSelection);\n    }\n",
    "4546": "    private void initWeights(String weightsFile) {\n        // If no file was specified, use default values\n        if (weightsFile == null) {\n            weights = new Weights(0.0f);\n            weights.setWeight(BallFeature.c_BALL, 1.0f);\n            weights.setWeight(TeammatePlayerFeature.c_TEAMMATE, 1.0f);\n            return;\n        }\n\n        try {\n            weights = WeightsIO.loadWeights(weightsFile);\n        }\n        catch (FileNotFoundException fnfe) {\n            // If an error occurs, use default values\n            weights = new Weights(0.0f);\n            weights.setWeight(BallFeature.c_BALL, 1.0f);\n            weights.setWeight(TeammatePlayerFeature.c_TEAMMATE, 1.0f);\n        }\n    }\n",
    "4547": "\tprivate void displayHelpLog2CaseBaseMessage(){\n\t\tJOptionPane.showMessageDialog(this, this.c_HELPLOG2CASEBASEMESSAGE, \"Help\", JOptionPane.PLAIN_MESSAGE);\n\t}\n",
    "4548": "    public void move(double x, double y){\n\t//the message will be (move X Y)\n\tsend(\"(move \" + Double.toString(x) + \" \" + Double.toString(y) + \")\");\n    }\n",
    "4549": "    public void addCEListener(CaseEventListener cel){\n\tCEListeners.add(cel);\n    }\n",
    "4550": "    public void turn(double moment){\n\t//the message will be (turn moment)\n\tsend(\"(turn \" + Double.toString(moment) + \")\");\n    }\n",
    "4552": "    public void removeCEListener(CaseEventListener cel){\n\tCEListeners.remove(cel);\n    }\n",
    "4553": "    public void turn_neck(double moment){\n\t//the message will be (turn_neck moment)\n\tsend(\"(turn_neck \" + Double.toString(moment) + \")\");\n    }\n",
    "4555": "    public void performTests() {\n\tapplyPreprocessing(testBase, testFilenameRoot);\n\t\n\tapplyPreprocessing(agentBase, agentFilenameRoot);\n\n\t// the global values must after the weights are final\n\tsetGlobalValues(weights);\n\n\t// reset the test classes\n\tinitTests();\n\t\n\tinitAgent(agentBase);\n\t\n\trunTests(testBase);\n\t\n\tsaveExpectedAndReceived();\n\t\n\tSystem.out.println(\"[\" + getTime() + \"]: Results:\\n\");\n\t\n\tSystem.out.println(getReportString());\n\t\n\t// Space out the output\n\tSystem.out.println();\n\t\n\t// Outputs result data to text files\n\toutputResultToFile();\n\toutputExpectedActualToFile();\n    }\n",
    "4556": "    public void ClientInit(ParsingEvent pe){\n\tm_teamName=pe.get(\"team_name\");\n\tCaseEvent ce = new CaseEvent(this,m_teamName);\n\tfor(CaseEventListener cel:CEListeners) cel.Connecting(ce);\n    }\n",
    "4557": "    public void dash(double power){\n\t//the message will be (dash power)\n\tsend(\"(dash \" + Double.toString(power) + \")\");\n    }\n",
    "4558": "    public void ServerInit(ParsingEvent pe){\n\tCaseEvent ce = new CaseEvent(this);\n\tfor(CaseEventListener cel:CEListeners) cel.Connected(ce);\n    }\n",
    "4559": "    public void kick(double power, double direction){\n\t//the message will be (kick power direction)\n\tsend(\"(kick \" + Double.toString(power) + \" \" + Double.toString(direction) + \")\");\n    }\n",
    "4561": "    private void outputResultToFile(){\n    \ttry{\n\t    \tPrintStream output = new PrintStream(new File(\"Results-\" + testID + \".txt\"));\n\t    \toutput.println(\"[\" + getTime() + \"]: Results:\\n\");\n\t    \toutput.println(getReportString());\n\t    \toutput.close();\n    \t}catch(IOException e){\n    \t\tSystem.out.println(\"Result File Creation Error\");\n    \t}\n    }\n",
    "4562": "    public void say(String message){\n\t//message will be (say message)\n\tsend(\"(say \" + message + \")\");\n    }\n",
    "4563": "    public void Sensing(ParsingEvent pe){\n\tif(m_teamName.equals(\"\")){\n\t    CaseEvent ce = new CaseEvent(this);\n\t    for(CaseEventListener cel:CEListeners) cel.TeamNameMissing(ce);\n\t}\n\telse{\n\t    if(m_lastInputs.getNumberSensoryItems()>0){\n\t\tCaseEvent ce = new CaseEvent(this,m_actionList);\n\t\tfor(CaseEventListener cel:CEListeners) cel.GotActions(ce);\n\t    }\n\t    m_lastInputs = new AgentInputs();\n\t    m_actionList = new ArrayList<AgentAction>();\n\t}\n    }\n",
    "4565": "    private void outputExpectedActualToFile(){\n    \tif(saveArtifacts){\n\t    \ttry{\n\t    \t\tPrintStream output = new PrintStream(new File(\"Expected-Actual-\" + testID + \".txt\"));\n\t    \t\toutput.println(saveExpectedAndReceived());\n\t    \t\toutput.close();\n\t    \t}catch(IOException e){\n\t    \t\tSystem.out.println(\"Expected Acutal File Creation Error\");\n\t    \t}\n    \t}\n    }\n",
    "4566": "    public void changeView(String angle, String quality){\n\t//message will be (change_view angle quality)\n\tsend(\"(change_view \" + angle + \" \" + quality + \")\");\n    }\n",
    "4567": "    public void SeeReceived(ParsingEvent pe){\n\tm_lastInputs = new AgentInputs();\n    }\n",
    "4569": "    public void catchBall(String direction){\n\t//message will be (catch direction)\n\tsend(\"(catch \" + direction + \")\");\n    }\n",
    "4571": "    private void applyPreprocessing(CaseBase cb, StringBuilder filenameRoot) {\n\tfor (String action : preprocessingActions) {\n\t    if (action.matches(\"(?i)(NoActionsFilter)|(naf)\")) {\n\t\tapplyNoActionsFilter(cb, filenameRoot);\n\t    }\n\t    else if (action.matches(\"(?i)(FeatureDistancePresort)|(fdp)\")) {\n\t\tapplyFeatureDistancePresort(cb, filenameRoot);\n\t    }\n\t    else if (action.matches(\"(?i)(SequentialBackwardGeneration)|(sbg)\")) {\n\t\tapplySequentialBackwardGeneration(cb, filenameRoot);\n\t    }\n\t    else if (action.matches(\"(?i)(ZeroWeightFilter)|(zwf)\")) {\n\t\tapplyZeroWeightFilter(cb, filenameRoot);\n\t    }\n\t    else if (action.matches(\"(?i)(RoughSetFeatureSelection)|(rsfs)\")) {\n\t\tapplyRoughSetFeatureSelection(cb, filenameRoot);\n\t    }\n\t}\n    }\n",
    "4573": "    protected void init(){\n\t//the message is (init teamname (version 8))\n        send(\"(init \" + this.m_teamname + \" (version 8))\");\n    }\n",
    "4574": "    private void execute() throws HibernateException {\n\n        log.trace(\"executing flush\");\n\n        try {\n            // we need to lock the collection caches before\n            // executing entity inserts/updates in order to\n            // account for bidi associations\n            beforeExecutionsAll(collectionRemovals);\n            beforeExecutionsAll(collectionUpdates);\n            beforeExecutionsAll(collectionCreations);\n\n            // now actually execute SQL and update the\n            // second-level cache\n            executeAll(insertions);\n            executeAll(updates);\n            executeAll(collectionRemovals);\n            executeAll(collectionUpdates);\n            executeAll(collectionCreations);\n            executeAll(deletions);\n        }\n        catch (HibernateException he) {\n            log.error(\"Could not synchronize database state with session\");\n            throw he;\n        }\n    }\n",
    "4575": "    public void Controling(ParsingEvent pe){\n\tif(m_lastInputs.getNumberSensoryItems()>0){\n\t    CaseEvent ce = new CaseEvent(this,m_lastInputs);\n\t    for(CaseEventListener cel:CEListeners) cel.GotInputs(ce);\n\t}\n    }\n",
    "4576": "    public void Sensing(ParsingEvent pe){\n\tif(m_teamName.equals(\"\")){\n\t    CaseEvent ce = new CaseEvent(this);\n\t    for(CaseEventListener cel:CEListeners) cel.TeamNameMissing(ce);\n\t}\n    }\n",
    "4577": "    private void send(String message){\n\tbyte[] buffer = new byte[RCSImitate.MSG_SIZE];\n\tbuffer = message.getBytes();\n\n\tDatagramPacket packet \n\t    = new DatagramPacket(buffer, buffer.length, this.m_serverhost, this.m_serverport);\n\n\ttry{\n\t    this.m_socket.send(packet);\n\t}catch(IOException e){\n\t    System.err.println(\"Socket sending error : \" + e);\n\t}\n    }\n",
    "4578": "    private void applyNoActionsFilter(CaseBase cb, StringBuilder filenameRoot) {\n\tSystem.out.println(\"[\" + getTime() + \"]: Applying No Actions Filter ...\");\n\tNoActionsFilter naf = new NoActionsFilter();\n\tcb.setCaseList(naf.filter(cb).getCaseList());\n\t\n\tfilenameRoot.append(\"-naf\");\n\t\n\tif (saveArtifacts) {\n\t    // Save the new case base\n\t    System.out.println(\"[\" + getTime() + \"]: Saving CaseBase to \" + filenameRoot.toString() + \".cb\");\n\t    try {\n\t\tCaseBaseIO.saveCaseBase(cb, filenameRoot.toString() + \".cb\");\n\t    }\n\t    catch (IOException ioe) {\n\t\tSystem.err.println(\"[\" + getTime() + \"]: Saving CaseBase after applying NoActionsFilter failed.\");\n\t    }\n\t}\n    }\n",
    "4579": "    private void setObjectPosition(RoboCupSimulation2DSpatialObject so,\n\t\t\t    ParsingEvent pe){//this sets the parameters that are common to all field objects\n\tif(pe.contains(\"dir_change\")) so.setDirectionChange(Float.parseFloat(pe.get(\"dir_change\")));\n\tif(pe.contains(\"dist_change\")) so.setDistanceChange(Float.parseFloat(pe.get(\"dist_change\")));\n\tif(pe.contains(\"direction\")) so.setDirection(Float.parseFloat(pe.get(\"direction\")));\n\tif(pe.contains(\"distance\")) so.setDistance(Float.parseFloat(pe.get(\"distance\")));\n    }\n",
    "4580": "    public void SeeReceived(ParsingEvent pe){\n\tif(m_lastInputs.getNumberSensoryItems()>0){\n\t    CaseEvent ce = new CaseEvent(this,m_actionList);\n\t    for(CaseEventListener cel:CEListeners) cel.GotActions(ce);\n\t}\n\tm_lastInputs = new AgentInputs();\n\tm_actionList = new ArrayList<AgentAction>();\n    }\n",
    "4581": "    private String receive() {\n\tbyte[] buffer = new byte[RCSImitate.MSG_SIZE];\n\tDatagramPacket packet = new DatagramPacket(buffer, RCSImitate.MSG_SIZE);\n\ttry{\n\t    this.m_socket.receive(packet);\n\t}catch(IOException e){\n\t    System.err.println(\"Socket receiving error : \" + e);\n\t}\n\treturn new String(buffer);\n    }\n",
    "4586": "    public void SeeParsed(ParsingEvent pe){\n\t    CaseEvent ce = new CaseEvent(this,m_lastInputs);\n\t    for(CaseEventListener cel:CEListeners) cel.GotInputs(ce);\n    }\n",
    "4588": "    public void Goal(ParsingEvent pe){\n\tGoalFeature gf = new GoalFeature();\n\tif(pe.contains(\"name\"))\n\t    gf.setSide(pe.get(\"name\"));\n\tsetObjectPosition(gf,pe);\n\tm_lastInputs.addSensoryItem(gf);\n    }\n",
    "4589": "    private void applyRoughSetFeatureSelection(CaseBase cb, StringBuilder filenameRoot) {\n\t\tSystem.out.println(\"[\" + getTime() + \"]: Applying RoughSetFeatureSelection\");\n\t\tweights = WeightAdjuster.featureSelect(WeightAdjuster.ROUGH_SET_FEATURE_SELECTION, cb);\n\t\t\n\t\tfilenameRoot.append(\"-rsfs\");\n\t\t\n\t\tif (saveArtifacts) {\n\t\t\t// Save generated Weights object\n\t\t\tSystem.out.println(\"[\" + getTime() + \"]: Saving generated Weights object to \" + filenameRoot.toString() + \".weights\");\n\t\t\ttry {\n\t\t\t\tWeightsIO.saveWeights(weights, filenameRoot.toString() + \".weights\");\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException iae) {\n\t\t\t\tSystem.err.println(\"[\" + getTime() + \"]: Saving generated Weights failed.\");\n\t\t\t}\n\t\t}\n\t}\n",
    "4592": "    public void Ball(ParsingEvent pe){\n\tBallFeature bf = new BallFeature();\n\tsetObjectPosition(bf,pe);\n\tm_lastInputs.addSensoryItem(bf);\n    }\n",
    "4593": "    private void applySequentialBackwardGeneration(CaseBase cb, StringBuilder filenameRoot) {\n\t\tSystem.out.println(\"[\" + getTime() + \"]: Applying SequentialBackwardGeneration\");\n\t\tweights = WeightAdjuster.featureSelect(WeightAdjuster.SEQUENTIAL_BACKWARD_GENERATION, cb);\n\t\t\n\t\tfilenameRoot.append(\"-sbg\");\n\t\t\n\t\tif (saveArtifacts) {\n\t\t\t// Save generated Weights object\n\t\t\tSystem.out.println(\"[\" + getTime() + \"]: Saving generated Weights object to \" + filenameRoot.toString() + \".weights\");\n\t\t\ttry {\n\t\t\t\tWeightsIO.saveWeights(weights, filenameRoot.toString() + \".weights\");\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException iae) {\n\t\t\t\tSystem.err.println(\"[\" + getTime() + \"]: Saving generated Weights failed.\");\n\t\t\t}\n\t\t}\n\t}\n",
    "4596": "    public void Flag(ParsingEvent pe){\n\tFlagFeature flag = new FlagFeature();\n\tString name=pe.get(\"name\");\n\tif(pe.contains(\"Box\")) flag.setBox(pe.get(\"Box\"));\n\tif(pe.contains(\"hp\")) \n\t    flag.setHorizontalPosition(pe.get(\"hp\"));\n\tif(pe.contains(\"vp\")) \n\t    flag.setVerticalPosition(pe.get(\"vp\"));\n\tif(pe.contains(\"flag_number\")){\n\t    flag.setFlagNumber(Integer.parseInt(pe.get(\"flag_number\")));\n\t    flag.setOutOfBounds(true);\n\t} else\n\t    flag.setOutOfBounds(false);\n\tsetObjectPosition(flag,pe);\n\tm_lastInputs.addSensoryItem(flag);\n    }\n",
    "4599": "\tprivate void applyZeroWeightFilter(CaseBase cb, StringBuilder filenameRoot) {\n\t\tSystem.out.println(\"[\" + getTime() + \"]: Applying Zero Weight Filter\");\n\t\tZeroWeightFilter zwf = new ZeroWeightFilter(weights);\n\t\tcb.setCaseList(zwf.filter(cb).getCaseList());\n\t\t\n\t\tfilenameRoot.append(\"-zwf\");\n\t\t\n\t\tif (saveArtifacts) {\n\t\t\t// Save the new case base\n\t\t\tSystem.out.println(\"[\" + getTime() + \"]: Saving CaseBase to \" + filenameRoot.toString() + \".cb\");\n\t\t\ttry {\n\t\t\t\tCaseBaseIO.saveCaseBase(cb, filenameRoot.toString() + \".cb\");\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tSystem.err.println(\"[\" + getTime() + \"]: Saving CaseBase after applying ZeroWeightFilter failed.\");\n\t\t\t}\n\t\t}\n\t}\n",
    "4600": "    public void Line(ParsingEvent pe){\n\tLineFeature lf = new LineFeature();\n\tif(pe.contains(\"name\")) lf.setLocation(pe.get(\"name\"));\n\tsetObjectPosition(lf,pe);\n\tm_lastInputs.addSensoryItem(lf);\n    }\n",
    "4601": "    public void TimeOver(CaseEvent ce){\n\tthis.m_timeOver = true;\n\tthis.m_brain.setTimeOver(true);\n    }\n",
    "4604": "    public void Catch(ParsingEvent pe){\n\tCatchAction catchAct = new CatchAction();\n\tif(m_actionList.size()<1)\n\t    m_actionList.add(catchAct);\n    }\n",
    "4605": "    private void setGlobalValues(Weights w) {\n        GlobalDistanceMeasure gd = new OrderIndexMatchingAlgorithm(w);\n\t\tCase.setGlobalDistanceCalculation(gd);\n\t\t\n\t\tSensoryItem.setDistanceCalculation(new EqualityDistanceAlgorithm());\n\t\tSensoryItem.setPenaltyDistanceCalculation(new ConstantPenalty(100));\n\t\tSpatial2DObject.setDistanceCalculation(new PolarDistanceAlgorithm());\n    }\n",
    "4609": "    public void Dash(ParsingEvent pe){\n\tfloat power =Float.parseFloat(pe.get(\"power\"));\n\tDashAction dash = new DashAction(power);\n\tif(m_actionList.size()<1)\n\t    m_actionList.add(dash);\n    }\n",
    "4615": "    public void Kick(ParsingEvent pe){\n\tfloat power =Float.parseFloat(pe.get(\"power\"));\n\tfloat angle =Float.parseFloat(pe.get(\"direction\"));\n\tKickAction kick = new KickAction(power,angle);\n\tif(m_actionList.size()<1)\n\t    m_actionList.add(kick);\n    }\n",
    "4616": "    public void Catch(ParsingEvent pe){\n\tCatchAction catchAct = new CatchAction();\n\tm_actionList.add(catchAct);\n    }\n",
    "4620": "    public void Turn(ParsingEvent pe){\n\tfloat angle =Float.parseFloat(pe.get(\"direction\"));\n\tTurnAction turn = new TurnAction(angle);\n\tif(m_actionList.size()<1)\n\t    m_actionList.add(turn);\n    }\n",
    "4621": "    public void Dash(ParsingEvent pe){\n\tfloat power =Float.parseFloat(pe.get(\"power\"));\n\tDashAction dash = new DashAction(power);\n\tm_actionList.add(dash);\n    }\n",
    "4623": "    private void showResults() {\n        System.out.println(\"[\" + getTime() + \"]: Results:\\n\");\n        \n        System.out.println(getReportString());\n        \n        // Space out the output\n        System.out.println();\n    }\n",
    "4625": "    public void Kick(ParsingEvent pe){\n\tfloat power =Float.parseFloat(pe.get(\"power\"));\n\tfloat angle =Float.parseFloat(pe.get(\"direction\"));\n\tKickAction kick = new KickAction(power,angle);\n\tm_actionList.add(kick);\n    }\n",
    "4626": "    public void TurnNeck(ParsingEvent pe){\n\tfloat angle =Float.parseFloat(pe.get(\"neck_angle\"));\n\tTurnNeckAction turnNeck = new TurnNeckAction(angle);\n\t//m_actionList.add(turnNeck);\n    }\n",
    "4628": "    public void Turn(ParsingEvent pe){\n\tfloat angle =Float.parseFloat(pe.get(\"direction\"));\n\tTurnAction turn = new TurnAction(angle);\n\tm_actionList.add(turn);\n    }\n",
    "4629": "    public void Hear(ParsingEvent pe){\n\tString who=pe.get(\"who\");\n\tString what=pe.get(\"what\");\n\tif(who.equals(\"referee\") && what.equals(\"time_over\")){\n\t    CaseEvent ce = new CaseEvent(this);\n\t    for(CaseEventListener cel:CEListeners) cel.TimeOver(ce);\n\t}\t    \n    }\n",
    "4772": "\tpublic Case getCase(){\n\t\treturn this.m_case;\n\t}\n",
    "4773": "\tpublic AgentAction getAction(){\n\t\treturn this.m_action;\n\t}\n",
    "4776": "\tpublic AgentAction senseEnvironment(Case c) {\n\t\t//check the parameters\n\t\tif(c == null){\n\t\t\tthrow new IllegalArgumentException(\"Null Case given to senseEnvironment\");\n\t\t}\n\t\tAgentInputs av = c.getInputs();\n\t\t\n\t\tlong startTime = System.currentTimeMillis();\n\t\tAgentAction action = this.m_agent.senseEnvironment(av);\n\t\tlong endTime = System.currentTimeMillis();\n\t\t\n\t\tthis.m_totalTime += endTime - startTime;\n\t\tthis.m_numInputs ++;\n\t\t\n\t\treturn action;\n\t}\n",
    "4778": "\tpublic float getMeanExecutionTime(){\n\t\t//make sure we don't divide by zero\n\t\tif(this.m_numInputs == 0){\n\t\t\treturn 0.0f;\n\t\t}\n\t\treturn ((float)this.m_totalTime)/this.m_numInputs;\n\t}\n",
    "4785": "         public AgentAction copyThis(){\n\t     AgentAction newAgent = null;\n\t     \n\t     Class<? extends AgentAction> clazz = this.getClass();\n\t     \n\t     Constructor<? extends AgentAction> constructor;\n\t     \n\t     try {\n\t\t constructor = clazz.getConstructor(clazz);\n\t\t newAgent = constructor.newInstance(this);\n\t     }\n\t     catch (Exception e) {\n\t\t e.printStackTrace();\n\t\t System.exit(1);\n\t     }\n\t     \n\t     return newAgent;\n\t }\n",
    "4787": "\tpublic String getActionName(){\n\t\treturn this.m_name;\n\t}\n",
    "4788": "    public int getCasebaseSize(){\n    \treturn this.m_casebase.size();\n    }\n",
    "4789": "         public String toString(){\n\t     String result=super.toString()+\":\";\n\t     result+=Float.toString(this.m_distance)+\":\";\n\t     result+=Float.toString(this.m_direction);\n\t     return result;\n\t }\n",
    "4790": "        public String getAttrib(String attrib){\n\t    return \"\";\n\t}\n",
    "4793": "    public void addCase(Case ca){\n    \tif(ca == null){\n    \t\tthrow new IllegalArgumentException(\"Null Case added to CaseBase.\");\n    \t}\n\t\t\n    \tthis.m_casebase.add(ca);\n    }\n",
    "4794": "         public Spatial2DObject copyOfThis(){\n\t     Spatial2DObject copy=new Spatial2DObject(this.getFeatureName());\n\t     copy.setDistance(this.m_distance);\n\t     copy.setDirection(this.m_direction);\n\t     return copy;\n\t }\n",
    "4795": "        public String toString(){\n        \treturn m_name;\t\n        }\n",
    "4796": "    public void setCaseList(List<Case> cbList){\n    \t//check params\n    \tif(cbList == null){\n    \t\tthrow new IllegalArgumentException(\"Null paramater given to CaseBase constructor\");\n    \t}\n\t\t\n    \tthis.m_casebase = new ArrayList<Case>(cbList);\n    }\n",
    "4798": "\tpublic void setDistance(float dist){\n\t\tthis.m_distance = dist;\n\t}\n",
    "4800": "\tpublic void setValue(float value){\n\t\tthis.m_value = value;\n\t}\n",
    "4802": "\tpublic void setDirection(float dir){\n\t\tthis.m_direction = dir;\n\t}\n",
    "4803": "\tpublic float getValue(){\n\t\treturn this.m_value;\n\t}\n",
    "4806": "\tpublic AgentAction selectAction(List<Case> nearestNeighbours) {\n\t\t//check parameters\n\t\tif(nearestNeighbours == null){\n\t\t\tthrow new IllegalArgumentException(\"Null value given to ClosestNeighbourSelection\");\n\t\t}\n\t\tif(nearestNeighbours.size() == 0){\n\t\t\tthrow new IllegalArgumentException(\"ClosestNeighbourSelection requires at least 1 Case to be given.\");\n\t\t}\n\t\t\n\t\t//get the first Case and its actions\n\t\tCase firstCase = nearestNeighbours.get(0);\n\t\tList<AgentAction> actions = firstCase.getActions();\n\t\t\n\t\treturn this.m_actionEst.estimateAction(actions);\n\t}\n",
    "4807": "\tpublic AgentAction estimateAction(List<AgentAction> possibilities) {\n\t\t//check parameters\n\t\tif(possibilities == null){\n\t\t\tthrow new IllegalArgumentException(\"Null list given to LastActionEstimate.\");\n\t\t}\n\t\t\n\t\t//if there are no associated actions, return null\n\t\tif(possibilities.size() == 0){\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//return the last item\n\t\treturn possibilities.get(possibilities.size() -1);\n\t}\n",
    "4808": "\tpublic float getDistance(){\n\t\treturn this.m_distance;\n\t}\n",
    "4811": "\tpublic float calculatePenalty(SensoryItem feat) {\n\t\t//sanity check, even though we don't use it, we still don't want null\n\t\tif(feat == null){\n\t\t\tthrow new IllegalArgumentException(\"Null feature given to penalty function.\");\n\t\t}\n\t\t\n\t\treturn this.m_penalty;\n\t}\n",
    "4813": "\tpublic void setFilters(CaseFilter[] filters){\n\t\tfor(int ii=0;ii<filters.length;ii++){\n\t\t\tif(filters[ii] == null){\n\t\t\t\tthrow new IllegalArgumentException(\"Null CaseFilter given to agent.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.m_filters = filters;\n\t}\n",
    "4814": "\tpublic float getDirection(){\n\t\treturn this.m_direction;\n\t}\n",
    "4816": "\tpublic void setWeights(Weights newWeights){\n\t\tif(newWeights == null){\n\t\t\tthrow new IllegalArgumentException(\"Null weights given to GlobalDistanceMeasure\");\n\t\t}\n\t\tthis.m_featureWeights = newWeights;\n\t}\n",
    "4817": "\tpublic void setCaseBase(CaseBase cb){\n\t\tif(cb == null){\n\t\t\tthrow new IllegalArgumentException(\"Null CaseBase given to Agent.\");\n\t\t}\n\t\tif(cb.getCasebaseSize() == 0){\n\t\t\tthrow new IllegalArgumentException(\"Empty CaseBase given to Agent. At least one Case must be in CaseBase.\");\n\t\t}\n\t\t\n\t\tthis.m_caseBase = cb;\n\t\t\n\t}\n",
    "4819": "\tpublic Weights getWeights(){\n\t\treturn this.m_featureWeights;\n\t}\n",
    "4821": "\tprotected float weightedDistance(Map<String, Float> distances) {\n\t\tfloat totalDistance = 0.0f;\n\t\t\n\t\t//get a list of object types we have and go through each type\n\t\tList<String> objectTypes = new ArrayList<String>(distances.keySet());\n\t\tfor(String currentType : objectTypes){\n\t\t\tfloat rawDistance = distances.get(currentType);\n\t\t\t\t\n\t\t\t//apply the weight\n\t\t\tfloat currentWeight = this.m_featureWeights.getWeight(currentType);\n\t\t\ttotalDistance += rawDistance*currentWeight;\n\t\t}\n\t\t\n\t\treturn totalDistance;\n\t}\n",
    "4822": "\tpublic void setWeight(String itemName, float weight){\n\t\t//check parameters\n\t\tif(itemName == null){\n\t\t\tthrow new IllegalArgumentException(\"Null parameter given to Weights object.\");\n\t\t}\n\t\tif(weight < 0.0f || weight > 1.0f){\n\t\t\tthrow new IllegalArgumentException(\"The weights must be between 0.0 and 1.0 (inclusive)\");\n\t\t}\n\t\t\n\t\t//set the weight value\n\t\tthis.m_weights.put(itemName, new Float(weight));\n\t}\n",
    "4824": "\tpublic float getWeight(String itemName){\n\t\t//check parameters\n\t\tif(itemName == null){\n\t\t\tthrow new IllegalArgumentException(\"Null parameter given to Weights object.\");\n\t\t}\n\t\t\n\t\t//get the associated weight\n\t\tFloat weight = this.m_weights.get(itemName);\n\t\t\n\t\t//see if the weight has actually been set, otherwise use default\n\t\tif(weight == null){\n\t\t\treturn this.m_defaultWeight;\n\t\t}\n\t\treturn weight.floatValue();\n\t}\n",
    "4825": "    public void setSensoryItems(Hashtable<String,List<SensoryItem>> items){\n    \tthis.m_featuregroupTable=new Hashtable<String,List<SensoryItem>>(items);\n    }\n",
    "4826": "    public void setActions(List<AgentAction> actions){\n    \tthis.m_actions= new ArrayList<AgentAction>(actions);\n    }\n",
    "4831": "    public AgentInputs getInputs(){\n    \treturn this.m_inputs;\n    }\n",
    "4832": "\tpublic void setSampleSize(int sampleSize){\n\t\tif(sampleSize <= 0){\n\t\t\tthrow new IllegalArgumentException(\"Invalid sample size given to RandomUnderSample.setSampleSize(int)\");\n\t\t}\n\t\tthis.m_maxNum = sampleSize;\n\t}\n",
    "4834": "\tpublic int getSampleSize(){\n\t\treturn this.m_maxNum;\n\t}\n",
    "4836": "    public void setInputs(AgentInputs inputs){\n    \tthis.m_inputs=inputs;\n    }\n",
    "4837": "    public boolean doesContain(String featureName){\n    \t//check parameters\n    \tif(featureName == null){\n    \t\tthrow new IllegalArgumentException(\"SensoryItem name was null.\");\n    \t}\n\t\t\n    \t//get the list of that type of feature\n    \tList<SensoryItem> l = this.m_featuregroupTable.get(featureName);\n\t\t\n    \t//if there is no entry in the feature table the HashMap will\n    \t//have returned null\n    \tif(l == null || l.size() == 0){\n    \t\treturn false;\n    \t}\n    \treturn true;\n    }\n",
    "4842": "    public int getNumberSensoryItems(String featureName){\n    \t//check parameters\n    \tif(featureName == null){\n    \t\tthrow new IllegalArgumentException(\"SensoryItem name was null.\");\n    \t}\n\t\t\n    \t//get the list for that feature\n    \tList<SensoryItem> sensoryItemList = this.m_featuregroupTable.get(featureName);\n    \t//if null then no features of that type exist\n    \tif(sensoryItemList == null){\n    \t\treturn 0;\n    \t}\n\t\treturn sensoryItemList.size();\n    }\n",
    "4844": "    public String toString(){\n    \tString output = \"Case : \";\n    \toutput += \"\\n\\tInputs : \";\n    \toutput += \"\\n\\t\\t\" + m_inputs.toString(m_inputs.getSensoryItemNames()); \n    \toutput += \"\\n\\tActions : \"; \n    \tfor(AgentAction a : m_actions){\n    \t\toutput += \"\\n\\t\\t\" + a.toString();\n    \t}  \t\n    \treturn output;\n    }\n",
    "4847": "    public int getNumberSensoryItems(){\n    \t//get the feature list for each type of feature\n    \tCollection<List<SensoryItem>> lists = this.m_featuregroupTable.values();\n\t\t\n    \tint featureCounter = 0;\n\t\t\n    \tfor(List<SensoryItem> currentList : lists){\n    \t\t//ignore null lists, these occur when we remove a feature list\n    \t\tif(currentList != null){\n    \t\t\tfeatureCounter += currentList.size();\n    \t\t}\n    \t}\n\t\t\n    \treturn featureCounter;\n    }\n",
    "4850": "\tprivate void resetLists(){\n\t\tthis.m_best = null;\n\t\tthis.m_evalBest = -1;\n\t\tthis.m_statsBest = null;\n\t\tthis.m_closed = new ArrayList<Weights>();\n\t\tthis.m_open = new ArrayList<Weights>();\n\t\tthis.m_evalOpen = new ArrayList<Float>();\n\t\tthis.m_statsOpen = new ArrayList<StatisticsBundle>();\n\t}\n",
    "4851": "    public void addMember(Case c) {\n\tif(c == null){\n\t    throw new IllegalArgumentException(\"Null Case given to Cluster.addMember(Case c)\");\n\t}\n\tthis.m_members.add(c);\n    }\n",
    "4853": "    public void removeSensoryItemType(String featureName){\n    \t//check parameters\n    \tif(featureName == null){\n    \t\tthrow new IllegalArgumentException(\"SensoryItem name was null.\");\n    \t}\n\t\t\n    \t//get the list for the specified feature\n    \tList<SensoryItem> sensoryItemList = this.m_featuregroupTable.get(featureName);\n\t\t\n    \t//if it is null then the feature doesn't exist in the AgentVision\n    \tif(sensoryItemList != null){\n    \t\t//clear the list\n    \t\tsensoryItemList.clear();\n    \t\t//change the table entry to null  (meaning empty)\n    \t\tthis.m_featuregroupTable.remove(featureName);\n    \t}\n    }\n",
    "4855": "\tpublic String getID(){\n\t\treturn this.m_id;\n\t}\n",
    "4856": "\tprivate double calculateError(List<List<VectorPoint>> clusters, VectorPoint[] newCentroids) {\n\t\tdouble total = 0;\n\t\t\n\t\t//go through each cluster\n\t\tfor(int ii=0; ii<clusters.size(); ii++){\n\t\t\tList<VectorPoint> nextCluster = clusters.get(ii);\n\t\t\tVectorPoint centroid = newCentroids[ii];\n\t\t\t//go through each cluster member\n\t\t\tfor(int jj=0; jj<nextCluster.size(); jj++){\n\t\t\t\tVectorPoint item = nextCluster.get(jj);\n\t\t\t\ttotal += item.euclideanDistance(centroid);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn total;\n\t}\n",
    "4857": "\tpublic CaseBase filter(CaseBase initialCB) {\n\t\t//check parameters\n\t\tif(initialCB == null){\n\t\t\tthrow new IllegalArgumentException(\"Null CaseBase given to NoActionsFilter.\");\n\t\t}\n\t\t\n\t\tCaseBase newCB = new CaseBase();\n\t\t\n\t\t//go through each Case in the initial CaseBase\n\t\tList<Case> allCases = initialCB.getCaseList();\n\t\tfor(Case currentCase : allCases){\n\t\t\t//only add ones that have AgentActions\n\t\t\tif(currentCase.getActions().size() != 0){\n\t\t\t\tnewCB.addCase(currentCase);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn newCB;\n\t}\n",
    "4860": "\tpublic CaseBase filter(CaseBase initialCB) {\n\t\t//check parameters\n\t\tif(initialCB == null){\n\t\t\tthrow new IllegalArgumentException(\"Null case base given to FeatureDistancePresort.\");\n\t\t}\n\t\t\n\t\t//Create the Case filter\n\t\tFeatureDistanceCasePresort fdcp = new FeatureDistanceCasePresort();\n\t\t\n\t\t//create the new CaseBase\n\t\tCaseBase sorted = new CaseBase();\n\t\t\n\t\t//go through each Case in the CaseBase\n\t\tList<Case> allCases = initialCB.getCaseList();\n\t\tfor(Case currentCase : allCases){\n\t\t\tCase filteredCase = fdcp.filter(currentCase);\n\t\t\tsorted.addCase(filteredCase);\n\t\t}\n\t\t\n\t\treturn sorted;\n\t}\n",
    "4861": "        public void add(AgentAction decClass){\n            elements+=1;\n            if(!Dclass.equals(decClass)){\n                consistent = false;\n            }\n        }\n",
    "4864": "\tpublic double euclideanDistance(VectorPoint otherPoint){\n\t\t//test the params\n\t\tif(otherPoint == null){\n\t\t\tthrow new IllegalArgumentException(\"Null point given.\");\n\t\t}\n\t\tfloat[] otherData = otherPoint.getPoint();\n\t\tif(otherData.length != this.m_point.length){\n\t\t\tthrow new IllegalArgumentException(\"Euclidean distance cannot be calculated because vectors are of different lengths.\");\n\t\t}\n\t\t\n\t\tdouble distance = 0;\n\t\tfor(int ii=0; ii<this.m_point.length; ii++){\n\t\t\tdistance += (this.m_point[ii] - otherData[ii])*(this.m_point[ii] - otherData[ii]);\n\t\t}\n\t\t\n\t\tdistance = Math.sqrt(distance);\n\t\treturn distance;\n\t}\n",
    "4865": "\tprivate void sortByDistance(List<SensoryItem> sensoryItemList){\n\t\t\n\t\t//define a comparator for sorting a List of Features by distance\n\t\tComparator<SensoryItem> comp = new Comparator<SensoryItem>(){\n\t\t\t public int compare(SensoryItem f1, SensoryItem f2){\n\t\t\t\t \n\t\t\t\t Spatial2DObject sf1 = (Spatial2DObject)f1;\n\t\t\t\t Spatial2DObject sf2 = (Spatial2DObject)f2;\n\t\t\t\t \n\t\t\t\t float dist1 = sf1.getDistance();\n\t\t\t\t float dist2 = sf2.getDistance();\n\t\t\t\t \n\t\t\t\t if (dist1 == dist2){\n\t\t\t\t\t return 0;\n\t\t\t\t }else if(dist1 > dist2){\n\t\t\t\t\t return 1;\n\t\t\t\t }else{\n\t\t\t\t\t return -1;\n\t\t\t\t }\n\t\t\t }\n\t\t};\n\t\t\n\t\t//sort the List based on our comparator we defined\n\t\tCollections.sort(sensoryItemList, comp);\n\t}\n",
    "4868": "        public int getCount(){\n            if(consistent == true)\n                return elements;\n            return 0;\n        }\n",
    "4871": "\tprivate CaseBaseProtocol saveCaseProtocolBufferHelpper(CaseBase casebase){\n\t\tCaseBaseProtocol.Builder builder = CaseBaseProtocol.newBuilder();\n\n\t\tfor(Case c : casebase.getCaseList()){\n\t\t\tbuilder.addMCasebase(saveCaseHelper(c));\n\t\t}\n\n\t\treturn builder.build();\n\t}\n",
    "4872": "\tprivate CaseProtocol saveCaseHelper(Case cases){\n\t\tCaseProtocol.Builder caseBuilder = CaseProtocol.newBuilder();\n\n\t\tcaseBuilder.setMInputs(saveAgentInputsHelper(cases.getInputs()));\n\t\tfor(AgentAction a : cases.getActions()){\n\t\t\tcaseBuilder.addMActions(saveAgentActionHelper(a));\n\t\t}\n\t\treturn caseBuilder.build();\n\t}\n",
    "4873": "        public AgentAction getDclass(){\n            if(consistent == true)\n                return Dclass;\n            return null;\n        }\n",
    "4875": "\tprivate AgentInputsProtocol saveAgentInputsHelper(AgentInputs i){\n\t\tAgentInputsProtocol.Builder inputsBuilder = AgentInputsProtocol.newBuilder();\n\n\t\tfor(String s : i.getSensoryItemNames()){\n\t\t\tAgentInputsProtocol.FeatureGroupTable.Builder featureBuilder = AgentInputsProtocol.FeatureGroupTable.newBuilder();\n\t\t\tfeatureBuilder.setFeature(s);\n\t\t\tfor(SensoryItem si : i.getSensoryItems(s)){\n\t\t\t\tfeatureBuilder.addItem(saveSensoryItemHelper(si));\n\t\t\t}\n\t\t\tinputsBuilder.addMFeaturegroupTable(featureBuilder.build());\n\t\t}\n\t\treturn inputsBuilder.build();\n\t}\n",
    "4876": "\tpublic int getMaximum(String item){\n\t\tif(item == null){\n\t\t\tthrow new IllegalArgumentException(\"Null value given to SensoryItemDistribution function.\");\n\t\t}\n\t\t\n\t\tInteger max = m_max.get(item);\n\t\tif(max == null){\n\t\t\treturn 0;\n\t\t}\n\t\treturn max.intValue();\n\t}\n",
    "4877": "\tprivate SensoryItemProtocol saveSensoryItemHelper(SensoryItem s){\n\t\tSensoryItemProtocol.Builder sensoryBuilder = SensoryItemProtocol.newBuilder();\n\t\tsensoryBuilder.setMFeatureName(s.getFeatureName());\n\t\treturn sensoryBuilder.build();\n\t}\n",
    "4879": "\tpublic int getMinimum(String item){\n\t\tif(item == null){\n\t\t\tthrow new IllegalArgumentException(\"Null value given to SensoryItemDistribution function.\");\n\t\t}\n\t\t\n\t\tInteger min = m_min.get(item);\n\t\tif(min == null){\n\t\t\treturn 0;\n\t\t}\n\t\treturn min.intValue();\n\t}\n",
    "4880": "\tprivate AgentActionProtocol saveAgentActionHelper(AgentAction a){\n\t\tAgentActionProtocol.Builder actionBuilder = AgentActionProtocol.newBuilder();\n\n\t\tactionBuilder.setMName(a.getActionName());\n\t\treturn actionBuilder.build();\n\t}\n",
    "4881": "\tpublic float getMean(String item){\n\t\tif(item == null){\n\t\t\tthrow new IllegalArgumentException(\"Null value given to SensoryItemDistribution function.\");\n\t\t}\n\t\t\n\t\tInteger count = m_count.get(item);\n\t\tif(count == null || m_numCases == 0){\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn (float)count/(float)m_numCases;\n\t}\n",
    "4882": "    public AgentInputs getAgentInputs(){\n\treturn aInputs;\n    }\n",
    "4885": "    public String getTeamName(){\n\treturn m_teamName;\n    }\n",
    "4886": "\tpublic String getFeatureName(){\n\t\treturn this.m_featureName;\n\t}\n",
    "4890": "        public SensoryItem copyOfThis(){\n\t    return new SensoryItem(this.getFeatureName());\n\t}\n",
    "4893": "       public String toString(){\n\t   return this.m_featureName;\n       }\n",
    "4894": "\tpublic float pairwiseDistance(SensoryItem f){\n\t\t//check the validity of parameters\n\t\tif(f == null){\n\t\t\tthrow new IllegalArgumentException(\"A null feature was given.\");\n\t\t}\n\t\t\n\t\t//make sure we have a distance calculation algorithm set\n\t\tif(SensoryItem.m_distanceCalculation == null){\n\t\t\tthrow new IllegalStateException(\"The distance calculation algorithm has not yet been set.\");\n\t\t}\n\t\t\n\t\t//if everything is fine, return the pairwise distance\n\t\treturn SensoryItem.m_distanceCalculation.pairwiseDistance(this, f);\n\t}\n",
    "4898": "\tpublic float penaltyDistance(){\n\t\n\t\t//make sure we have a penalty calculation algorithm set\n\t\tif(SensoryItem.m_penaltyCalculation == null){\n\t\t\tthrow new IllegalStateException(\"The penalty calculation algorithm has not yet been set.\");\n\t\t}\n\t\t\n\t\t//if everything is fine, return the pairwise distance\n\t\treturn SensoryItem.m_penaltyCalculation.calculatePenalty(this);\n\t}\n",
    "4899": "\tpublic String toXML(){\n\t\tString xml = \"\";\n\t\t\n\t\txml += \"<SensoryItem>\";\n\t\txml += \"<FeatureName>\";\n\t\txml += this.m_featureName;\n\t\txml += \"</FeatureName>\";\n\t\txml += \"</SensoryItem>\";\n\t\t\n\t\treturn xml;\n\t}\n",
    "5030": "\t@Test\n\tpublic void getClassificationAccuracy_manyTypesPerfect() throws Exception{\t\n\t\tMethod addPair = addPairHack();\n\t\t\n\t\t//simulate the pairings\n\t\taddPair.invoke(this.dummysw, \"oneAction\", \"oneAction\");\n\t\taddPair.invoke(this.dummysw, \"otherAction\", \"otherAction\");\n\t\taddPair.invoke(this.dummysw, \"otherAction\", \"otherAction\");\n\t\taddPair.invoke(this.dummysw, \"thirdAction\", \"thirdAction\");\n\t\taddPair.invoke(this.dummysw, \"thirdAction\", \"thirdAction\");\n\t\t\n\t\tassertEquals(this.dummysw.getClassificationAccuracy(), 1.0f);\n\t}\n",
    "5143": "    private void preFlushEntities() throws HibernateException {\n\n        List list = IdentityMap.concurrentEntries(entityEntries);\n        //safe from concurrent modification because of how entrySet() is implemented on IdentityMap\n        int size = list.size();\n        for ( int i=0; i<size; i++ ) {\n\n            Map.Entry me = (Map.Entry) list.get(i);\n            EntityEntry entry = (EntityEntry) me.getValue();\n            Status status = entry.status;\n\n            if ( status!=LOADING && status!=GONE && status!=DELETED ) {\n                Object object = me.getKey();\n                cascading++;\n                try {\n                    Cascades.cascade(this, entry.persister, object, Cascades.ACTION_SAVE_UPDATE, Cascades.CASCADE_ON_UPDATE);\n                }\n                finally {\n                    cascading--;\n                }\n            }\n        }\n\n    }\n",
    "5203": "\tprivate Method addPairHack() throws Exception{\n\t\t\n\t\tClass<StatisticsWrapper> c = StatisticsWrapper.class;\n\t\tMethod addPair = c.getDeclaredMethod(\"addPair\", new Class[]{String.class, String.class});\n\t\taddPair.setAccessible(true);\n\t\t\n\t\treturn addPair;\n\t}\n",
    "5380": "    public boolean contains(String paramName){\n\treturn line.contains(paramName);\n    }\n",
    "5419": "    private void parseOptions(String message, String params)\n    { //parse an initialization info\n\tparsed.setSensor(message);\n\tparsed.setParam(\"params\",params);\n\tparsed.setCycle(-1);\n\tParsingEvent pe=new ParsingEvent(this,parsed);\n\tfor(ParsingEventListener pel:PEListeners) pel.ServerParams(pe);\n    }\n",
    "5423": "    private void parseError(String message, String params)\n    { //parse an error\n\tparsed.setSensor(message);\n\tparsed.setParam(\"error\",params);\n\tparsed.setCycle(-2);\n\tParsingEvent pe=new ParsingEvent(this,parsed);\n\tfor(ParsingEventListener pel:PEListeners) pel.Error(pe);\n    }\n",
    "5521": "    private void preFlushCollections() throws HibernateException {\n\n        // Initialize dirty flags for arrays + collections with composite elements\n        // and reset reached, doupdate, etc.\n\n        List list = IdentityMap.entries(collectionEntries);\n        int size = list.size();\n        for ( int i=0; i<size; i++ ) {\n            Map.Entry e = (Map.Entry) list.get(i);\n           \t( (CollectionEntry) e.getValue() ).preFlush( (PersistentCollection) e.getKey() );\n        }\n    }\n",
    "5654": "    public void setPageSize(int pageSize){\n        this.pageSize = pageSize;\n        maxPage = rowCount / this.pageSize;\n        if (rowCount % pageSize > 0)\n            maxPage++;\n        currentPage = 0;\n            gotoPage(0);\n    }\n",
    "5658": "    public int getPageSize(){\n        return pageSize;\n    }\n",
    "5660": "    public void gotoPage(int pageNumber){\n        if ((pageNumber < 0)  || (pageNumber > maxPage))\n                throw new IndexOutOfBoundsException(\"Page number incorrect: got \"+pageNumber+ \"min 0, max \"+maxPage);\n        currentPage = pageNumber;\n        index = pageSize * currentPage;\n\n        length = ((rowCount - index) < pageSize) ? (rowCount - index): (pageSize);\n\n        fireTableStructureChanged();\n\n    }\n",
    "5665": "        public void setCheckValues(ArrayList<Map<K, V>> checkValues) {\n             this.checkValues.clear();\n             this.checkValues.addAll(checkValues);\n        }\n",
    "5666": "    public void gotoPrevPage(){\n        gotoPage(currentPage--);\n    }\n",
    "5668": "    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n        if (isSelected){\n            setForeground(table.getSelectionForeground());\n            setBackground(table.getSelectionBackground());\n        }\n        else{\n            setForeground(table.getForeground());\n            setBackground(table.getBackground());\n        }\n        boolean selected = (Boolean)value; //\u043f\u0440\u0438\u0432\u043e\u0434\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043a \u0442\u0438\u043f\u0443 Boolean\n        setSelected(selected); //\u0438\u0437\u043c\u0435\u043d\u044f\u0435\u043c \u0432\u0438\u0434 \u0447\u0435\u043a\u0431\u043e\u043a\u0441\u0430 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e\n        return this;\n    }\n",
    "5669": "    public int getPageCount(){\n        return maxPage;\n    }\n",
    "5672": "    public int getPageNumber(){\n        return currentPage;\n    }\n",
    "5677": "    public void setData(String[][] data, String[] columnNames, int pageSize){\n        this.data = data;\n        this.columnNames = columnNames;\n        this.isEnabled = new boolean[columnNames.length];\n        colCount = data.length;\n        if (colCount > 0)\n            rowCount = data[0].length;\n        setPageSize(pageSize);\n\n    }\n",
    "5679": "    public void warning(SAXParseException e) throws SAXException {\n        String location = \"Warning at [ \"+e.getColumnNumber()+\",\"+e.getLineNumber()+\"]:\";\n        System.out.println(e.getMessage());\n    }\n",
    "5683": "        public int getColumnCount() {\n            return colCount;\n        }\n",
    "5693": "        private void changeFilterState(int columnIndex, boolean  state){\n            if (state) {  // if check is enabled\n                manager.updateData(columnIndex,data[columnIndex]); //update validator\n                for (int i = 0; i < rowCount; i++) //corrects values for cells in columns\n                    data[columnIndex][i] = manager.getValidValue(columnIndex,data[columnIndex][i]);\n                fireTableDataChanged();\n            }\n\n        }\n",
    "5697": "        public Object getValueAt(int rowIndex, int columnIndex) {\n            if (rowIndex == 0)\n                return isEnabled[columnIndex];\n            else {\n                rowIndex+=index;\n                if (isEnabled[columnIndex])\n                    return manager.getValidValue(columnIndex,data[columnIndex][rowIndex-1]);\n                return data[columnIndex][rowIndex-1];\n            }\n\n            }\n",
    "5700": "        public boolean addValidator(int columnIndex, Validator validator){\n            if ((columnIndex >= 0 ) && (columnIndex <= columnNames.length -1)) {\n                manager.addValidator(columnIndex,validator);\n                return true;\n            }\n\n            else return false;\n        }\n",
    "5708": "    public boolean addEditor(String columnName, Editor editor){\n        return addEditor(findColumn(columnName),editor);\n    }\n",
    "5709": "    public void resizeNumberPanel( int maxNumber){\n        int digitCount = 3;\n        while ((maxNumber = maxNumber/10) > 0)\n            digitCount++;\n        this.setMinimumDisplayDigits(digitCount);\n    }\n",
    "5710": "    public Validator getValidator(int columnIndex){\n        return manager.getValidator(columnIndex);\n    }\n",
    "5766": "    private DefaultMutableTreeNode copy(DefaultMutableTreeNode node) {\n        return new DefaultMutableTreeNode(node.getUserObject());\n    }\n",
    "5776": "    private void refreshData(){\n        try {\n            countLines();\n            readData();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        JTableHeader header = owner.getTableHeader();\n        owner.setTableHeader(new JTableHeader());\n        fireTableStructureChanged();\n        fireTableDataChanged();\n        owner.setTableHeader(header);\n\n    }\n",
    "5779": "    private void countLines() throws IOException {\n        fileLineCount = 0;\n        steamReader = new InputStreamReader(new FileInputStream(this.inputFile),this.charset);\n        BufferedReader dataReader = new BufferedReader(steamReader);\n        while ( dataReader.readLine() !=null)\n            fileLineCount++;\n        steamReader.close();\n        dataReader.close();\n    }\n",
    "5782": "     public void setSplitRegexp(String splitRegexp) {\n         this.splitRegexp = splitRegexp;\n         refreshData();\n     }\n",
    "5784": "    public String getSplitRegexp() {\n        return splitRegexp;\n    }\n",
    "5785": "    public int getRowCount() {\n        return map.size();\n    }\n",
    "5786": "    public int getRowCount() {\n        return fileLineCount - startLine;\n    }\n",
    "5787": "    public int getColumnCount() {\n        return 2;\n    }\n",
    "5788": "    public int getColumnCount() {\n         return fileColumnCount;\n    }\n",
    "5789": "    public Object getValueAt(int row, int column) {\n        Object[] entries=map.entrySet().toArray();\n        Map.Entry entry=(Map.Entry)entries[row];\n        if (column==0) {\n            return entry.getKey();\n        } else if (column==1) { // column==1\n            return entry.getValue();\n        } else {\n            throw new IndexOutOfBoundsException(Integer.toString(column));\n        }\n    }\n",
    "5792": "    public String getColumnName(int column) {\n        return columnNames[column];\n    }\n",
    "5794": "    public void setColumnNames(String keyName, String valueName) {\n        columnNames= new String[]{keyName, valueName};\n    }\n",
    "5796": "    public Map getMap() {\n        return map;\n    }\n",
    "5797": "    public char getMinChar() {\n        return minChar;\n    }\n",
    "5798": "    public int getLength() {\n        return length;\n    }\n",
    "5799": "    public void setMap(Map map) {\n        this.map = map;\n    }\n",
    "5805": "    public WizardModel getWizardModel() {\n        return wizard.getModel();\n    }\n",
    "5812": "    public void aboutToDisplayPanel() {\n\n    }\n",
    "5813": "    public void displayingPanel() {\n\n    }\n",
    "5815": "    public void aboutToHidePanel() {\n\n    }    \n",
    "5851": "    public JDialog getDialog() {\n        return wizardDialog;\n    }\n",
    "5859": "    public Component getOwner() {\n        return wizardDialog.getOwner();\n    }\n",
    "5861": "    public void setFormat(SimpleDateFormat format) {\n        this.format = format;\n    }\n",
    "5864": "    public void tableChanged(TableModelEvent e) {\n\n        makeSample();\n    }\n",
    "5865": "    public void setTitle(String s) {\n        wizardDialog.setTitle(s);\n    }\n",
    "5867": "    private void makeSample(){\n        panel.getFileBrowser().setText(\"\");\n        Map<String, String> fieldMap;\n        fieldMap = model.getMap();\n        String[] fields = fieldMap.values().toArray(new String[fieldMap.values().size()]); \n        builder.mapAttributes(columns, fields);\n        builder.makeSample(data[0],sampleWriter);\n        panel.getFileBrowser().setCaretPosition(0);\n    }\n",
    "5871": "    public String getTitle() {\n        return wizardDialog.getTitle();\n    }\n",
    "5875": "    private void  fillArrayLoop(Object[] source, Object[] dest){\n\n        if  (source.length >= dest.length)\n        System.arraycopy(source,0,dest,0,dest.length);\n        else {\n            System.arraycopy(source,0,dest,0,source.length);\n            int length = source.length;\n            int counter = 0;\n            while (length < dest.length) {\n                dest[length] = source[counter];\n                counter++;\n                length++;\n                if (counter == source.length)\n                    counter = 0;\n            }\n        }\n\n\n    }\n",
    "5877": "    public void setModal(boolean b) {\n        wizardDialog.setModal(b);\n    }\n",
    "5881": "    public void showButtons(String fileName){\n        if (FileValidate.canWrite(fileName))  {\n            getWizard().setNextFinishButtonEnabled(true);\n            Core appCore = Core.getInstance();\n            appCore.setOutputFile(new File(fileName));\n            appCore.setOutputWriter(writer);\n\n        }\n\n        else\n            getWizard().setNextFinishButtonEnabled(false);\n    }\n",
    "5884": "    public boolean isModal() {\n        return wizardDialog.isModal();\n    }\n",
    "5890": "    public int showModalDialog() {\n        \n     //   wizardDialog.setModalityType(Dialog.ModalityType.TOOLKIT_MODAL);\n        wizardDialog.pack();\n        wizardDialog.setModal(true);\n        wizardDialog.setVisible(true);\n        return returnCode;\n    }\n",
    "5897": "    public WizardModel getModel() {\n        return wizardModel;\n    }\n",
    "5898": "    public JTextField getFileNameField(){\n        return content.getFileNameField();\n    }\n",
    "5900": "    public JTextArea getFileBrowser(){\n        return content.getContentBrowser();\n    }\n",
    "5901": "    public JTable getContentTable(){\n        return content.getMapTable();\n    }\n",
    "5902": "    public JTextField getFileNameField() {\n        return fileNameField;\n    }\n",
    "5903": "    public XMLWriterGUI getContent(){\n        return content;\n    }\n",
    "5904": "    public JTextArea getContentBrowser() {\n        return contentBrowser;\n    }\n",
    "5907": "    public void registerWizardPanel(Object id, WizardPanelDescriptor panel) {\n        \n        //  Add the incoming panel to our JPanel display that is managed by\n        //  the CardLayout layout manager.\n        \n        cardPanel.add(panel.getPanelComponent(), id);\n        \n        //  Set a callback to the current wizard.\n        \n        panel.setWizard(this);\n        \n        //  Place a reference to it in the model. \n        \n        wizardModel.registerPanel(id, panel);\n        \n    }  \n",
    "5909": "    public void mapAttributes(String[] columnNames, String[] attributes) {\n        indexesMap.clear();\n        for (int i = 0; i < attributes.length; i++ ){\n            String name = this.attributes[i];\n            indexesMap.put(name,findIndex(attributes[i],columnNames));\n        }\n    }\n",
    "5913": "    public void setCurrentPanel(Object id) {\n\n        //  Get the hashtable reference to the panel that should\n        //  be displayed. If the identifier passed in is null, then close\n        //  the dialog.\n        \n        if (id == null)\n            close(ERROR_RETURN_CODE);\n        \n        WizardPanelDescriptor oldPanelDescriptor = wizardModel.getCurrentPanelDescriptor();\n        if (oldPanelDescriptor != null)\n            oldPanelDescriptor.aboutToHidePanel();\n        \n        wizardModel.setCurrentPanel(id);\n        wizardModel.getCurrentPanelDescriptor().aboutToDisplayPanel();\n        \n        //  Show the panel in the dialog.\n        \n        cardLayout.show(cardPanel, (String)id);\n        wizardModel.getCurrentPanelDescriptor().displayingPanel();        \n        \n        \n    }\n",
    "5914": "    public void reset(){\n        users.clear();\n    }\n",
    "5918": "    public void makeSample(String[] fields, Writer out){\n        UserList sampleList = new UserList();\n        List<UserList.User> sample = sampleList.getUser();\n        sample.add(createUser(fields));\n        JAXBElement<UserList> sampleElement = new JAXBElement<UserList>(name,UserList.class,null,sampleList);\n        JAXB.marshal(sampleElement,out);\n\n\n\n\n    }\n",
    "5921": "    public void openFile(String fileName) throws IOException {\n        output = new FileOutputStream(fileName,false);\n\n\n    }\n",
    "5922": "    public void close() throws IOException {\n        output.close();\n    }\n",
    "5923": "    public void writeData(MappingResult result) throws IOException {\n        builder.reset();\n        for (String[] row : result.getData()){\n            builder.addUser(row);\n        }\n            builder.writeData(output);\n    }\n",
    "5926": "    public int getReturnCode() {\n        return returnCode;\n    }\n",
    "5933": "    public boolean getBackButtonEnabled() {\n        return wizardModel.getBackButtonEnabled();\n    }\n",
    "5935": "    public void insertUpdate(DocumentEvent e) {\n        showButtons(fileNameField.getText());\n\n    }\n",
    "5936": "    public void removeUpdate(DocumentEvent e) {\n        showButtons(fileNameField.getText());\n\n    }\n",
    "5939": "    public void setBackButtonEnabled(boolean newValue) {\n        wizardModel.setBackButtonEnabled(newValue);\n    }\n",
    "5945": "    public boolean getNextFinishButtonEnabled() {\n        return wizardModel.getNextFinishButtonEnabled();\n    }\n",
    "5951": "    public void setNextFinishButtonEnabled(boolean newValue) {\n        wizardModel.setNextFinishButtonEnabled(newValue);\n    }\n",
    "5958": "    public boolean getCancelButtonEnabled() {\n        return wizardModel.getCancelButtonEnabled();\n    }\n",
    "5963": "    public void setCancelButtonEnabled(boolean newValue) {\n        wizardModel.setCancelButtonEnabled(newValue);\n    }\n",
    "5972": "    public void initDialog(MappingResult result){\n        String[] columns = result.getColumns();\n        String data[][] = result.getData();\n        Set<String> ouNames = new HashSet<String>();\n            for (String[] row : data){\n              OUNode node = new OUNode(columns,row);\n              String name = node.toString();\n              if (!ouNames.contains(name))  {\n                  root.add(new DefaultMutableTreeNode(node));\n                  ouNames.add(name);\n              }\n            }\n            availableFields.setModel(new DefaultComboBoxModel<String>(columns));\n    }\n",
    "5974": "    public void clearTree(){\n        OUNode rootNode = new OUNode(new String[]{\"ou\"},new String[]{\"Domain Controllers\"});\n        root = new DefaultMutableTreeNode(rootNode);\n    }\n",
    "5975": "    public void openFile(String fileName) throws IOException {\n        writer = new BufferedWriter(new FileWriter(fileName, false));\n    }\n",
    "5978": "    public void close() throws IOException {\n        writer.close();\n    }\n",
    "5980": "    public String generateScript(MappingResult result){\n        UserFactory factory = new UserFactory(\"dc=edo ,dc=chsu, dc=ru\",\n                Arrays.asList(\"cn\",\"sn\",\"userPrincipalName\",\n                        \"userAccountControl\",\"unicodePwd\", \"givenName\"));\n        factory.initFactory(result);\n        StringBuilder script = new StringBuilder();\n        for( String[] row : result.getData()){\n            try {\n\n                script.append(documentBuilder.createAddStatement(factory.createClass(row)));\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return script.toString();\n    }\n",
    "5983": "    public void writeData(MappingResult result) throws IOException {\n       writer.write(generateScript(result));\n    }\n",
    "5984": "    public void initFactory(MappingResult result) {\n        this.columns = result.getColumns();\n        for (int i = 0; i < columns.length; i++){ //searches for dn-attributes\n            int index =Arrays.binarySearch(dnAttributes,columns[i]); \n            if (index > -1)\n                dnIndexes[index] = i; // stores found indexes\n        }\n        \n    }\n",
    "5988": "    private StringBuilder makeAttributeDescription(LDIFClass object){\n        StringBuilder builder = new StringBuilder();\n        for (String key : object.keySet()) {\n            String[] values = object.get(key);\n            for (String value : values){\n                builder.append(key);\n                builder.append(\":\");\n                builder.append(generateSafeString(value));\n                builder.append(SEP);\n            }\n        }\n        return builder;\n    }\n",
    "5989": "    public LDIFClass createClass(String[] data) {\n        LDIFClass result = new LDIFClass();\n        result.setDN(makeDN(data)); //make and store DN\n        result.put(\"objectclass\",\"user\"); //store object class\n\n        for (int i = 0; i < columns.length; i++ )  //for all attributes in row\n            if (attributeNames.contains(columns[i])) // if this attribute is an user attributes\n              result.put(columns[i],data[i]); //store it\n        return result;\n    }\n",
    "5991": "    public StringBuilder createAddStatement(LDIFClass object) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"dn:\");\n        builder.append(generateSafeString(object.getDN()));\n        builder.append(SEP);\n        builder.append(\"changetype:add\");\n\n        builder.append(SEP);\n        builder.append(makeAttributeDescription(object));\n        builder.append(SEP);\n        return builder;\n    }\n",
    "5992": "    public void setSheetName(String sheetName) {\n        this.sheetName = sheetName;\n    }\n",
    "5993": "    public void setSelectedColumns(int[] selectedColumns,String[] columnNames){\n        this.selectedColumns = selectedColumns;\n        this.columnNames = columnNames;\n    }\n",
    "6000": "    public void close() throws IOException {\n        try {\n            workbook.write();\n            workbook.close();\n        } catch (WriteException e) {\n            throw new IOException(e);\n        }\n    }\n",
    "6003": "    private void writeRow(String[] data) throws IOException {\n        int colCounter = 0;\n        for (int index : selectedColumns){// for all indexes of selectedColumns\n            try {       // write values to sheet as text label\n                sheet.addCell(new Label(colCounter,activeRow,data[index]));\n                colCounter++; //increase column number\n            } catch (WriteException e) {\n                throw new IOException(e);\n            }\n        }\n\n    }\n",
    "6005": "    public void writeData(MappingResult result) throws IOException {\n\n        activeRow = 0;\n        int colCounter = 0;\n        String columnNames[] = result.getColumns(); // getting column names\n        for ( int index : selectedColumns)\n            try {  //writing selected column names\n                sheet.addCell(new Label(colCounter,activeRow,columnNames[index]));\n                colCounter++;\n            } catch (WriteException e) {\n                throw new IOException(e.getMessage(),e);\n            }\n        activeRow++;\n        for (String[] row : result.getData()){//for all selected rows of mapping output\n            writeRow(row); //write the row to worksheet\n            activeRow++;\n        }\n\n\n    }\n",
    "6008": "    public XLSWriterGUI getContent(){\n        return content;\n    }\n",
    "6013": "    public Charset getCharset() {\n        return charset;\n    }\n",
    "6015": "     public void setCharset(Charset charset) {\n        this.charset = charset;\n    }\n",
    "6020": "     public int getStartLine() {\n        return startLine;\n    }\n",
    "6022": "    public void setStartLine(int startLine) {\n        if (startLine < 0)   //line number must be non-negative\n            this.startLine = 0;\n        else\n          this.startLine = startLine;\n    }\n",
    "6024": "    public void stateChanged(ChangeEvent e) {\n        refreshFileContent();\n    }\n",
    "6027": "    public void actionPerformed(ActionEvent e) {\n        refreshFileContent();\n    }\n",
    "6029": "    public void setSplitRegexp(String splitRegexp) {\n        this.splitRegexp = splitRegexp;\n    }\n",
    "6032": "    public void setColumns(String[] columns) {\n        this.columns = columns;\n    }\n",
    "6040": "    public void actionPerformed(ActionEvent e) {\n        readerPanel.getContent().updateSeparators();\n    }\n",
    "6043": "    private void gotoStartLine() throws FileNotFoundException, NoSuchElementException {\n        inputScanner = new Scanner(getFile(),charset.name());\n                int lineCount = startLine;\n        while (lineCount-- > 0)\n                inputScanner.nextLine();\n    }\n",
    "6050": "    public FileReaderGUI getReaderGUI() {\n        return readerGUI;\n    }\n",
    "6051": "    public FileSeparator getContent() {\n        return GUI;\n    }\n",
    "6052": "    public JSpinner getImportStringSpinner() {\n        return importStringSpinner;\n    }\n",
    "6053": "   public JTable getFiletable(){\n       return GUI.getFileTable();\n   }\n",
    "6055": "    public Charset getCharset(){\n        return (Charset) charsetComboBox.getSelectedItem();\n    }\n",
    "6057": "    public JTable getFileTable() {\n        return fileTable;\n    }\n",
    "6059": "    public File getFile() {\n        return file;\n    }\n",
    "6060": "    public void setCheckboxesActionListener(ActionListener a){\n        for (Component component : separators.getComponents()) {\n            if (component instanceof JCheckBox)\n            {\n                ((JCheckBox)component).addActionListener(a);\n            }\n        }\n    }\n",
    "6061": "    public void setFile(File file) {\n        this.file = file;\n    }\n",
    "6063": "    public void setPreviewModel(TableModel fileViewModel) {\n        fileTable.setModel(fileViewModel);\n    }\n",
    "6064": "    public void setWorkSheet(int sheetIndex){\n        if (sheetIndex < sheetCount) {\n            this.sheetIndex = sheetIndex;\n            worksheet = workbook.getSheet(sheetIndex);\n        }\n    }\n",
    "6065": "    public int getSheetIndex() {\n        return sheetIndex;\n    }\n",
    "6066": "    public JPanel getContentPane() {\n        return contentPane;\n    }\n",
    "6067": "    public String getSheetName(){\n        return workbook.getSheet(sheetIndex).getName();\n    }\n",
    "6068": "    public void updateSeparators(){\n        String result =\"\";\n        for (Component component : separators.getComponents()) { // determine what checkboxes are checked\n            boolean isSelected = (component instanceof JCheckBox) && ((JCheckBox)component).isSelected();\n            if (isSelected)\n                result += ((JCheckBox)component).getActionCommand(); //add corresponding regexp to result\n        }\n        if (result.length() > 0) //if some regexp is selected\n            result =\"[\"+result+\"]\"; // quote it\n        else\n            result =  \"/.?/\"; // otherwise use default value\n        FileViewModel model = (FileViewModel) fileTable.getModel();\n        model.setSplitRegexp(result);      //update model\n        ColumnPacker.packColumns(fileTable, 3);  //pack table\n    }\n",
    "6070": "    public int getSheetCount(){\n        return sheetCount;\n    }\n",
    "6071": "    public void setSelectedColumns(int[] selectedColumns, String[] columnNames) throws IndexOutOfBoundsException{\n        this.selectedColumns = selectedColumns;\n        int maxColumns = worksheet.getColumns();\n        for (int selectedColumn : selectedColumns) {\n            if ((selectedColumn < 0 ) || (selectedColumn >= maxColumns))\n                throw new IndexOutOfBoundsException(\"\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u0438\u043d\u0434\u0435\u043a\u0441 \u0441\u0442\u043e\u043b\u0431\u0446\u0430 \"+selectedColumn+ \" >= \"+maxColumns);\n        }\n        this.columnNames = columnNames;\n\n    }\n",
    "6076": "    public void setSelectedColumns() throws IndexOutOfBoundsException{\n        int maxColumns = worksheet.getColumns();\n        this.selectedColumns = new int[maxColumns];\n        this.columnNames = new String[selectedColumns.length];\n\n        for (int i = 0; i < selectedColumns.length; i++) {\n            selectedColumns[i] = i;\n            columnNames[i] = worksheet.getCell(i,0).getContents();\n        }\n    }\n",
    "6084": "    public JTable getContentTable() {\n        return contentTable;\n    }\n",
    "6086": "    public JLabel getSheetName() {\n        return sheetName;\n    }\n",
    "6088": "    public JSpinner getSheetSpinner() {\n        return sheetSpinner;\n    }\n",
    "6090": "    public XLSReaderGUI getContent(){\n        return content;\n    }\n",
    "6096": "    public void setSheet(int sheetNumber){\n        if (sheetNumber < sheetCount) { // check if number is valid\n            workSheet = workbook.getSheet(sheetNumber); // change actual worksheet\n            sheetIndex = sheetNumber;\n            fireTableStructureChanged(); // fire table change events\n            fireTableDataChanged();\n        }\n    }\n",
    "6099": "    public String getSheetName(){\n        return workSheet.getName();\n    }\n",
    "6106": "    public File getFile() {\n        return filename;\n    }\n",
    "6107": "    public void stateChanged(ChangeEvent e) {\n        JSpinner source = (JSpinner)e.getSource();\n        xlsModel.setSheet((Integer)source.getValue());  //update sheet\n        panel.getContent().getSheetName().setText(xlsModel.getSheetName()); //update name\n        JTableHeader header = new EditableTableHeader(contentTable.getColumnModel());\n        contentTable.setTableHeader(header); //set up the header\n        ColumnPacker.packColumns(contentTable, 3);\n    }\n",
    "6113": "    public int getRowCount() {\n        return workSheet.getRows()-1;\n    }\n",
    "6114": "    public void actionPerformed(ActionEvent e) {\n        refreshPageCounter();\n    }\n",
    "6115": "    public int getColumnCount() {\n        return workSheet.getColumns();\n    }\n",
    "6118": "    public Object getValueAt(int rowIndex, int columnIndex) {\n        return workSheet.getCell(columnIndex, rowIndex+1).getContents();//not displaying the header row\n    }\n",
    "6122": "    public void stateChanged(ChangeEvent e) {\n           int pageNumber = (Integer)recordSpinner.getValue() - 1; // get selected page number from event\n           model.gotoPage(pageNumber);// change model state\n    }\n",
    "6129": "    private void refreshPageCounter(){\n\n        int pageSize = panel.getContent().getRecordsPerPage();\n        model.setPageSize(pageSize);\n        int pageCount = model.getPageCount();\n        recordSpinner.setModel(new SpinnerNumberModel(1,1,pageCount,1));\n        panel.getContent().getAmount().setText(Integer.toString(pageCount));\n\n\n    }\n",
    "6135": "    private void reshapeData() {\n        String[][] newArray;\n        newArray = new String[linesCount][];\n        for (int i = 0; i < newArray.length; i++){\n            newArray[i] = new String[columns.length];\n            for (int j = 0; j < columns.length; j++)\n                newArray[i][j] = displayData[j][i];\n        }\n        displayData = newArray;\n    }\n",
    "6144": "    public MappingSettings getContent() {\n        return content;\n    }\n",
    "6154": "    private int findMapperIndex(Class mapperClass){\n        ListModel<MapperDecorator> model = pluginsList.getModel();\n        int length = model.getSize();\n        for (int i = 0;i < length; i++ ){\n            AttributeMapper current = model.getElementAt(i).getDelegate();\n            if (current.getClass().equals(mapperClass))\n                return i;\n\n        }\n        return -1;\n    }\n",
    "6158": "    public JLabel getAmount() {\n        return amount;\n    }\n",
    "6159": "    public Integer getRecordsPerPage() {\n        return Integer.parseInt((String)recordsPerPage.getSelectedItem());\n    }\n",
    "6161": "    public JComboBox getRecordsComboBox(){\n        return recordsPerPage;\n    }\n",
    "6163": "    public JSpinner getRecordSpinner() {\n        return recordSpinner;\n    }\n",
    "6165": "    public JTable getResultsTable() {\n        return resultsTable;\n    }\n",
    "6166": "            public void valueChanged(ListSelectionEvent e) {\n                //retrieve dialog window for selected plugin from manager\n                currentDialog = dialogManager.getDialog(pluginsList.getSelectedValue().getDelegate());\n                if (currentDialog==null) { //if dialog window is not found\n                    configPanel.removeAll();\n                    configPanel.add(defaultPanel); //display default panel\n                    configPanel.repaint();\n                }\n                else  {\n                     configPanel.removeAll();   //otherwise display dialog for mapper\n                     configPanel.add(currentDialog.getConfigPanel());\n                     configPanel.repaint();\n                }\n                pack();\n            }\n",
    "6168": "    private void createUIComponents() {\n\n        recordSpinner = new JSpinner();\n        resultsTable = new JTable();\n        resultsTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);\n    }\n",
    "6170": "    public void setAvailableAttributes(Collection<AttributeBean>collection){\n        fieldList.removeAll();\n        DefaultListModel<String> model = (DefaultListModel<String>) fieldList.getModel();\n        for (AttributeBean bean : collection)\n            model.addElement(bean.getName());\n    }\n",
    "6173": "    private void showAddDialog(AttributeBean bean){\n        DefaultListModel<AttributeBean> model =\n                (DefaultListModel<AttributeBean>) availableAttributesList.getModel();\n       List<AttributeBean> list = Collections.list(model.elements());\n       model = (DefaultListModel<AttributeBean>) usedAttributesList.getModel();\n       list.addAll(Collections.list(model.elements()));\n\n         addDialog.setAvailableAttributes(list);\n         addDialog.setData(bean);\n\n         addDialog.pack();\n         addDialog.setVisible(true);\n         addDialog.getData(bean);\n\n    }\n",
    "6176": "    public AttributeMapper createPlugin(Class<? extends AttributeMapper> mapperClass) throws PluginConfigurationException {\n        boolean isFound = pluginsMap.values().contains(mapperClass);\n        if (!isFound)\n            throw new PluginConfigurationException(mapperClass) ;\n        AttributeMapper result;\n        try {\n            result = mapperClass.newInstance();//\u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u043c \u043d\u043e\u0432\u044b\u0439 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\n        } catch (InstantiationException e) {\n            throw new PluginConfigurationException(mapperClass);\n        } catch (IllegalAccessException e) {\n             throw new PluginConfigurationException(mapperClass);\n        }\n        return result;\n    }\n",
    "6181": "    public boolean contains(String value){\n        return value.equals(data) || parent != null && parent.contains(value);\n    }\n",
    "6183": "    private void createUIComponents() {\n        // TODO: place custom component creation code here\n        availableAttributesList = new JList<AttributeBean>();\n        usedAttributesList = new JList<AttributeBean>();\n\n        availableAttributesList.setModel(new DefaultListModel<AttributeBean>());\n        usedAttributesList.setModel(new DefaultListModel<AttributeBean>());\n        addDialog = new AddMapper();\n        addDialog.setModal(true);\n        addDialog.setLocation(this.getX(),this.getY());\n    }\n",
    "6184": "    public void addChild(String value)throws DependencyException {\n        if (!contains(value)){\n            childs.add(new DependencyTree(this,value));\n        } else throw new DependencyException(\"\u0426\u0438\u043a\u043b\u0438\u0447\u0435\u0441\u043a\u0430\u044f \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u044c \u0434\u043b\u044f \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u0430 \"+value);\n\n    }\n",
    "6186": "    public void addChilds(String[] values) throws DependencyException {\n        for (String value : values) {\n            addChild(value);\n        }\n\n    }\n",
    "6191": "    private void isCyclicDependent(String attributeName, ru.chsu.mapper.dependence.DependencyTree parent)throws ru.chsu.mapper.dependence.DependencyException {\n            ru.chsu.mapper.dependence.DependencyTree tree = new ru.chsu.mapper.dependence.DependencyTree(parent,attributeName);\n            AttributeBean attributeBean = config.get(attributeName);\n            AttributeMapper plugin = attributeBean.getMapper();\n            if (plugin != null){\n                String[] dependencies = attributeBean.getMapper().getDependencies();\n                tree.addChilds(dependencies);\n                for (ru.chsu.mapper.dependence.DependencyTree child : tree.getChilds()) {\n                    isCyclicDependent(child.getData(), tree);\n                }\n            }\n    }\n",
    "6196": "    public void checkDependencies(Collection<String> attributes) throws ru.chsu.mapper.dependence.DependencyException {\n        for (String attribute : attributes) {\n            isCyclicDependent(attribute,null);\n        }\n    }\n",
    "6201": "    public void setInputAttributes(Map<String, String> inputAttributes) {\n        this.inputAttributes = inputAttributes;\n    }\n",
    "6212": "    private void configureMappers(String configFileName) throws DependencyException, PluginConfigurationException{\n        ConfigParser parser;\n        try {\n            parser = new ConfigParser(configFileName);\n        } catch (IOException e) {\n            throw new PluginConfigurationException(\"Error: configuration file cannot be read\");\n        } catch (ParserConfigurationException e) {\n            throw new PluginConfigurationException(\"Error: configuration file structure is invalid\");\n        }\n        try {\n            config = parser.loadAttributes();\n        } catch (PluginConfigurationException e) {\n            e.printStackTrace();\n\n        }\n        checkDependencies(config.keySet());\n    }\n",
    "6229": "    public void setMapper(String field, AttributeBean mapperBean){\n        config.put(field, mapperBean);\n    }\n",
    "6540": "    private void convertNonSerializableParams(Object[] params) {\n        // Happens when the method is parameter-less\n        if (params == null) {\n            return;\n        }\n\n        for (int i = 0; i < params.length; i++) {\n            params[i] = Naming.getParameterStubIfNeeded(params[i]);\n        }\n    }\n",
    "6650": "    private void addUninitializedCollection(PersistentCollection collection, CollectionPersister persister, Serializable id) {\n        CollectionEntry ce = new CollectionEntry(persister, id, flushing);\n        collection.setCollectionSnapshot(ce);\n        addCollection(collection, ce, id);\n    }\n",
    "6717": "    private void addUninitializedDetachedCollection(PersistentCollection collection, CollectionPersister persister, Serializable id) {\n        CollectionEntry ce = new CollectionEntry(persister, id);\n        collection.setCollectionSnapshot(ce);\n        addCollection(collection, ce, id);\n    }\n",
    "6852": "    public void addArrayHolder(ArrayHolder holder) {\n        //TODO:refactor + make this method private\n        arrayHolders.put( holder.getArray(), holder );\n    }\n",
    "6868": "\tpublic void dragDropEnd(DragSourceDropEvent e)\t{}\n",
    "7190": "\tpublic void keyReleased(KeyEvent e) {}\n",
    "7463": "    protected void finalize() throws Throwable {\n\n        log.debug(\"running Session.finalize()\");\n\n        if (isCurrentTransaction) log.warn(\"afterTransactionCompletion() was never called\");\n\n        if (connection!=null) { //ie it was never disconnected\n\n            //afterTransactionCompletion(false);\n\n            if ( connection.isClosed() ) {\n                log.warn(\"finalizing unclosed session with closed connection\");\n            }\n            else {\n                log.warn(\"unclosed connection, forgot to call close() on your session?\");\n                if (autoClose) connection.close();\n                //TODO: Should I also call closeStatements() from here?\n            }\n        }\n    }\n",
    "7571": "    private CollectionEntry getCollectionEntryOrNull(Object collection) {\n\n        PersistentCollection coll;\n        if (collection instanceof PersistentCollection) {\n            coll = (PersistentCollection) collection;\n            //if (collection==null) throw new TransientObjectException(\"Collection was not yet persistent\");\n        }\n        else {\n            coll = getArrayHolder(collection);\n            if (coll==null) {\n                //it might be an unwrapped collection reference!\n                //try to find a wrapper (slowish)\n                Iterator wrappers = IdentityMap.keyIterator(collectionEntries);\n                while ( wrappers.hasNext() ) {\n                    PersistentCollection pc = (PersistentCollection) wrappers.next();\n                    if ( pc.isWrapper(collection) ) {\n                        coll=pc;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return (coll==null) ? null : getCollectionEntry(coll);\n\n    }\n",
    "7828": "    public void evict(Object object) throws HibernateException {\n        if (object instanceof HibernateProxy) {\n            LazyInitializer li = HibernateProxyHelper.getLazyInitializer( (HibernateProxy) object );\n            Serializable id = li.getIdentifier();\n            ClassPersister persister = getClassPersister( li.getPersistentClass() );\n            Key key = new Key(id, persister);\n            proxiesByKey.remove(key);\n            if ( !li.isUninitialized() ) {\n                Object entity = removeEntity(key);\n                if (entity!=null) {\n                    EntityEntry e = removeEntry(entity);\n                    doEvict(e.persister, entity);\n                }\n            }\n        }\n        else {\n            EntityEntry e = removeEntry(object);\n            if (e!=null) {\n                removeEntity( new Key(e.id, e.persister) );\n                doEvict(e.persister, object);\n            }\n        }\n    }\n",
    "7938": "    private void evictCachedCollections(ClassPersister persister, Serializable id) throws HibernateException {\n        evictCachedCollections( persister.getPropertyTypes(), id );\n    }\n",
    "12961": "\tpublic void ejbCreate() throws CreateException {\n\t\t// TODO Auto-generated method stub\n\t}\n",
    "29877": "    public void setCodeset(String codeset) {\n        this.codeset = codeset;\n    }\n",
    "29883": "    public String getCodeset() {\n        return codeset;\n    }\n",
    "29887": "    public XMLDocument addStylesheet(String href, String type) {\n        PI pi = new PI();\n        pi.setTarget(\"xml-stylesheet\")\n          .addInstruction(\"href\", href)\n          .addInstruction(\"type\", type);\n        prolog.addElement(pi);\n        \n        return(this);\n    }\n",
    "29892": "    public XMLDocument addStylesheet(String href) {\n        return addStylesheet(href, \"text/xsl\");\n    }\n",
    "29897": "    public XMLDocument addToProlog(ConcreteElement element) {\n        prolog.addElement(element);\n        return(this);\n    }\n",
    "29900": "    public XMLDocument addElement(XML element) {\n        if (content == null)\n            content = element;\n        else\n            content.addElement(element);\n            \n        return(this);\n    }\n",
    "29906": "    public void output(OutputStream out)\n    {        \n        /** \n         * FIXME: The other part of the version hack!\n         *   Add the version declaration to the beginning of the document.\n         */\n        try {\n            out.write(versionDecl.getBytes());\n        } catch (Exception e) { }\n        \n        for (int i=0; i<prolog.size(); i++) {\n            ConcreteElement e = (ConcreteElement)prolog.elementAt(i);\n            e.output(out);\n        }\n         \n        if (content != null)\n            content.output(out);\n    }\n",
    "29909": "    public PI addInstruction(String name, String value) {\n        addAttribute(name, value);\n        return(this);\n    }\n",
    "29916": "    public Object clone() {\n        return content.clone();\n    }\n",
    "29941": "    public String process(String to_process)\n    {   System.out.println(\"\\nString to Process in StringFilter = \"+to_process);\n        String[] value = split(to_process);\n        StringBuffer new_value = new StringBuffer();\n        for(int x = 0; x < value.length; x++)\n        {\n            if(hasAttribute(value[x]))\n                new_value.append((String)get(value[x]));\n            else\n                new_value.append(value[x]);\n            if(x != value.length - 1)\n                new_value.append(\" \");\n        }\n        return(new_value.toString());\n    }\n",
    "30502": "\tpublic CToggleButton () {\n\t\tthis(null, null, false);\n\t}\n",
    "30504": "\tpublic CToggleButton (String text) {\n\t\tthis(text, null, false);\n\t}\n",
    "30508": "\tpublic CToggleButton (String text, boolean selected) {\n\t\tthis(text, null, selected);\n\t}\n",
    "42686": "\tpublic MQuery (int AD_Table_ID)\n\t{\t//\tUse Client Context as r/o\n\t\tm_TableName = M_Table.getTableName (Env.getCtx(), AD_Table_ID);\n\t}\t//\tMQuery\n",
    "63167": "\n\tprotected String checkOptions()\t{ return null; }\n",
    "64598": "    public void initialize() {\n    }\n",
    "64614": "    public int getInitialFirstRowHeight() {\n    \treturn -1;\n    }\n",
    "64625": "    public void setFirstRowHeight(int value) {\n        setRowHeight(0, value);\n    }\n",
    "64630": "    public Object getContentAt(int col, int row) {\n        return doGetContentAt(col, row);\n    }\n",
    "64634": "    public String getTooltipAt(int col, int row) {\n        return doGetTooltipAt(col, row);\n    }\n",
    "64639": "    public String doGetTooltipAt(int col, int row) {\n        return null;\n    }\n",
    "64645": "    public KTableCellEditor getCellEditor(int col, int row) {\n        return doGetCellEditor(col, row);\n    }\n",
    "64662": "    public void setContentAt(int col, int row, Object value) {\n        doSetContentAt(col, row, value);\n        for (int i = 0; i < modelChangeListeners.size(); i++) {\n        \tModelChangeListener listener = (ModelChangeListener)modelChangeListeners.get(i);\n        \tlistener.modelChanged(col, row, value);\n        }\n    }\n",
    "64674": "    public boolean isFixedCell(int col, int row) {\n        return col < getFixedColumnCount()\n        || row < getFixedRowCount();\n    }\n",
    "64698": "\tprotected void onTraverse(TraverseEvent e) {\n\t    if (e.keyCode == SWT.ARROW_LEFT) {\n\t        if (m_Text.getCaretPosition()==0 && m_Text.getSelectionCount()==0)\n\t            super.onTraverse(e);\n\t        // handel the event within the text widget!\n\t    } else if (e.keyCode == SWT.ARROW_RIGHT) {\n\t        if (m_Text.getCaretPosition()==m_Text.getText().length() && m_Text.getSelectionCount()==0)\n\t            super.onTraverse(e);\n\t        // handle the event within the text widget!\n\t    } else\n\t        super.onTraverse(e);\n\t}\n",
    "64712": "    private boolean isValidHAlignment(int align) {\n        if (align==SWTX.ALIGN_HORIZONTAL_CENTER || \n            align==SWTX.ALIGN_HORIZONTAL_LEFT  || \n            align==SWTX.ALIGN_HORIZONTAL_RIGHT)\n            return true;\n        return false;\n    }\n",
    "64715": "    private boolean isValidVAlignment(int align) {\n        if (align==SWTX.ALIGN_VERTICAL_TOP || \n            align==SWTX.ALIGN_VERTICAL_CENTER  || \n            align==SWTX.ALIGN_VERTICAL_BOTTOM)\n            return true;\n        return false;\n    }\n",
    "64719": "\tpublic void close(boolean save) {\n\t\tsuper.close(save);\n\t\tm_Dialog = null;\n\t}\n",
    "64722": "    public Point belongsToCell(int col, int row) {\n        return doBelongsToCell(col, row);\n    }\n",
    "64723": "\tpublic void setBounds(Rectangle rect) {\n\t    // ignored.\n\t}\n",
    "64727": "    protected Control createControl() {\n        return null;\n    }\n",
    "64733": "    public Point doBelongsToCell(int col, int row) {\n        return new Point(col, row);\n    }\n",
    "64735": "\tpublic void open(KTable table, int col, int row, Rectangle rect) {\n\t\tm_Table = table;\n\t\tm_Model = table.getModel();\n\t\tm_Rect = rect;\n\t\tm_Row = row;\n\t\tm_Col = col;\n\t\t\n\t\tclose(true);\n\t\t\n\t\tGC gc = new GC(m_Table);\n\t\tm_Table.updateCell(m_Col, m_Row);\n\t\tgc.dispose();\n\t}\n",
    "64737": "\tpublic void close(boolean save) {\n\t    if (save) {\n\t        Object o = m_Model.getContentAt(m_Col, m_Row);\n\t        if (!(o instanceof Boolean))\n\t            throw new ClassCastException(\"CheckboxCellEditor needs a Boolean content!\");\n\t        \n\t        boolean newVal = !((Boolean)o).booleanValue();\n\t        \n\t        m_Model.setContentAt(m_Col, m_Row, new Boolean(newVal));\n\t    }\n\t    super.close(save);\n\t}\n",
    "64743": "    public void setContent(Object content) {\n    }\n",
    "64744": "    public int mapRowIndexToModel(int shownRow) {\n        return shownRow;\n    }\n",
    "64749": "    public void setColumnToCompare(int column) {\n        //if (row>=m_Model.getFixedRowCount())\n        //    throw new IllegalArgumentException(\"An invalid column index was given!\");\n        \n        m_ColIndex=column;\n    }\n",
    "64752": "    public int mapRowIndexToTable(int modelRow) {\n    \treturn modelRow;\n    }\n",
    "64754": "\tpublic void cellDoubleClicked(int col, int row, int statemask) {\n\t}\n",
    "64757": "\tpublic void fixedCellDoubleClicked(int col, int row, int statemask) {\n\t}\n",
    "64759": "    public void setSortDirection(int direction) {\n    \t if (direction!=SORT_UP && direction!=SORT_DOWN && direction!=SORT_NONE)\n             throw new IllegalArgumentException(\"Undefined sorting direction: \"+direction);\n         \n    \t m_Direction = direction;\n    }\n",
    "64763": "\tpublic void dispose() {\n\t\tif (m_Control != null) {\n\t\t\tControl contr = m_Control;\n\t\t\tm_Control = null;\n\t\t\tcontr.dispose();\n\t\t}\n\t}\n",
    "64768": "    public void setModel(KTableSortedModel model) {\n    \tm_Model = model;\n    }\n",
    "64775": "\tpublic void close(boolean save) {\n\t\tm_Table.m_CellEditor = null;\n\t\t//m_Control.setVisible(false);\n\t\tGC gc = new GC(m_Table);\n\t\tm_Table.drawCell(gc, m_Col, m_Row);\n\t\tgc.dispose();\n\t\tthis.dispose();\n\t\tm_Table.setFocus();\n\t}\n",
    "64776": "    public void sort(KTableSortComparator comparator) {\n        Collections.sort(rowMapping, comparator);\n        \n        m_Ordered = comparator.getSortDirection();\n        \n        if (m_Ordered==KTableSortComparator.SORT_NONE)\n            setSortColumn(-1);\n        else\n            setSortColumn(comparator.getColumnToSortOn());\n    }\n",
    "64777": "\tpublic boolean isFocused() {\n\t\tif (m_Control == null)\n\t\t\treturn false;\n\t\treturn m_Control.isFocusControl();\n\t}\n",
    "64780": "\tpublic void setBounds(Rectangle rect) {\n\t\tif (m_Control != null)\n\t\t\tm_Control.setBounds(rect);\n\t}\n",
    "64784": "    public void setStyle(int style) {\n        m_Style = style;\n    }\n",
    "64786": "    public Object getContentAt(int col, int row) {\n        row = mapRowIndexToModel(row);\n        // now have to check if the mapped cell is spanned, and if it is, take the\n        // cell that is responsible for the content of the big cell:\n        Point valid = getValidCell(col, row);\n        return doGetContentAt(valid.x, valid.y);\n    }\n",
    "64789": "    public String getTooltipAt(int col, int row) {\n        row = mapRowIndexToModel(row);\n        Point valid = getValidCell(col, row);\n        return doGetTooltipAt(valid.x, valid.y);\n    }\n",
    "64794": "    public KTableCellEditor getCellEditor(int col, int row) {\n        row = mapRowIndexToModel(row);\n        // now have to check if the mapped cell is spanned, and if it is, take the\n        // cell that is responsible for the content of the big cell:\n        Point valid = getValidCell(col, row);\n        return doGetCellEditor(valid.x, valid.y);\n    }\n",
    "64796": "    public void setContentAt(int col, int row, Object value) {\n        row = mapRowIndexToModel(row);\n        // now have to check if the mapped cell is spanned, and if it is, take the\n        // cell that is responsible for the content of the big cell:\n        Point valid = getValidCell(col, row);\n        doSetContentAt(valid.x, valid.y, value);\n    }\n",
    "64800": "    public KTableCellRenderer getCellRenderer(int col, int row) {\n        row = mapRowIndexToModel(row);\n        Point valid = getValidCell(col, row);\n        return doGetCellRenderer(valid.x, valid.y);\n    }\n",
    "64803": "    public Point belongsToCell(int col, int row) {\n        if (getSortState() == KTableSortComparator.SORT_NONE)\n            return doBelongsToCell(col, row);\n        // if sorting is active, all cells get rendered seperately!\n        return new Point(col, row);\n    }\n",
    "64810": "    protected void drawCellButton(GC gc, Rectangle rect, String text, boolean pressed) {\n        rect.height += 1;\n        rect.width += 1;\n        gc.setForeground(Display.getCurrent().getSystemColor(\n                SWT.COLOR_LIST_FOREGROUND));\n        if (pressed) {\n            SWTX.drawButtonDown(gc, \n                    text, getAlignment(),\n                    null, getAlignment(), rect);\n        } else {\n            SWTX.drawButtonUp(gc, \n                    text, getAlignment(),\n                    null, getAlignment(), rect);\n        }\n    }\n",
    "64839": "    private Image mirrorImage(Image source) {\n        Rectangle bounds = source.getBounds();\n        \n        ImageData sourceData = source.getImageData();\n        ImageData resultData = new ImageData(\n                sourceData.height, sourceData.width, \n                sourceData.depth, sourceData.palette);\n        for (int x = 0; x<bounds.width; x++)\n            for (int y=0; y<bounds.height; y++)\n                resultData.setPixel(y, resultData.height-x-1, sourceData.getPixel(x, y));\n        source.dispose();\n        return new Image(Display.getCurrent(), resultData);        \n    }\n",
    "64840": "\tpublic void cellSelected(int col, int row, int statemask) {\n\t}\n",
    "64841": "\tpublic void fixedCellSelected(int col, int row, int statemask) {\n\t}\n",
    "64848": "    protected Rectangle drawDefaultSolidCellLine(GC gc, Rectangle rect, Color vBorderColor, Color hBorderColor) {\n        return BorderPainter.drawDefaultSolidCellLine(gc, rect, vBorderColor, hBorderColor);\n    }\n",
    "64860": "    public void setAlignment(int style) {\n        m_alignment = style;\n    }\n",
    "64885": "    public void setForeground(Color fgcolor) {\n        m_fgColor=fgcolor;\n    }\n",
    "64898": "    public void setDefaultForeground(Color fgcolor) {\n        COLOR_TEXT = fgcolor;\n    }\n",
    "64900": "    public Point doBelongsToCell(int col, int row) {\n        if ((col==2 || col==3)&& !isFixedCell(col, row)) {\n            int newRow = row;\n            if ((row-getFixedRowCount())%2==1)\n                newRow--;\n            return new Point(2, newRow);\n        }\n        return new Point(col,row);\n    }\n",
    "64907": "    public void setBackground(Color bgcolor) {\n        m_bgColor=bgcolor;\n    }\n",
    "64917": "    public void setDefaultBackground(Color bgcolor) {\n        COLOR_BACKGROUND = bgcolor;\n    }\n",
    "64943": "    public void setFont(Font font) {\n        m_font = font;\n    }\n",
    "64959": "    protected void applyFont(GC gc) {\n        m_GCfont = gc.getFont();\n        if (m_font == null)\n            m_font = Display.getCurrent().getSystemFont();\n        if ((m_Style & SWT.BOLD) != 0 || (m_Style & SWT.ITALIC)!=0) {\n            FontData[] fd = m_font.getFontData();\n            int style = SWT.NONE;\n            if ((m_Style & SWT.BOLD)!=0)\n                style |= SWT.BOLD;\n            if ((m_Style & SWT.ITALIC)!=0)\n                style |= SWT.ITALIC;\n            \n            for (int i=0; i<fd.length; i++)\n                fd[i].setStyle(style);\n            m_TMPfont = new Font(Display.getCurrent(), fd);\n            gc.setFont(m_TMPfont);\n        }  else\n            gc.setFont(m_font);\n    }\n",
    "64969": "    protected void resetFont(GC gc) {\n        if (m_TMPfont!=null) {\n            m_TMPfont.dispose();\n            m_TMPfont = null;\n        }\n            \n        gc.setFont(m_GCfont);\n    }\n",
    "64989": "\tpublic Vector getTasks() {\n\t\treturn tasks;\n\t}\n",
    "64991": "\tpublic void addTask() {\n\t\tExampleTask task = new ExampleTask(\"New task\");\n\t\ttasks.add(tasks.size(), task);\n\t\tIterator iterator = taskChangeListeners.iterator();\n\t\twhile (iterator.hasNext())\n\t\t\t((ITaskChangeListener) iterator.next()).taskAdded(task);\n\t}\n",
    "65013": "\tpublic void setCompleted(boolean b) {\n\t\tcompleted = b;\n\t}\n",
    "65014": "\tpublic void setDescription(String string) {\n\t\tdescription = string;\n\t}\n",
    "65017": "\tpublic void setOwner(String string) {\n\t\towner = string;\n\t}\n",
    "65018": "\tpublic void setPercentComplete(int i) {\n\t\tpercentComplete = i;\n\t}\n",
    "65052": "\tprivate void createSashForm() {\n\t\tGridData gridData = new org.eclipse.swt.layout.GridData();\n\t\tgridData.horizontalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\tgridData.grabExcessHorizontalSpace = true;\n\t\tgridData.grabExcessVerticalSpace = true;\n\t\tgridData.verticalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\tsashForm = new SashForm(top, SWT.NONE);\n\t\tsashForm.setOrientation(org.eclipse.swt.SWT.VERTICAL);\n\t\tsashForm.setLayoutData(gridData);\n\t\tcreateTopComposite();\n\t\tcreateBottomComposite();\n\t}\n",
    "65053": "\tprivate TrifonTextModelExample getTrifonTextModelExample() {\n\t\tif (trifonTextModelExample == null) {\n\t\t\ttrifonTextModelExample = new TrifonTextModelExample();\n\t\t}\n\t\treturn trifonTextModelExample;\n\t}\n",
    "65055": "\tprivate void createTopComposite() {\n\t\ttopComposite = new Composite(sashForm, SWT.NONE);\n\t\ttopComposite.setLayout(new GridLayout());\n\t\tcreateKTable();\n\t}\n",
    "65057": "\tprivate void createBottomComposite() {\n\t\tbottomComposite = new Composite(sashForm, SWT.NONE);\n\t}\n",
    "65059": "\tprivate void createComposite() {\n\t\tcomposite = new Composite(tabFolder, SWT.NONE);\n\t\tbuttonOne = new Button(composite, SWT.NONE);\n\t\tbuttonOne.setBounds(new org.eclipse.swt.graphics.Rectangle(5,5,12,23));\n\t\tbuttonOne.setText(\"Button One\");\n\t}\n",
    "65060": "\tprivate void createKTable() {\n\t\tGridData gridData1 = new org.eclipse.swt.layout.GridData();\n\t\tgridData1.horizontalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\tgridData1.grabExcessHorizontalSpace = true;\n\t\tgridData1.grabExcessVerticalSpace = true;\n\t\tgridData1.verticalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\tkTable = new KTable(topComposite, SWT.NONE);\n\t\tkTable.setLayoutData(gridData1);\n\t\t\n\t\tkTable.setModel(model);\n\t}\n",
    "65063": "\tprivate void createComposite1() {\n\t\tcompositeTwo = new Composite(tabFolder, SWT.NONE);\n\t\tcreateKTable();\n\t}\n",
    "65066": "\tprivate void createKTable() {\n\t\tkTable = new KTable(compositeTwo, SWT.V_SCROLL | SWT.H_SCROLL \n\t\t\t\t| SWTX.FILL_WITH_LASTCOL\n\t\t\t\t| SWTX.EDIT_ON_KEY | SWT.MULTI | SWTX.MARK_FOCUS_HEADERS ); // @Trifon important\n\n\t\tkTable.setModel(getTrifonTextModelExample());\n\t\tkTable.setBounds(new org.eclipse.swt.graphics.Rectangle(115,15,77,23));\n\t\t\n\t}\n",
    "65070": "\tprivate void createBottomCTabFolder() {\n\t\tbottomTabFolder = new TabFolder(sashForm, SWT.NONE);\n\t\t\n\t\ttabItemOne = new TabItem(bottomTabFolder, SWT.NONE);\n\t\ttabItemOne.setText(\"Text Table\");\n\t\t\n\t\tComposite comp1 = new Composite(bottomTabFolder, SWT.NONE);\n\t\ttabItemOne.setControl(comp1);\n\t\tcomp1.setLayout(new FillLayout());\n\t\ttabOneKTable = new KTable(comp1, SWT.V_SCROLL | SWT.H_SCROLL \n\t\t\t\t| SWTX.FILL_WITH_LASTCOL\n\t\t\t\t| SWTX.EDIT_ON_KEY | SWT.MULTI | SWTX.MARK_FOCUS_HEADERS ); // @Trifon important\n\t\t\n\t}\n",
    "65108": "\tpublic boolean isSurveyant() {\n\t\treturn this.level == OutlawUser.LEVEL_NOBODY;\n\t}\n",
    "65110": "\tpublic Condition getPostCondition() {\n\t\treturn this.postCondition;\n\t}\n",
    "65112": "\tpublic void setContent(List<PersistentObject> list) {\n\t\tthis.content = list;\n\t}\n",
    "65113": "\tprivate void createTabFolder() {\n\t\tGridData gridData = new org.eclipse.swt.layout.GridData();\n\t\tgridData.horizontalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\tgridData.grabExcessHorizontalSpace = true;\n\t\tgridData.grabExcessVerticalSpace = true;\n\t\tgridData.verticalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\ttabFolder = new TabFolder(top, SWT.NONE);\n\t\ttabFolder.setLayoutData(gridData);\n\t}\n",
    "65115": "\tpublic String getFilename() {\n\t\treturn this.filename;\n\t}\n",
    "65117": "\tpublic void setFilename(final String string) {\n\t\tthis.filename = string;\n\t}\n",
    "65118": "\tpublic void setImage(byte[] data) {\n\t\tthis.data = data;\n\t}\n",
    "65119": "\tpublic boolean isUser() {\n\t\treturn this.level == OutlawUser.LEVEL_USER;\n\t}\n",
    "65128": "\tpublic boolean isAdmin() {\n\t\treturn this.level == OutlawUser.LEVEL_ADMIN;\n\t}\n",
    "65132": "\tpublic String getText() {\n\t\treturn this.text;\n\t}\n",
    "65135": "\tpublic int getLayout() {\n\t\treturn this.layout;\n\t}\n",
    "65138": "\tpublic void setText(final String string) {\n\t\tthis.text = string;\n\t}\n",
    "65141": "\tpublic void setLayout(final int theLayout) {\n\t\tthis.layout = theLayout;\n\t}\n",
    "65144": "\tpublic String getTextPreview() {\n\t\tString retVal;\n\n\t\tif (this.text.length() > 120) {\n\t\t\tretVal = this.text.substring(0, 60);\n\t\t\tretVal += \"...\";\n\t\t\tretVal += this.text.substring(this.text.length() - 60 - 1, this.text.length() - 1);\n\t\t} else {\n\t\t\tretVal = this.text;\n\t\t}\n\n\t\treturn retVal;\n\t}\n",
    "65147": "\tpublic Date getCdate() {\n\t\treturn this.cdate;\n\t}\n",
    "65150": "\tpublic Date getEdate() {\n\t\treturn this.edate;\n\t}\n",
    "65151": "\tpublic Date getSdate() {\n\t\treturn this.sdate;\n\t}\n",
    "65155": "\tpublic int getState() {\n\t\treturn this.state;\n\t}\n",
    "65158": "\tpublic Survey getSurvey() {\n\t\treturn this.survey;\n\t}\n",
    "65162": "\tpublic void setCdate(final Date date) {\n\t\tthis.cdate = date;\n\t}\n",
    "65165": "\tpublic void setEdate(final Date date) {\n\t\tthis.edate = date;\n\t}\n",
    "65168": "\tpublic void setSdate(final Date date) {\n\t\tthis.sdate = date;\n\t}\n",
    "65171": "\tpublic void setState(final int theState) {\n\t\tthis.state = theState;\n\t}\n",
    "65175": "\tpublic void setSurvey(final Survey theSurvey) {\n\t\tthis.survey = theSurvey;\n\t}\n",
    "65212": "\tpublic int getQuestionLayout() {\n\t\treturn this.questionLayout;\n\t}\n",
    "65220": "\tpublic int getAnswerLayout() {\n\t\treturn this.answerLayout;\n\t}\n",
    "65353": "    public boolean equals(Object object)\n    {  \n        if (!(object instanceof InternalGroupPrincipal))\n            return false;\n\n        InternalGroupPrincipal r = (InternalGroupPrincipal) object;\n        boolean isEqual = (r.getFullPath().equals(this.getFullPath()));\n        return isEqual;\n    }\n",
    "65370": "    public boolean equals(Object object)\n    {  \n        if (!(object instanceof InternalRolePrincipal))\n            return false;\n\n        InternalRolePrincipal r = (InternalRolePrincipal) object;\n        boolean isEqual = (r.getFullPath().equals(this.getFullPath()));\n        return isEqual;\n    }\n",
    "65394": "    public boolean equals(Object object)\n    {  \n        if (!(object instanceof InternalUserPrincipal))\n            return false;\n\n        InternalUserPrincipal r = (InternalUserPrincipal) object;\n        boolean isEqual = (r.getFullPath().equals(this.getFullPath()));\n        return isEqual;\n    }\n",
    "65424": "    public boolean equals(Object object)\n    {  \n        if (!(object instanceof InternalCredential))\n            return false;\n\n        InternalCredential c = (InternalCredential) object;\n        boolean isEqual = ((c.getValue().equals(this.getValue())) && (c.getType() == this.getType()) && ((null == c.getClassname()) || (c.getClassname().equals(this.getClassname()))));\n        return isEqual;\n    }\n",
    "65427": "    public String getSystemRoot()\n    {        \n        return \"/\";\n    }\n",
    "65555": "    public List retrieveOptions(Object command, Object context) {\n        if (getRefreshPropertyAsBoolean(command)) {\n            return chainedOption.retrieveOptions(command, context);\n        } else {\n            return new LinkedList();\n        }\n    }\n",
    "65556": "    protected LabelValueBean convertBean(Object object) {\n        String string = (String) object;\n        return new LabelValueBean(string, string);\n    }\n",
    "65558": "    public List adjustAndSort(List options, Object context) {\n        return options;\n    }\n",
    "65559": "    public void updateValue(Object command, List options, Object context) {\n        if (getRefreshPropertyAsBoolean(command)) {\n            chainedOption.updateValue(command, options, context);\n        }\n    }\n",
    "65561": "    public String getDefaultValue(List options, Object context) {\n        if (options.size() > 0) {\n            LabelValueBean bean = (LabelValueBean) options.get(0);\n            return bean.getValue();\n        } else {\n            return \"\";\n        }\n    }\n",
    "65569": "    public void setExtraItems(List extraItems) {\n        this.extraItems = extraItems;\n    }\n",
    "65570": "    public String getOptionsKey() {\n        return chainedOption.getOptionsKey();\n    }\n",
    "65574": "    public void setChainedOption(ChainedOption chainedOption) {\n        this.chainedOption = chainedOption;\n    }\n",
    "65581": "    public void setRefreshProperty(String refreshProperty) {\n        this.refreshProperty = refreshProperty;\n    }\n",
    "65582": "    public void setOptions(List options) {\n        this.options = options;\n    }\n",
    "65584": "    public List adjustAndSort(List options, Object context) {\n        LinkedList result = new LinkedList();\n        result.addAll(options);\n        Collections.sort(result);\n        return result;\n    }\n",
    "65588": "    public List convert(List beans) {\n        List retval = new ArrayList(beans.size());\n        for (Iterator iter = beans.iterator(); iter.hasNext();) {\n            LabelValueBean bean = convertBean(iter.next());\n            retval.add(bean);\n        }\n\n        return retval;\n    }\n",
    "65589": "    public void referenceData(Map model, Object command, Object context) {\n        for (Iterator iter = chainedOptions.iterator(); iter.hasNext();) {\n            ChainedOption chainedOption = (ChainedOption) iter.next();\n            List options = chainedOption.retrieveOptions(command, context);\n            model.put(chainedOption.getOptionsKey(), options);\n            chainedOption.updateValue(command, options, context);\n        }\n    }\n",
    "65590": "    public ChainedOptionStrategy getStrategy(Object command) {\n        return chainedOption.getStrategy(command);\n    }\n",
    "65600": "    public void updateValue(Object command, List options, Object context) {\n        String selectedValue = getProperty(command, getCommandProperty());\n\n        for (Iterator iter = options.iterator(); iter.hasNext();) {\n            if (matches((LabelValueBean) iter.next(), selectedValue)) {\n                return;\n            }\n        }\n\n        setProperty(command, getCommandProperty(), getStrategy(command)\n                .getDefaultValue(options, context));\n    }\n",
    "65607": "    protected boolean matches(LabelValueBean bean, String value) {\n        if (value == null) {\n            return false;\n        }\n        String beanValue = ((LabelValueBean) bean).getValue();\n        return StringUtils.equals(beanValue, value);\n    }\n",
    "65615": "    protected void initChainedOption() {\n    }\n",
    "65625": "    protected void setProperty(Object bean, String propertyName, Object value) {\n        BeanWrapper commandWrapper = new BeanWrapperImpl(bean);\n        commandWrapper.setPropertyValue(new PropertyValue(propertyName, value));\n    }\n",
    "65640": "    public void setCommandProperty(String commandProperty) {\n        this.commandProperty = commandProperty;\n    }\n",
    "65653": "    public void setOptionsKey(String optionsKey) {\n        this.optionsKey = optionsKey;\n    }\n",
    "65665": "    public void setConverter(BeanConverter converter) {\n        this.converter = converter;\n    }\n",
    "65667": "    public void testUpdateValue_valueExists() {\n        SomeCommand someCommand = new SomeCommand();\n        someCommand.setRegion(\"EU\");\n\n        final LabelValueBean expected = new LabelValueBean(\"a\", \"b\");\n        AbstractChainedOption tested = new AbstractChainedOption() {\n\n            public List retrieveOptions(Object command, Object context) {\n                return null;\n            }\n\n            protected boolean matches(LabelValueBean bean, String value) {\n                assertSame(expected, bean);\n                return true;\n            }\n\n            public ChainedOptionStrategy getStrategy(Object command) {\n                return strategyMock;\n            }\n        };\n\n        tested.setCommandProperty(\"region\");\n\n        tested.updateValue(someCommand, Collections.singletonList(expected),\n                null);\n\n        assertEquals(\"EU\", someCommand.getRegion());\n    }\n",
    "65674": "    public ChainedOptionStrategy getStrategy(Object command) {\n        return defaultStrategy;\n    }\n",
    "65683": "    public void setDefaultStrategy(ChainedOptionStrategy defaultStrategy) {\n        this.defaultStrategy = defaultStrategy;\n    }\n",
    "65802": "    @Override protected void startup() {\n        show(new VisualJBusinessView(this));\n    }\n",
    "65803": "    @Override protected void configureWindow(java.awt.Window root) {\n    }\n",
    "65809": "    public Database getDatabase() {\n        return this.database;\n    }\n",
    "65811": "    public void setDatabase(Database database) {\n        this.database = database;\n    }\n",
    "65812": "     public Table getChoosenTableByName(String name) {\n        Table table = null, target = null;\n        Tables choosenTables = getDatabase().getChoosenTables();\n        for (int i = 0; i < choosenTables.getSize(); i++) {\n            target = (Table) choosenTables.getElementAt(i);\n            if (target.getName().equalsIgnoreCase(name)) {\n                return target;\n            }\n        }\n        return table;\n    }\n",
    "65813": "     public Table getChoosenTableHlsHead(Table table) {\n        Table target = null;\n        if (table.getHlsHead().equals(\"\")) {\n            // there is no head\n            return (Table) null;\n        }\n        Tables choosenTables = getDatabase().getChoosenTables();\n        for (int i = 0; i < choosenTables.getSize(); i++) {\n            target = (Table) choosenTables.getElementAt(i);\n            if (target.getName().equalsIgnoreCase(table.getHlsHead())) {\n                // head found\n                return target;\n            }\n        }\n        return (Table) null;\n    }\n",
    "65815": "    public Table getChoosenTableHlsLines(Table table) {\n        Table target = null;\n        if (table.getHlsLines().equals(\"\")) {\n            // there is no lines\n            return (Table) null;\n        }\n        Tables choosenTables = getDatabase().getChoosenTables();\n        for (int i = 0; i < choosenTables.getSize(); i++) {\n            target = (Table) choosenTables.getElementAt(i);\n            if (target.getName().equalsIgnoreCase(table.getHlsLines())) {\n                // lines found\n                return target;\n            }\n        }\n        return (Table) null;\n    }\n",
    "65817": "    public Table getColumnFkTable(Column column) {\n        Table target = null;\n        if (column.getFkTable().equals(\"\")) {\n            // there is no fkTable\n            return (Table) null;\n        }\n        Tables choosenTables = getDatabase().getChoosenTables();\n        for (int i = 0; i < choosenTables.getSize(); i++) {\n            target = (Table) choosenTables.getElementAt(i);\n            if (target.getName().equalsIgnoreCase(column.getFkTable())) {\n                // fkTable found\n                return target;\n            }\n        }\n        return (Table) null;\n    }\n",
    "65844": "    public String getSecurityPath() {\n        return securityPath;\n    }\n",
    "65845": "    public void setSecurityPath(String securityPath) {\n        securityPath = securityPath.toLowerCase().trim();\n        if(!securityPath.equals(\"\")) {\n            //securityPath.replaceAll(\"\\\\\", \"/\");\n            securityPath.replaceAll(\".\", \"/\");\n            securityPath.replaceAll(\" \", \"\");\n            if(securityPath.startsWith(\"/\")) {\n                securityPath = securityPath.substring(1);\n            }\n            if(!securityPath.endsWith(\"/\")) {\n                securityPath = securityPath + \"/\";\n            }\n        }\n        this.securityPath = securityPath;\n    }\n",
    "65874": "    protected Rectangle getCellRectIgnoreSpan(int col, int row) {\n        return getCellRectIgnoreSpan(col, row, getColumnLeft(col) + 1);\n    }\n",
    "65967": "    public String getTableName() {\n        return tableName;\n    }\n",
    "65968": "    public MenuVJB getMenuVJB() {\n        return menuVJB;\n    }\n",
    "65969": "    public void setTableName(String tableName) {\n        this.tableName = tableName;\n    }\n",
    "65970": "    public void setMenuVJB(MenuVJB menuVJB) {\n        this.menuVJB = menuVJB;\n    }\n",
    "65975": "    public String getTitleOfMenuOfItemsVJB() {\n        return titleOfMenuOfItemsVJB;\n    }\n",
    "65977": "    public void setTitleOfMenuOfItemsVJB(String titleOfMenuOfItemsVJB) {\n        this.titleOfMenuOfItemsVJB = titleOfMenuOfItemsVJB;\n    }\n",
    "65978": "    public boolean isMenuOfItemsSetted() {\n        return menuOfItemsSetted;\n    }\n",
    "65980": "    public void setMenuOfItemsSetted(boolean menuOfItemsSetted) {\n        this.menuOfItemsSetted = menuOfItemsSetted;\n    }\n",
    "65981": "    public MenuBarVJB getMenuBarVJB() {\n        return menuBarVJB;\n    }\n",
    "65983": "    public void setMenuBarVJB(MenuBarVJB menuBarVJB) {\n        this.menuBarVJB = menuBarVJB;\n    }\n",
    "65987": "    public boolean isAddNewMenuBar() {\n        return addNewMenuBar;\n    }\n",
    "65990": "    public void setAddNewMenuBar(boolean addNewMenuBar) {\n        this.addNewMenuBar = addNewMenuBar;\n    }\n",
    "66004": "    public Table getSelectedTable() {\n        return selectedTable;\n    }\n",
    "66005": "    public MenuOfBarVJB getMenuOfBarVJB() {\n        return menuOfBarVJB;\n    }\n",
    "66006": "    public void setSelectedTable(Table selectedTable) {\n        this.selectedTable = selectedTable;\n    }\n",
    "66007": "    public void setMenuOfBarVJB(MenuOfBarVJB menuOfBarVJB) {\n        this.menuOfBarVJB = menuOfBarVJB;\n    }\n",
    "66008": "    public boolean isTargetClassSelected() {\n        return targetClassSelected;\n    }\n",
    "66010": "    public void setTargetClassSelected(boolean targetClassSelected) {\n        this.targetClassSelected = targetClassSelected;\n    }\n",
    "66022": "    public String getMenuTitle() {\n        return menuTitle;\n    }\n",
    "66026": "    public void setMenuTitle(String menuTitle) {\n        this.menuTitle = menuTitle;\n    }\n",
    "66028": "    public int getMenuVJBType() {\n        return menuVJBType;\n    }\n",
    "66030": "    public void setMenuVJBType(int menuVJBType) {\n        this.menuVJBType = menuVJBType;\n    }\n",
    "66031": "    public boolean isCreateNewMenuBar() {\n        return createNewMenuBar;\n    }\n",
    "66032": "    public boolean isSelected() {\n        return selected;\n    }\n",
    "66033": "    public void setCreateNewMenuBar(boolean createNewMenuBar) {\n        this.createNewMenuBar = createNewMenuBar;\n    }\n",
    "66035": "    public void setSelected(boolean selected) {\n        this.selected = selected;\n    }\n",
    "66041": "    public String getMenuBarVJBName() {\n        return menuBarVJBName;\n    }\n",
    "66042": "    public void setMenuBarVJBName(String menuBarVJBName) {\n        this.menuBarVJBName = menuBarVJBName;\n    }\n",
    "66048": "    public void setMenuItemVJBList(ArrayList<MenuItemVJB> menuItemVJBList) {\n        this.menuItemVJBList = menuItemVJBList;\n    }\n",
    "66053": "    public void setMenuVJBList(ArrayList<MenuVJB> menuVJBList) {\n        this.menuVJBList = menuVJBList;\n    }\n",
    "66063": "    public void setMenusBarVJB(ArrayList<MenuBarVJB> menusBarVJB) {\n        this.menusBarVJB = menusBarVJB;\n    }\n",
    "66132": "    private String testDropTarget(TreePath destination, TreePath dropper) {\n        //Typical Tests for dropping\n\n        //Test 1.\n        boolean destinationPathIsNull = destination == null;\n        if (destinationPathIsNull) {\n            return \"Invalid drop location.\";\n        }\n\n        //Test 2.\n        MenuNode node = (MenuNode) destination.getLastPathComponent();\n        if (!node.getAllowsChildren()) {\n            return \"This node does not allow children\";\n        }\n\n        if (destination.equals(dropper)) {\n            return \"Destination cannot be same as source\";\n        }\n\n        //Test 3.\n        if (dropper.isDescendant(destination)) {\n            return \"Destination node cannot be a descendant.\";\n        }\n\n        //Test 4.\n        if (dropper.getParentPath().equals(destination)) {\n            return \"Destination node cannot be a parent.\";\n        }\n\n        return null;\n    }\n",
    "66171": "    public void redraw(Rectangle cellsToRedraw) {\n        checkWidget();\n        redraw(cellsToRedraw.x, cellsToRedraw.y, cellsToRedraw.width,\n                cellsToRedraw.height);\n    }\n",
    "66199": "    protected void drawCell(GC gc, int col, int row) {\n        \n        drawCell(gc, col, row, getCellRect(col, row));\n        \n        Rectangle oldClip = gc.getClipping();\n        gc.setClipping(getClientArea());\n        if ((getStyle() & SWTX.MARK_FOCUS_HEADERS)==SWTX.MARK_FOCUS_HEADERS) {\n            if (row>=m_TopRow) {\n                for (int i=0; i<m_Model.getFixedHeaderColumnCount(); i++)\n                    drawCell(gc, i, row, getCellRect(i, row));\n                for (int i=0; i<m_Model.getFixedHeaderRowCount(); i++)\n                    drawCell(gc, col, i, getCellRect(col, i));\n            }\n        }\n        gc.setClipping(oldClip);\n    }\n",
    "66227": "    public String getDateMask() {\n        return dateMask;\n    }\n",
    "66229": "    public void setDateMask(String dateMask) {\n        this.dateMask = dateMask;\n    }\n",
    "66231": "    public void updateCell(int col, int row) {\n        checkWidget();\n        if ((row < 0) || (row >= m_Model.getRowCount()) || \n            (col < 0) || (col >= m_Model.getColumnCount()))\n            return;\n\n        // be sure it is a valid cell if cells span \n        Point valid = getValidCell(col, row);\n        // update it:\n        GC gc = new GC(this);\n        drawCell(gc, valid.x, valid.y);\n        gc.dispose();\n    }\n",
    "66237": "    public JPanel getSelectedPanel() {\n        return selectedPanel;\n    }\n",
    "66238": "    public void setSelectedPanel(JPanel selectedPanel) {\n        this.selectedPanel = selectedPanel;\n    }\n",
    "66270": "    @Override protected void startup() {\n        show(new HotdogView(this));\n    }\n",
    "66273": "    public boolean isUfRecordSelected() {\n        return ufTable.getSelectedRow() != -1;\n    }\n",
    "66284": "    public boolean isSaveFired() {\n        return saveFired;\n    }\n",
    "66285": "    public void setSaveFired(boolean saveFired) {\n        this.saveFired = saveFired;\n    }\n",
    "66286": "    public Cliente getCurrentRecord() {\n        return currentRecord;\n    }\n",
    "66288": "    public void setCurrentRecord(Cliente currentRecord) {\n        Cliente oldRecord = this.currentRecord;\n        this.currentRecord = currentRecord;\n        propertyChangeSupport.firePropertyChange(\"currentRecord\",\n                oldRecord, currentRecord);\n    }\n",
    "66297": "    public boolean isCidadeRecordSelected() {\n        return cidadeTable.getSelectedRow() != -1;\n    }\n",
    "66300": "    public void setDefaultCursor(Cursor cursor, Point size_below_hotspot) {\n        checkWidget();\n        if (m_defaultCursor != null)\n            m_defaultCursor.dispose();\n        m_defaultCursor = cursor;\n        m_defaultCursorSize = size_below_hotspot;\n        setCursor(cursor);\n    }\n",
    "66305": "    public Animal getCurrentRecord() {\n        return currentRecord;\n    }\n",
    "66306": "    public void setCurrentRecord(Animal currentRecord) {\n        Animal oldRecord = this.currentRecord;\n        this.currentRecord = currentRecord;\n        propertyChangeSupport.firePropertyChange(\"currentRecord\",\n                oldRecord, currentRecord);\n    }\n",
    "66323": "    public Hospedagem getCurrentRecord() {\n        return currentRecord;\n    }\n",
    "66324": "    public void setCurrentRecord(Hospedagem currentRecord) {\n        Hospedagem oldRecord = this.currentRecord;\n        this.currentRecord = currentRecord;\n        propertyChangeSupport.firePropertyChange(\"currentRecord\",\n                oldRecord, currentRecord);\n        if(this.currentRecord == null) {\n            Logger.getLogger(this.getClass().getName()).\n                warning(\"this.current record is null!\");\n        }\n        Logger.getLogger(this.getClass().getName()).\n                info(\"setCurrentRecord method, diaria value : \" + this.currentRecord.getDiaria());\n    }\n",
    "66330": "    public boolean isAnimalRecordSelected() {\n        return animalTable.getSelectedRow() != -1;\n    }\n",
    "66341": "    public Cidade getCurrentRecord() {\n        return currentRecord;\n    }\n",
    "66342": "    public void setCurrentRecord(Cidade currentRecord) {\n        Cidade oldRecord = this.currentRecord;\n        this.currentRecord = currentRecord;\n        propertyChangeSupport.firePropertyChange(\"currentRecord\",\n                oldRecord, currentRecord);\n    }\n",
    "66379": "    public boolean isClienteRecordSelected() {\n        return clienteTable.getSelectedRow() != -1;\n    }\n",
    "66438": "    public boolean isHospedagemRecordSelected() {\n        return hospedagemTable.getSelectedRow() != -1;\n    }\n",
    "66452": "    public Double getDesconto() {\n        return desconto;\n    }\n",
    "66453": "    public void setDesconto(Double desconto) {\n        this.desconto = desconto;\n    }\n",
    "66455": "    public Double getDiaria() {\n        return diaria;\n    }\n",
    "66456": "    public void setDiaria(Double diaria) {\n        this.diaria = diaria;\n    }\n",
    "66459": "    public Date getFim() {\n        return fim;\n    }\n",
    "66461": "    public void setFim(Date fim) {\n        this.fim = fim;\n    }\n",
    "66462": "    public Date getInicio() {\n        return inicio;\n    }\n",
    "66464": "    public void setInicio(Date inicio) {\n        this.inicio = inicio;\n    }\n",
    "66465": "    public Animal getAnimal() {\n        return animal;\n    }\n",
    "66467": "    public void setAnimal(Animal animal) {\n        this.animal = animal;\n    }\n",
    "66477": "    protected Point checkIfMatchesInColumns(int startRow, int endRow, int startCol, int endCol, Point toFind, boolean span) {\n        \n        for (int row = startRow; row < endRow; row++) {\n            for (int col = startCol; col < endCol; col++) {\n                \n                Rectangle rect = getCellRectIgnoreSpan(col, row);\n                // take into account the 1px right and bottom border\n                rect.width+=1;\n                rect.height+=1;\n                if (rect.contains(toFind))\n                    if (span)\n                    // take into account the spanning when reporting a match:\n                        return getValidCell(col, row);\n                    else\n                        return new Point(col, row);\n            }\n        }\n        return null;\n    }\n",
    "66478": "    public void setPlayers(ArrayList<PlayerThread> players) {\n        this.players = players;\n    }\n",
    "66535": "    public int getType() {\n        return type;\n    }\n",
    "66537": "    public void setType(int type) {\n        this.type = type;\n    }\n",
    "66570": "    public String getPlayerName() {\n        return playerName;\n    }\n",
    "66571": "    public void setPlayerName(String playerName) {\n        this.playerName = playerName;\n    }\n",
    "66572": "    public Integer getServerPort() {\n        return serverPort;\n    }\n",
    "66573": "    public void setServerPort(Integer serverPort) {\n        this.serverPort = serverPort;\n    }\n",
    "66575": "    public String getServerIP() {\n        return serverIP;\n    }\n",
    "66577": "    public void setServerIP(String serverIP) {\n        this.serverIP = serverIP;\n    }\n",
    "66585": "    public KeyframeController getKeyframeController() {\n        return keyframeController;\n    }\n",
    "66587": "    public void setKeyframeController(KeyframeController keyframeController) {\n        this.keyframeController = keyframeController;\n    }\n",
    "66588": "    public Node getNode() {\n        return node;\n    }\n",
    "66590": "    public void setNode(Node node) {\n        this.node = node;\n    }\n",
    "66607": "    public void setModelAnimationsList(List<ModelAnimation> modelAnimationsList) {\n        this.modelAnimationsList = modelAnimationsList;\n    }\n",
    "66609": "    public ModelAnimation getBaseAnimation() {\n        return baseAnimation;\n    }\n",
    "66611": "    public void setBaseAnimation(ModelAnimation baseAnimation) {\n        this.baseAnimation = baseAnimation;\n    }\n",
    "66612": "    public ModelAnimation getRunAnimation() {\n        return runAnimation;\n    }\n",
    "66614": "    public void setRunAnimation(ModelAnimation runAnimation) {\n        this.runAnimation = runAnimation;\n    }\n",
    "66632": "    private void buildInput() {\n        input = new ChaseDoomHandler(player.getNode(), properties.getRenderer());\n        mouse = new RelativeMouse(\"Mouse Input\");\n        mouse.registerWithInputHandler(input);\n\tmouse.setCullMode(Spatial.CULL_ALWAYS);\n        URL cursorFile = null;\n        try {\n            cursorFile = new File(\"model\", \"cursor1.png\").toURI().toURL();\n        } catch (MalformedURLException ex) {\n            Logger.getLogger(Client.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        MouseInput.get().setHardwareCursor(cursorFile);\n    }\n",
    "66638": "    public int getBeginFrame() {\n        return beginFrame;\n    }\n",
    "66639": "    public void setBeginFrame(int beginFrame) {\n        this.beginFrame = beginFrame;\n    }\n",
    "66640": "    public int getEndFrame() {\n        return endFrame;\n    }\n",
    "66641": "    public void setEndFrame(int endFrame) {\n        this.endFrame = endFrame;\n    }\n",
    "66642": "    public boolean isAnimating() {\n        return animating;\n    }\n",
    "66643": "    public void setAnimating(boolean animating) {\n        this.animating = animating;\n    }\n",
    "66644": "    public void setKeys(List<Integer> keys) {\n        if (this.getKeys().size()>0) {\n            this.getKeys().clear();\n        }\n        this.getKeys().addAll(keys);\n    }\n",
    "66647": "    public boolean isEnabled() {\n\n        return enabled;\n    }\n",
    "66649": "    public void setEnabled(boolean enabled) {\n\n        this.enabled = enabled;\n\n        if (enabled) {\n            setCullMode(CULL_DYNAMIC);\n        } else {\n            setCullMode(CULL_ALWAYS);\n        }\n    }\n",
    "66650": "    public void setColor(ColorRGBA color) {\n\n        this.color = color;\n\n        text2D.setTextColor(color);\n    }\n",
    "66651": "    public void setOffset(Vector3f offset) {\n\n        this.offset = offset;\n    }\n",
    "66652": "    public void setText(String text) {\n\n        text2D.setText(text);\n    }\n",
    "66656": "    public void setHorizontalAlignment(int align) {\n\n        if (align == HA_LEFT) {\n            alignOffset = 0;\n        } else if (align == HA_CENTER) {\n            alignOffset = (text2D.getWidth() / 2) * -1;\n        } else if (align == HA_RIGHT) {\n            alignOffset = text2D.getWidth() * -1;\n        }\n\n        alignOffset = alignOffset * getLocalScale().x;\n    }\n",
    "66658": "    public void setVerticalAlignment(int valign) {\n\n        if (valign == VA_TOP) {\n            valignOffset = 0;\n        } else if (valign == VA_MIDDLE) {\n            valignOffset = (text2D.getHeight() / 2) * -1;\n        } else if (valign == VA_BOTTOM) {\n            valignOffset = text2D.getHeight() * -1;\n        }\n\n        valignOffset = valignOffset * getLocalScale().y;\n    }\n",
    "66661": "    public boolean isEditorOutcomeSave() {\n        return editorOutcomeSave;\n    }\n",
    "66663": "    public void setEditorOutcomeSave(boolean editorOutcomeSave) {\n        this.editorOutcomeSave = editorOutcomeSave;\n    }\n",
    "66720": "    public void setToolTipText(String tooltip) {\n        m_nativTooltip = tooltip;\n    }\n",
    "66734": "    public String getToolTipText() {\n        return m_nativTooltip;\n    }\n",
    "66811": "    public void openEditorInFocus(KTableCellEditor cellEditor) {\n        checkWidget();\n        //m_CellEditor = m_Model.getCellEditor(m_FocusCol, m_FocusRow);\n        m_CellEditor = cellEditor; //@Trifon\n        if (m_CellEditor != null) {\n            scrollToFocus();\n            Rectangle r = getCellRect(m_FocusCol, m_FocusRow);\n            m_CellEditor.open(this, m_FocusCol, m_FocusRow, r);\n        }\n    }\n",
    "66843": "    public void scroll(int col, int row) {\n        if (col<0 || col>=m_Model.getColumnCount() ||\n            row<0 || row>=m_Model.getRowCount())\n            return;\n        \n        m_TopRow = row;\n        m_LeftColumn=col;\n        redraw();\n    }\n",
    "66897": "    public void addCellSelectionListener(KTableCellSelectionListener listener) {\n        cellSelectionListeners.add(listener);\n    }\n",
    "66909": "    public void addCellResizeListener(KTableCellResizeListener listener) {\n        cellResizeListeners.add(listener);\n    }\n",
    "66949": "    public void addCellDoubleClickListener(KTableCellDoubleClickListener listener) {\n        cellDoubleClickListeners.add(listener);\n    }\n",
    "66967": "    public boolean removeCellSelectionListener(KTableCellSelectionListener listener) {\n        return cellSelectionListeners.remove(listener);\n    }\n",
    "66991": "    public boolean removeCellResizeListener(KTableCellResizeListener listener) {\n        return cellResizeListeners.remove(listener);\n    }\n",
    "67028": "    public boolean removeDoubleClickListener(KTableCellDoubleClickListener listener) {\n        return cellDoubleClickListeners.remove(listener);\n    }\n",
    "67038": "  public void gotoRecord(int pos) {\n    curRecordIndex = pos;\n    int rowNb = curRecordIndex-1+firstRowIndex;\n    getCaller().trace.trace(\"Moving to record #\"+pos+\" (row #\"+rowNb+\")\");\n    if(rowNb<firstRowIndex || rowNb>lastRowIndex)\n      curRow = null;\n    else\n      curRow = curSheet.getRow(rowNb);\n  }\n",
    "67043": "  public Value getColumn(int i) throws ExecuteException {\n    if(i<1 || i>sheetLabels.length)\n      throw new ExecuteException(\"Cell #\"+i+\" is out of range\");\n    if(curRow==null) return NullValue.NULL;\n    getCaller().trace.trace(\"Getting column #\"+i);\n    return getCellValue((short)(i-1));\n    // getCellType: CELL_TYPE_STRING, CELL_TYPE_NUMERIC, CELL_TYPE_FORMULA, CELL_TYPE_BOOLEAN, CELL_TYPE_ERROR\n    //    return cell.getNumericCellValue();\n  }\n",
    "67044": "    public boolean isRowSelectMode() {\n        return (getStyle() & SWT.FULL_SELECTION) == SWT.FULL_SELECTION;\n    }\n",
    "67056": "    public boolean isMultiSelectMode() {\n        return (getStyle() & SWT.MULTI) == SWT.MULTI;\n    }\n",
    "67066": "  protected boolean first100AreInteger(short col) {\n    int i = firstRowIndex;\n    HSSFRow row;\n    while((row=curSheet.getRow(i++))!=null && i<100) {\n      HSSFCell cell = row.getCell(col);\n      if(cell!=null) {\n\tif(cell.getCellType()==HSSFCell.CELL_TYPE_NUMERIC)\n        try {\n          float val = (float)cell.getNumericCellValue();\n          if(val!=(float)((int)val)) return false;\n\t} catch (NumberFormatException exc) {return false;}\n      }\n    }\n    return true;\n  }\n",
    "67081": "  public ASTXMLObject nextXML() throws ExecuteException {\n    currentChildIndex++;\n    if(currentChildIndex<(bufStart+buffer.size()))\n      return (ASTXMLObject) buffer.get(currentChildIndex+bufStart);\n    else \n      try{return parseXML();}\n      catch (XMLException exc) {\n        if(onerror==null) throw exc;\n        else {\n          onerror.executeWithExc(exc,\n              \"Caught XML exception while parsing \"+fileName);\n          return null;\n        }\n      }\n  }\n",
    "67085": "  public void initParser() throws ExecuteException {\n    bufStart = -1;\n    buffer.removeAllElements();\n    getCaller().trace.debug(\"*** Parsing \"+fileName+\" header...\");\n    FileReader fileReader;\n    // TBD: set encoding\n    try {fileReader = new FileReader(fileName);}\n    catch (FileNotFoundException exc) {\n      throw new ExecuteException(\"File not found: \"+fileName);}\n    parser = new Parser(fileReader);\n    // parse header\n    try {\n      boolean allowDSQL = allowDSQL();\n      root = parser.XMLHeader(allowDSQL,allowDSQL);\n      // TBD: detect empty document, i.e. <doc/>\n    } catch (ParseException exc) {\n      throw new XMLException(fileName,exc);\n    } catch (TokenMgrError exc) {\n      throw new XMLException(fileName,exc);\n    }\n  }\n",
    "67140": "  public String getString() throws ExecuteException {\n    if(getColumnCount()==0) return null;\n    if(currentRecord()>1) reset();\n    if(currentRecord()==0) \n      if(!nextRecord()) return null;\n    return getColumnString(1);\n  }\n",
    "67178": "  protected int findColumn(String label) throws ExecuteException {\n    Integer i = (Integer) columnLabels.get(label);\n    if(i!=null) return i.intValue();\n    else throw new ExecuteException(\"No column \"+label+\" in results\");\n  }\n",
    "67180": "    public void clearSelection() {\n        checkWidget();\n        clearSelectionWithoutRedraw();\n        m_FocusCol = -1;\n        m_FocusRow = -1;\n        if (isMultiSelectMode())\n            redraw();\n    }\n",
    "67193": "    protected boolean toggleSelection(int col, int row) {\n\n        if (isMultiSelectMode()) {\n            Object o;\n            if (isRowSelectMode()) {\n                o = new Integer(row);\n            } else {\n                o = new Point(col, row);\n            }\n            if (m_Selection.get(o) != null) {\n                m_Selection.remove(o);\n                return false;\n            } else {\n                m_Selection.put(o, o);\n                return true;\n            }\n        }\n        return false;\n    }\n",
    "67203": "    protected void addToSelectionWithoutRedraw(int col, int row) {\n        if (isMultiSelectMode()) {\n            if (isRowSelectMode()) {\n                Integer o = new Integer(row);\n                m_Selection.put(o, o);\n            } else {\n                Point o = new Point(col, row);\n                m_Selection.put(o, o);\n            }\n        }\n    }\n",
    "67213": "    public void setSelection(int col, int row, boolean scroll) {\n        checkWidget();\n        if (col < m_Model.getColumnCount()\n                && col >= m_Model.getFixedHeaderColumnCount()\n                && row < m_Model.getRowCount()\n                && row >= m_Model.getFixedHeaderRowCount()) {\n            focusCell(col, row, 0);\n            if (scroll) {\n                scrollToFocus();\n            }\n        }\n    }\n",
    "67216": "  protected int findColumn(String label) throws ExecuteException {\n    if(cachedLabels!=null && cachedLabels.get(label)!=null)\n      return ((Integer)cachedLabels.get(label)).intValue();\n    else {\n      if(rs==null) // not sure this can ever happen \n        throw new ExecuteException(\"No SQL results\");\n      try {return rs.findColumn(label);}\n      catch (SQLException exc) {throw new ExecuteException(\n        \"Column \"+label+\" does not exist in results\");}\n    }\n  }\n",
    "67233": "    public boolean isCellSelected(int col, int row) {\n        checkWidget();\n        Point v = getValidCell(col, row);\n        col = v.x;\n        row = v.y;\n        if (!isMultiSelectMode()) {\n            if (isRowSelectMode())\n                return (row == m_FocusRow);\n            return (col == m_FocusCol && row == m_FocusRow);\n        }\n\n        if (isRowSelectMode())\n            return (m_Selection.get(new Integer(row)) != null);\n        else\n            return (m_Selection.get(new Point(col, row)) != null);\n    }\n",
    "67241": "    public boolean isRowSelected(int row) {\n        return (m_Selection.get(new Integer(row)) != null);\n    }\n",
    "67255": "  public Object getField(String name) throws ExecuteException {\n    if(name.equals(\"start\")) return new IntValue(start);\n    if(name.equals(\"end\")) return new IntValue(end);\n    return super.getField(name);\n  }\n",
    "67321": "    private boolean highlightSelectedRowCol(int col, int row) {\n        if (!isHighlightSelectionInHeader() || !isHeaderCell(col, row))\n            return false;\n        \n        Point[] sel = getCellSelection();\n        if (sel!=null) {\n            for (int i=0; i<sel.length; i++) {\n                if (sel[i].x == col || sel[i].y == row) \n                    return true;\n                Point valid = getValidCell(sel[i].x, row);\n                if (valid.x == col) return true;\n                valid = getValidCell(col, sel[i].y);\n                if (valid.y == row) return true;\n            }\n        }\n        return false;\n    }\n",
    "67364": "    public void setModel(KTableModel model) {\n        checkWidget();\n        m_Model = model;\n        m_FocusCol = -1;\n        m_FocusRow = -1;\n        clearSelectionWithoutRedraw();\n        \n        // implement autoscrolling if needed:\n        if ((getStyle() & SWTX.AUTO_SCROLL) == SWTX.AUTO_SCROLL)\n            updateScrollbarVisibility();\n        \n        redraw();\n        // TODO add KTable as listener to KModel...\n        if (m_Model != null) {\n        \tSystem.out.println(\"KTable added as listener to KTableModel...\");\n        \tm_Model.addModelChangeListener(this);\n        }\n    }\n",
    "67396": "    public KTableModel getModel() {\n        return m_Model;\n    }\n",
    "67402": "  public Object getType(Class cl) throws ExecuteException {\n    if(cl==String.class) return getString();\n    if(cl==Boolean.class) return new Boolean(getBoolean());\n    if(cl==Integer.class) return new Integer(getInt());\n    if(cl==Float.class) return new Float(getFloat());\n    if(cl==RecordHolder.class) return getRecordHolder();\n    if(cl==XmlElement.class) return getXmlElement();\n    if(cl==ASTXMLObject.class) return getASTXML();\n    throw new ExecuteException(\"Cannot convert \"+this.toString()+\n\t\t\t       \" to \"+cl);\n  }\n",
    "67404": "  public Class getObjectClass() {\n    return getClass();\n  }\n",
    "67405": "  public Object getField(String name) throws ExecuteException {\n    try {\n      return getValue(getClass().getField(name).get(this));\n    } catch (NoSuchFieldException exc) {\n      StringBuffer available = new StringBuffer(\"Valid fields are: \");\n      boolean first = true;\n      for (Enumeration e=getFieldsEnumeration(); e.hasMoreElements();) {\n        available.append((first?\"\":\",\")+e.nextElement());\n        first = false;\n      }\n      throw new ExecuteException(\"Field '\"+name+\"' does not exist. \"\n                               +(first?\"No fields defined.\":available.toString()));\n    } catch (IllegalAccessException exc) {\n      throw new ExecuteException(\"Field '\"+name+\"' cannot be accessed\",exc);\n    }\n  }\n",
    "67409": "  public Enumeration getFieldsEnumeration() {\n    Field[] fields = getClass().getFields();\n    Vector v = new Vector();\n    for(int i=0; i<fields.length; i++) v.add(fields[i].getName());\n    return Collections.enumeration(v);\n  }\n",
    "67432": "  public Object getField(String name) throws ExecuteException {\n    return getColumn(name);\n  }\n",
    "67441": "    protected int getFixedColumnCount() {\n        return m_Model.getFixedHeaderColumnCount()+m_Model.getFixedSelectableColumnCount();\n    }\n",
    "67494": "  public void reset() throws ExecuteException {\n      if(currentIndex==0) return;\n      else throw new ExecuteException(\"Unable to reset Enum value\");\n  }\n",
    "67526": "    protected int getFixedRowCount() {\n        return m_Model.getFixedHeaderRowCount()+m_Model.getFixedSelectableRowCount();\n    }\n",
    "67554": "  public void highlight(String pattern) {\n    // First remove all old highlights\n    try {\n      Highlighter hilite = getHighlighter();\n      Document doc = getDocument();\n      String text = doc.getText(0, doc.getLength());\n      int pos = 0;\n      // Search for pattern\n      while ((pos = text.indexOf(pattern, pos)) >= 0) {\n\t// Create highlighter using private painter and apply around pattern\n\thilite.addHighlight(pos, pos+pattern.length(), findHighlightPainter);\n\tpos += pattern.length();\n      }\n    } catch (BadLocationException e) {\n    }\n  }\n",
    "67555": "  public void removeHighlights() {\n    Highlighter hilite = getHighlighter();\n    Highlighter.Highlight[] hilites = hilite.getHighlights();  \n    for (int i=0; i<hilites.length; i++) {\n      if (hilites[i].getPainter() == findHighlightPainter) {\n\thilite.removeHighlight(hilites[i]);\n      }\n    }\n  }\n",
    "67572": "  public boolean abortOpen() {\n    if(unsavedEdits()) {\n      // bring up save dialog\n      int i=gui.chooseYesNoCancel(\"Save changes to \"+\n\t\t\t      (fileName==null?\"buffer\":fileName)+\n\t\t\t      \"?\",\"Unsaved\");\n      if(i==JOptionPane.CANCEL_OPTION) return true;\n      if(i==JOptionPane.YES_OPTION) {\n\tif(fileName!=null) saveFile(fileName);\n\telse if(!saveDialog()) return true;\n      }\n    }\n    return false;\n  }\n",
    "67606": "  public void addStackValue(Value v) {\n    if(getGui()!=null) getGui().addReturnValue(v);\n  }\n",
    "67639": "  protected ConnectStmt openConnection() throws ExecuteException {\n    try {\n      if(driverClass!=null) Class.forName(driverClass);\n      getCaller().trace.sql(\"Connecting to \"+conurl);\n      Connection con = \n        DriverManager.getConnection(conurl,userName.getUserName(),\n        \t                    password.getPassword());\n      ConnectStmt conStmt = new ConnectStmt(con);\n      SQLconns.addElement(conStmt);\n      setMetadata();\n      return conStmt;\n    } catch (ClassNotFoundException exc) {\n      throw new ExecuteException(\"Unable to use driver \"+getDriverId()+\n        \": class \"+driverClass+\" could not be found.\");\n    } catch (SQLException exc) {\n      throw new ExecuteException(\"Unable to establish connection to '\"+\n        getId()+\"': \"+exc.getMessage(),exc);\n    }\n  }\n",
    "67646": "   public void stopMasking() {\n      this.stop = true;\n   }\n",
    "67647": "    public boolean hasMoreElements() {\n        if (hasMore)\n            hasChecked = hasMore = e1.hasMoreElements();\n        return hasMore ? true : e2.hasMoreElements();\n    }\n",
    "67648": "    public Object nextElement() {\n        if (hasMore && !hasChecked)\n            hasMore = e1.hasMoreElements();\n\thasChecked = false;\n        return hasMore ? e1.nextElement() : e2.nextElement();\n    }\n",
    "67669": "  protected int priority() {\n    return Integer.MAX_VALUE;\n  }\n",
    "67718": "  public void addVariable(Variable var) {\n    ((Hashtable)vars.elementAt(vars.size()-1)).put(var.getName(),var);\n    getCaller().trace.debug(\"Added \"+var+\" to the current variable context\");\n  }\n",
    "67719": "  public void setVariable(String name, Value value) throws ExecuteException {\n    Variable var;\n    try { var = getVariable(name); }\n    catch (VarNotSetException exc) { \n      var = new Variable(name);\n      addVariable(var); \n    }\n    var.setValue(value);\n  }\n",
    "67810": "  public String getXMLText() throws ExecuteException {\n    String r = \"\";\n    // TBD: should start from attributes?\n    for(int i=0; i<jjtGetNumChildren(); i++)\n      if(children[i] instanceof ASTXMLObject &&\n         !(children[i] instanceof ASTXMLAttribute))\n        r = r+((ASTXMLObject)children[i]).getXMLText();\n    return r;\n  }\n",
    "67862": "  public void updateCursorPos(int line, int col) {\n    caretPos.setText(\"\"+line+\":\"+col);\n  }\n",
    "67892": "  public Value executeWithCatch() throws ExecuteException {\n    if(getCaller().hasRequestToStop()) \n      throw new StopException();\n    try {return execute();}\n    catch (ExecuteException exc) {\n      if(exc.getNode()==null) exc.setNode(this); \n      throw exc;\n    }\n  }\n",
    "67954": "  public ASTXMLObject executeXML() {\n    return this;\n  }\n",
    "68115": "   public Food findIdenticalFood(Food f) {\n      Iterator iter = map.values().iterator();\n      while (iter.hasNext()) {\n         FoodProxy food = (FoodProxy)iter.next();\n         if (food.getDescription().equals(f.getDescription())) {\n            if (food.getFood().equals(f)) {\n               return food.getFood();\n            }\n         }\n      }\n      return null;\n   }\n",
    "68207": "   private String fixString(String str) {\n      //return \"<html><div align=\\\"center\\\">\" + str + \"</div></html>\";\n      if (str.length() > 53) {\n         return str.substring(0, 50)+\"...\";\n      } else {\n         return str;\n      }\n   }\n",
    "68213": "   private void createFile() {\n      for (Iterator iter = Biomarker.createPredefinedBiomarkers().iterator(); iter.hasNext();) {\n         Biomarker biomarker = (Biomarker) iter.next();\n         addBiomarker(biomarker);\n      }\n      save();\n   }\n",
    "68215": "   private void createDataset() {\n      actualData = new TimeSeries(metricName, Day.class);\n      dataset = new TimeSeriesCollection();\n      getData();\n      dataset.addSeries(actualData);\n   }\n",
    "68229": "   public int compareTo(Object object) {\n      return date.compareTo(((Metric)object).getDate());\n   }\n",
    "68297": "   public void addFood(NutrientTable toAdd, double weight) {\n      for (int i = 0; i < nutrients.length; i++) {\n         nutrients[i] += toAdd.getAmount(i) * weight;\n      }\n   }\n",
    "68319": "    public void update() {\n       UserManager.getCurrentUser().getFoodHistory().update(this);\n        //lds.changeServingAmount(this);\n    }\n",
    "68342": "   public void setMeasure(String measureName) {\n      if (food == null) return;\n      List measures = getFoodProxy().getFood().getMeasures();\n      for (int i=0; i<measures.size(); i++) {\n         Measure m = (Measure)measures.get(i);\n         if (m.getDescription().equals(measureName)) {\n            setMeasure(m);\n            return;\n         }\n      }\n      // if nothing found, default to GRAMS\n      setMeasure(Measure.GRAM);\n   }\n",
    "68372": "   public String getDescription() {\n      return description;\n   }\n",
    "68373": "   public void setFood(Food f) {\n      measures.setModel(new DefaultComboBoxModel(f.getMeasures().toArray()));\n      curMeasure = Measure.GRAM;\n      fireChangeEvent();\n   }\n",
    "68375": "   public void setDescription(String text) {\n      description = text;\n      setDirty(true);\n   }\n",
    "68376": "   public void setMeasure(Measure w, double mult) {\n     // measures.setSelectedItem(w);\n      for (int i=0; i<measures.getItemCount(); i++) {\n         Measure m = (Measure)measures.getItemAt(i);\n         if (m.equals(w)) {\n            measures.setSelectedIndex(i);\n            break;\n         }\n      }\n      multiplier.setValue(mult);\n      fireChangeEvent();\n   }\n",
    "68377": "   public List getMeasures() {\n      if (measures == null) {\n         measures = new ArrayList();\n         measures.add(Measure.GRAM);\n      }\n      return measures;\n   }\n",
    "68378": "   public void updateMeasure() {\n      Measure w = getSelectedMeasure();     \n      if (linked) {\n         double mult = w.getAmount();\n         if (curMeasure != null) {\n            double grams = curMeasure.getGrams() * multiplier.getValue();\n            mult = grams/w.getGrams();\n         }\n         multiplier.setValue(mult);\n      }\n      setFocus();\n      curMeasure = w;\n      fireChangeEvent();\n   }      \n",
    "68380": "   public double getMultiplier() {\n      return getGrams() / 100.0;\n   }\n",
    "68381": "   public void setMeasures(List measures) {\n      this.measures = measures;\n      setDirty(true);\n   }\n",
    "68382": "   public double getGrams() {\n      Measure w = getSelectedMeasure();\n      if (w != null) {\n         return multiplier.getValue() * w.getGrams();// * (1.0/w.getAmount()); \n      }\n      return 0;\n   }\n",
    "68383": "   public boolean hasDataFor(NutrientInfo ni) {\n        if (ni == null) return false;\n        return getNutrients().dataExists(ni.getIndex());         \n    }\n",
    "68386": "   public double getNutrientAmount(NutrientInfo ni) {\n        if (ni == null) return 0;\n        return getNutrients().getAmount(ni.getIndex());         \n    }\n",
    "68388": "   public void setNutrientAmount(NutrientInfo ni, double val) {\n      getNutrients().setAmount(ni.getIndex(), val);        \n      setDirty(true);\n   }\n",
    "68401": "   public void addServings(Serving[] list) {\n      addServingsToUser(list, UserManager.getCurrentUser(), CRONOMETER.getDailySummary().getDate());\n   }\n",
    "68402": "   public void itemStateChanged(ItemEvent e) {\n      updateMeasure();\n   }\n",
    "68403": "   public void actionPerformed(ActionEvent e) {\n      fireChangeEvent();\n      fireActionEvent();\n      //Toolkit.getDefaultToolkit().beep();\n   }\n",
    "68410": "   public String getSourceUID() {\n      return sourceUID;\n   }\n",
    "68411": "   public void keyReleased(KeyEvent e) {\n      //System.out.println(\"keyReleased: \" + e);\n      fireChangeEvent();\n   }\n",
    "68413": "   public void setSourceUID(String uid) {\n      sourceUID = uid;\n      setDirty(true);\n   }\n",
    "68415": "   public boolean isLinked() {\n      return linked;\n   }\n",
    "68416": "   public void setComment(String comment) {\n      this.comment = comment;\n      setDirty(true);\n   }\n",
    "68418": "   public void setLinked(boolean linked) {\n      this.linked = linked;\n   }\n",
    "68419": "   public String getComment() {\n      return comment;\n   }\n",
    "68433": "   public boolean equals(Food f) {\n      if (!f.getDescription().equals(getDescription())) return false;\n      List nutrients = NutrientInfo.getGlobalList();\n      for (int i=0; i<nutrients.size(); i++) {\n         NutrientInfo ni = (NutrientInfo)nutrients.get(i);\n         if (f.getNutrientAmount(ni) != getNutrientAmount(ni)) {\n            return false;\n         }\n      }\n      return true;\n   }\n",
    "68453": "   public Component customRender(Component c, PrettyTable table, int row, int col) {\n      Serving s = getServing(row);\n      if (s != null) {\n         if (s.getFoodProxy().isDeprecated()) {\n            c.setForeground(Color.LIGHT_GRAY);               \n         } else if (col == 0) {\n            c.setForeground(s.getFoodProxy().getSource().getDisplayColor());               \n         } else {\n            c.setForeground(Color.BLACK);\n         }\n      }\n      return c;\n   }\n",
    "68457": "   private void setMeasureBox(Serving s) {\n      if (s != null) {\n         measureBox.removeAllItems();\n         List measures = s.getFood().getMeasures();\n         for (int i=0; i<measures.size(); i++) {\n            measureBox.addItem(measures.get(i));\n         }\n         measureBox.setSelectedItem(s.getMeasure());\n      }\n   }\n",
    "68461": "   public void updateOriginal() {\n      original.copy(food);\n      original.update();\n   }\n",
    "68472": "    public double getAmount() {\n        return amount;\n    }\n",
    "68474": "    public void setAmount(double amount) {\n        this.amount = amount;\n    }\n",
    "68477": "    public void setDescription(String description) {\n        this.description = description;\n    }\n",
    "68478": "    public double getGrams() {\n        return grams;\n    }\n",
    "68480": "    public void setGrams(double grams) {\n        this.grams = grams;\n    }\n",
    "68523": "   public void doPrint() {\n      try {         \n         MessageFormat headerFormat = new MessageFormat(getTitle());\n         MessageFormat footerFormat = new MessageFormat(\"- {0} -\");\n         getTable().print(JTable.PrintMode.FIT_WIDTH, headerFormat, footerFormat);          \n      } catch (PrinterException e) {\n         e.printStackTrace();\n         JOptionPane.showMessageDialog(this, e.getMessage());\n      }\n   }     \n",
    "68552": "   private void recomputeNutrients() {\n      double total = getTotalGrams();\n      \n      Iterator iter = NutrientInfo.getGlobalList().iterator();\n      while (iter.hasNext()) {\n         NutrientInfo ni = (NutrientInfo)iter.next();\n         setNutrientAmount(ni, getAmount(ni, total));\n      }\n      \n      recomputeFactors();\n      \n      boolean found = false;\n      List list = getMeasures();      \n      for (int i=0; i<list.size(); i++) {\n         Measure m = (Measure)list.get(i);\n         if (m.getDescription().equals(\"full recipe\")) {\n            m.setGrams(total);\n            found = true;\n         }\n      }\n      if (!found) {\n         getMeasures().add( new Measure(1.0, \"full recipe\", total) );\n      }\n      //update();\n   }\n",
    "68556": "   private double getAmount(NutrientInfo ni, double totalGrams) {\n      double total = 0;\n      for (Iterator iter = getServings().iterator(); iter.hasNext();) {\n         Serving serving = (Serving) iter.next();\n         if (serving.getFood() != null) {\n            double weight = (serving.getGrams()/totalGrams);\n            total += weight * serving.getFood().getNutrientAmount(ni);\n         }\n      }\n      return total;\n   }\n",
    "68563": "   public void updateOriginal() {\n      ((Recipe)original).copy(getRecipe());\n      original.update();\n   }\n",
    "68564": "   public boolean isSparseData() {\n      return sparse;\n   }\n",
    "68601": "   public User getLastUser() {\n      User user = getUser(getLastUsername());\n      if (user == null) {\n         user = getUserList().get(0);\n      }\n      return user;\n   }\n",
    "68615": "   public void addUser(JComponent parentWindow) {\n      User user = new User(new Settings(Settings.TAG_USER));\n      setCurrentUser(user);\n      addUser(user);\n      user.doFirstRun(parentWindow);\n      settings.save();\n   }\n",
    "68621": "   public void addUser(User user) {\n      userList.add(user);\n      settings.save();\n   }\n",
    "68626": "   public User getUser(String username) {\n      return getUser(getUserList(), username);\n   }\n",
    "68631": "   public void deleteUser(User user) {\n      userList.remove(user);\n      deleteFiles(user);\n      if (currentUser == user) {\n         // Make sure we select a new currentUser, find the first active user\n         setCurrentUser(getUserList().get(0));\n      }\n      settings.save();\n   }\n",
    "68635": "   public void deleteFiles(User user) {\n      File userDir = getUserDirectory(user);\n      if (userDir.exists()) {\n         int i;\n         for (i=0; i<userFileList.length; i++) {\n            File userFile = new File(userDir.getAbsolutePath(), userFileList[i]);\n            if (userFile.exists()) {\n               if (!userFile.delete()) {\n                  Logger.error(\"Unable to delete the file: \" + userFile.getAbsolutePath());\n               }\n            }\n         }\n         if (!userDir.delete()) {\n            Logger.error(\"Unable to delete the folder: \" + userDir.getAbsolutePath());\n         }\n      }\n   }\n",
    "68641": "   public boolean deleteUser(String username) {\n      User user = getUser(username);\n      if (userExists(username)) {\n         deleteUser(user);\n         return true;\n      }\n      return false;\n   }\n",
    "68649": "   public boolean setCurrentUser(String username) {\n      User user = getUser(username);\n      if (user != null) {\n         setCurrentUser(user);\n         return true;\n      } else {\n         return false;\n      }\n   }\n",
    "68660": "   public int getAge() {\n      if (null != getBirthDate()) {\n         return getAge(getBirthDate());\n      }\n      return 0;\n   }\n",
    "68746": "   private void deleteSelectedUser(int row) {\n      String username = (String)userListModel.get(row);\n      \n      if ( ! isOkToDeleteUser()) {\n         return;\n      }\n      \n      if (userListModel.size() == 1) {\n         Logger.error(\"Not allowed to delete last user.\");\n         return;\n      }\n      if (!userMan.deleteUser(username)) {\n         Logger.error(\"Unable to delete user.\");\n         return;\n      }\n      userListModel.remove(row);\n      selectCurrentUser();\n      setDirty(true);\n   }\n",
    "68754": "   public void selectDefaultUser() {\n      userList.setSelectedValue(UserManager.selectOtherUser().getUsername(), true);   \n   }\n",
    "68759": "   public void selectCurrentUser() {\n      userList.setSelectedValue(UserManager.getCurrentUser().getUsername(), true);   \n      if (userListModel.getSize() == 1) {\n         delBtn.setEnabled(false);\n      }\n   }\n",
    "68774": "   public double getTargetCompletion(boolean average) {\n      double total = 0;\n      double value = 0;\n      double valueFull = 0; \n      \n      Iterator iter = getNutrientList().iterator();\n      while (iter.hasNext()) {\n         NutrientInfo ni = (NutrientInfo)iter.next();\n         Target target = UserManager.getCurrentUser().getTarget(ni);\n         if (target.getMin() > 0 && UserManager.getCurrentUser().isTracking(ni)) {\n            double amount = getNutrientTable().getAmount(ni);\n            valueFull += amount/target.getMin();\n            if (amount < target.getMin()) {\n               value += amount/target.getMin();\n            } else {\n               value++;\n            }\n            total++;\n         }\n      }\n      if (average) {\n         return valueFull/total;\n      } else {\n         return value / total;\n      }\n   }\n",
    "68851": "   public void initUserData() {\n      getFoodHistory();\n      getNotesHistory();\n      getBiometricsHistory();\n   }\n",
    "68906": "   public void saveUserData() {\n      getFoodHistory().save();\n      getBiometricsHistory().save();\n      getNotesHistory().save();\n      getExerciseHistory().save();\n   }\n",
    "68918": "   public double getTargetCompletion(List servings, List nutrients, int days, boolean average) {\n      double total = 0;\n      double value = 0;\n      double valueFull = 0; \n      \n      Iterator iter = nutrients.iterator();\n      while (iter.hasNext()) {\n         NutrientInfo ni = (NutrientInfo)iter.next();\n         Target target = UserManager.getCurrentUser().getTarget(ni);\n         if (target.getMin() > 0 && UserManager.getCurrentUser().isTracking(ni)) {\n            double amount = getAmount(servings, ni) / (double) days;\n            valueFull += amount/target.getMin();\n            if (amount < target.getMin()) {\n               value += amount/target.getMin();\n            } else {\n               value++;\n            }\n            total++;\n         }\n      }\n      if (average) {\n         return valueFull / total;\n      } else {\n         return value / total;\n      }\n   }\n",
    "69072": "   public void focusLost(FocusEvent e) {\n      if (curDate != null) {\n         saveCurrentNote(); \n      }\n   }\n",
    "69106": "   public Component customRender(Component c, PrettyTable table, int row, int col) {\n      Exercise s = getExercise(row);\n      if (s != null) {\n         c.setForeground(Color.BLACK);\n      }\n      return c;\n   }\n",
    "69119": "   public void doDBSearch() {\n      Object sel = getSourceBox().getSelectedItem();\n      if (sel instanceof FoodDataSource) {\n         doDBSearch((FoodDataSource)sel);\n      } else {\n         doDBSearch(null);\n      }\n   }\n",
    "69156": "   public void restoreWindow() {\n      setVisible(true);\n      setExtendedState(Frame.NORMAL);\n      toFront();\n   }\n",
    "69168": "   public void goToToday() {\n      setDate(new Date(System.currentTimeMillis()), false);\n   }\n",
    "69174": "   private void copyPreviousDay() {\n//      if (isOkToAddServings(curDate)) {\n\t   Date previousDay = new Date(curDate.getTime() - ONE_DAY);\n      UserManager.getCurrentUser().getFoodHistory().copyConsumedOn(previousDay, curDate);\n\t   notifyObservers();\n//      }\n   }\n",
    "69192": "      public Component customRender(Component c, PrettyTable table, int row, int col) {\n         FoodProxy f = getSearchHit(row).getFoodProxy();\n         if (f != null) {\n            if (col == 0) {\n               c.setForeground(f.getSource().getDisplayColor());\n               if (f.isDeprecated()) {\n                  c.setForeground(Color.LIGHT_GRAY);\n               }\n            }\n         }\n         return c;\n      }\n",
    "69198": "   public void update() {\n      UserManager.getCurrentUser().getExerciseHistory().update(this);\n   }\n",
    "69207": "   public void addExercises(Exercise[] list) {\n      addExercisesToUser(list, UserManager.getCurrentUser(), CRONOMETER.getDailySummary().getDate());\n   }\n",
    "69234": "   public void setDate(Date d, boolean userChanged) {\n      curDate = d;      \n      // getDateTitle().setDate(curDate);\n      getDateTitle().setText(df.format(curDate));\n      validate();\n      getBioMarkersPanel().setDate(d);\n      getServingTable().setTitle(df.format(curDate));\n      if (!userChanged) {\n         getNotesEditor().saveCurrentNote(); \n      }\n      getNotesEditor().setDate(d);\n      asked = false;\n      refreshTime();\n      notifyObservers();\n   }\n",
    "69318": "   public void reload() {\n      load();\n   }\n",
    "69347": "   public Component customRender(Component c, PrettyTable table, int row, int col) {\n      //Record entry = getUserEntry(row);\n      return c;\n   } \n",
    "69454": "   public void addEntries(Record[] list) {\n      for (int i=0; i<list.length; i++) {\n         add(list[i].copy());\n      }\n   }\n",
    "69485": "    public void removeLayoutComponent(Component comp) {\n        compTable.remove(comp);\n    }\n",
    "69504": "    public Dimension minimumLayoutSize(Container parent) {\n    \tint ncomponents = parent.getComponentCount();\n\t\tif (ncomponents == 0) return new Dimension(1,1);\n\t\tRectangle totalRect = new Rectangle(0,0,1,1);\n\t\tfor ( int i = 0; i < ncomponents; i++ ) {\n\t\t\tComponent c = parent.getComponent(i);\n\t\t\tSpazPosition lp = (SpazPosition)compTable.get(c);\n         Rectangle rect = lp.getMinRectangle();\n         if ( rect != null ) \n         \ttotalRect = totalRect.union(rect); \n\n\t\t}\n\t\treturn new Dimension(totalRect.width,totalRect.height);\n    }\n",
    "69515": "    public void addLayoutComponent(Component comp, Object constraints) {\n        if (constraints instanceof SpazPosition) {\n            SpazPosition cons = (SpazPosition)constraints;\n            setConstraints(comp, cons);\n        } else if (constraints != null) {\n            throw new IllegalArgumentException(\n                \"cannot add to layout: constraint must be a SpazPostion\");\n        }\n    }\n",
    "69519": "    public Dimension maximumLayoutSize(Container target) {\n        return new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);\n    }\n",
    "69523": "    public float getLayoutAlignmentX(Container target) {\n        return 0.5f;\n    }\n",
    "69527": "    public float getLayoutAlignmentY(Container target) {\n        return 0.5f;\n    }\n",
    "69530": "    public void invalidateLayout(Container target) {\n        // Do nothing\n    }\n",
    "69551": "   public Component customRender(Component c, PrettyTable table, int row, int col) {\n      return c;\n   }\n",
    "69578": "   public void showWindow() {\n      setVisible(true); \n      toFront();\n   }\n",
    "69601": "   public void setExternal(boolean val) {\n      external = val;\n   }\n",
    "69606": "   public Object newInstance(String name) {\n      try {\n         Class c = this.loadClass(name, true);\n         return c.newInstance();\n      } catch (Exception e) {\n         e.printStackTrace();\n      }\n      return null;\n   }\n",
    "69631": "   public long getBytesRead() {\n      return bytesRetrieved;\n   }\n",
    "69634": "   public String getKey() {\n      return key;\n   }\n",
    "69636": "   public String getNewValue() {\n      return newValue;\n   }\n",
    "69659": "   public SQLColumnSet getColumns() {\n      return cols;\n   }\n",
    "69660": "    public void addWhere(String name, Object val) {\n        addWhere(name, EQ, val);\n    }\n",
    "69676": "    public void addWhereLike(String name, String val) {\n        where.add(\"upper(\" + name + \") like '\"\n                + escape(val.toString()).toUpperCase() + \"' \");\n    }\n",
    "69689": "    public void addSelection(String field) {\n        items.add(field);\n    }\n",
    "69692": "    protected ResultSet doExecuteQuery(Connection con) throws SQLException {\n        Statement stmt = con.createStatement();\n        String query = this.getQueryString();\n        if (Logger.isDebugEnabled()) {\n           Logger.debug(\"executeQuery() - Statement to be executed: \" + query);\n        }\n\n        results = stmt.executeQuery(query);\n        return results;\n    }\n",
    "69695": "   public void setPrintNewLines(boolean b) {\n      printNewLines  = b;\n      Iterator iter = children.iterator();\n      while (iter.hasNext()) {\n         ((XMLNode)iter.next()).setPrintNewLines(b);\n      }\n   }\n",
    "69701": "   protected String getQueryString() {\n      StringBuffer sb = new StringBuffer();\n      sb.append(\"UPDATE \");\n      sb.append(getTableName());\n      sb.append(\" SET \");\n      List names = cols.getNames();\n      List terms = cols.getValues();\n      for (int i=0; i<names.size(); i++) {         \n         Object name = names.get(i);\n         Object term = terms.get(i);\n         if (term == null) {\n            term = \"NULL\"; \n         }\n         sb.append(name.toString());\n         sb.append(\" = '\");\n         sb.append(escape(term.toString()));\n         sb.append(\"' \");\n         if (i < names.size() - 1) {\n            sb.append(\", \");\n         }\n      }\n      sb.append(getWhere());\n      return sb.toString();\n   }\n",
    "69706": "   protected String getQueryString() {\n      StringBuffer sb = new StringBuffer();\n      sb.append(\"DELETE FROM \");\n      sb.append(getTableName());\n      sb.append(getWhere());\n      return sb.toString();\n   }\n",
    "69730": "   public void setHgap(int hgap) {\n       this.hgap = hgap;\n   }\n",
    "69735": "   public int getVgap() {\n       return vgap;\n   }\n",
    "69757": "   public void setVgap(int vgap) {\n       this.vgap = vgap;\n   }\n",
    "69767": "   public void removeLayoutComponent(Component comp) {\n      constraints.remove(comp);\n   }\n",
    "69866": "    public DistributorMO setEndPoint(Location endPoint) {\n        this.endPoint = endPoint;\n        return this;\n    }\n",
    "70192": "    public void menuVJBTreeClear() {\n        menuSetDMT.removeAllChildren();\n        menuVJBTreeModel.reload();\n    }\n",
    "70311": "    public void menuVJBTreeRemoveCurrentNode() {\n        TreePath currentSelection = menuVJBTree.getSelectionPath();\n        if (currentSelection != null) {\n            DefaultMutableTreeNode currentNode = \n                    (DefaultMutableTreeNode)\n                    (currentSelection.getLastPathComponent());\n            MutableTreeNode parent = \n                    (MutableTreeNode)(currentNode.getParent());\n            if (parent != null) {\n                menuVJBTreeModel.removeNodeFromParent(currentNode);\n                return;\n            }\n        } \n        // Either there was no selection, or the root was selected.\n    }\n",
    "70455": "    public DefaultMutableTreeNode menuVJBTreeAddObject(Object child) {\n        DefaultMutableTreeNode parentNode = null;\n        TreePath parentPath = menuVJBTree.getSelectionPath();\n        if (parentPath == null) {\n            parentNode = menuSetDMT;\n        } else {\n            parentNode = (DefaultMutableTreeNode)\n                 (parentPath.getLastPathComponent());\n        }\n        return menuVJBTreeAddObject(parentNode, child, true);\n    }\n",
    "70493": "    public TimeLimit timeLimit(TickTock tickTock) {\n        return new TimeLimit(this, tickTock);\n    }\n",
    "70817": "    public TimeSpan approximate(TimeUnit unit) {\n        long nanos = nanoTime();\n        long tenths = (long)Math.floor(Math.log10(nanos));\n        for (int i = 0; ; i++) {\n            int exp = (i + 1) * 3;\n            if (tenths < exp || i == 3 || unit == UNITS[i]) {\n                long div = (long)Math.pow(10, exp - 3);\n                long time = nanos / div;\n                return new TimeSpan(time, UNITS[i]);\n            }\n        }\n    }\n",
    "70823": "    public TimeSpan approximate() {\n        return approximate(null);\n    }\n",
    "70872": "    public boolean isWrapped() {\n        return this.wrappedValue != null;\n    }\n",
    "70880": "    public Object getValueString() {\n        return this.valueString;\n    }\n",
    "70884": "    public Object getTypedValue() {\n        return this.typedValue;\n    }\n",
    "70888": "    public Class getType() {\n        return this.type;\n    }\n",
    "70892": "    public String getTypeName() {\n        return this.typeName;\n    }\n",
    "70898": "    public boolean isPrimitive() {\n        return this.primitive;\n    }\n",
    "70902": "    public Throwable getThrowable() {\n        return this.throwable;\n    }\n",
    "70909": "    protected void writeToBuffer(StringBuffer buffer, int x, boolean indent) {\n        buffer.append(this.getType().getLeft());\n        for (int i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].writeToBuffer(buffer, x + 2, true);\n            if (i < (this.nodes.length - 1)) {\n                buffer.append(\" \");\n            }\n        }\n        buffer.append(this.getType().getRight());\n    }\n",
    "70916": "    public long getEvalTime() {\n        return this.evalTime;\n    }\n",
    "70922": "    public boolean isOK() {\n        return this.throwableType == null;\n    }\n",
    "71014": "    protected void writeToBuffer(StringBuffer buffer, int x, boolean i) {\n        String string = this.isContentString()\n            ? \"\\\"\" + this.getContent() + \"\\\"\"\n            : (this.isContentHolder()\n               ? ((Holder)this.getContent()).toValueString()\n               : String.valueOf(this.getContent()));\n        buffer.append(string);\n    }\n",
    "71023": "    public Object evaluate(Context context) {\n        if (this.isContentSymbol()) {\n            Object value = context.lookup(this.getSymbolContent());\n            if (value == null) {\n                value = Reflector.get().resolveLeafNode(context, this);\n                if (value == null) {\n                    throw new EvaluationException\n                        (\"Unknown symbol or type \" + this.getSymbolContent());\n                }\n            }\n            return value;\n        } else {\n            return this.getContent();\n        }\n    }\n",
    "71705": "    private void addClassNodes() {\n        if (getRealObject() != null) {\n            ClassNode actualClass = new ClassNode(this,\n                                                  getRealObject().getClass(),\n                                                  \"Actual class\");\n            addChild(actualClass);\n        }\n        if (getDeclaredClass() != null) {\n            ClassNode declaredClass = new ClassNode(this,\n                                                    getDeclaredClass(),\n                                                    \"Declared class\");\n            addChild(declaredClass);\n        }\n    }\n",
    "71708": "    private void addFieldListNodes() {\n        for (Class clazz = getActualClass();\n             clazz != null;\n             clazz = clazz.getSuperclass()) {\n            addFieldList(clazz);\n        }\n    }\n",
    "72000": "    public void testMod() {\n        assertEquals(\"Module failed\",\n                     DataHolderFactory.holder(5),\n                     DataHolderFactory.holder(20).mod(DataHolderFactory.holder(15)));\n    }\n",
    "72003": "    public void testMul() {\n        assertEquals(\"Multiplication failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(4).mul(DataHolderFactory.holder(5)));\n        assertEquals(\"Multiplicatio failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(4).mul(DataHolderFactory.holder(5)));\n        assertEquals(\"Multiplication failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(4.0).mul(DataHolderFactory.holder(5.0)));\n        assertEquals(\"Multiplication failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(4.0).mul(DataHolderFactory.holder(5.0)));\n    }\n",
    "72005": "    public void testDiv() {\n        assertEquals(\"Division failed\",\n                     DataHolderFactory.holder(100),\n                     DataHolderFactory.holder(20).mul(DataHolderFactory.holder(5)));\n        assertEquals(\"Division failed\",\n                     DataHolderFactory.holder(100),\n                     DataHolderFactory.holder(20.0).mul(DataHolderFactory.holder(5.0)));\n    }\n",
    "72007": "    public void testSub() {\n        assertEquals(\"Subtraction failed\",\n                     DataHolderFactory.holder(4),\n                     DataHolderFactory.holder(20).sub(DataHolderFactory.holder(16)));\n        assertEquals(\"Subtraction failed\",\n                     DataHolderFactory.holder(4),\n                     DataHolderFactory.holder(20.0).sub(DataHolderFactory.holder(16.0)));\n    }\n",
    "72010": "    public void testAdd() {\n        assertEquals(\"Addition failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(12).add(DataHolderFactory.holder(8)));\n        assertEquals(\"Addition failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(12.0).add(DataHolderFactory.holder(8.0)));\n    }\n",
    "72016": "    public void setUp() {\n    }\n",
    "72020": "    public void tearDown() {\n    }\n",
    "72294": "\tprivate void populateFields() {\n\t\tfields = editDVD.getFields();\n\t\t//We also need to add any extra fields that may have been added later\n\t\tfields = Field.addMissingFields(fields);\n\t\tupdateTabel();\n\t\tif(editDVD.getPoster() == null) {\n\t\t\tposter.setIcon(new ImageIcon(getClass().getResource(\"/org/dvdcatalog/dvdc/images/poster.png\")));\n\t\t}\n\t\telse {\n\t\t\tposter.setIcon(new ImageIcon(editDVD.getPoster()));\n\t\t}\n\t}\n",
    "72310": "\tprivate void saveFields() throws RuntimeException {\n\t\teditDVD.setFields(fields);\n\t}\n",
    "72311": "\tpublic Class getColumnClass(int c) {\n\t\ttry {\n            return super.getColumnClass (c);\n\t\t} catch (NullPointerException e) {\n\t\t\treturn String.class;\n\t\t}\n\t}\n",
    "72313": "\tpublic void setData(Vector v) {\n\t\tdata = v;\n\t\tfireTableDataChanged();\n\t}\n",
    "72323": "\tprivate Component createButtons() {\n\t\tJPanel buttonPane = new JPanel();\n\t\tbuttonPane.setLayout(new GridLayout(1, 3));\n\n\t\tpreviousButton.addActionListener(this);\n\t\tbuttonPane.add(previousButton);\n\n\t\tnextButton.addActionListener(this);\n\t\tbuttonPane.add(nextButton);\n\n\t\tsaveButton.addActionListener(this);\n\t\tsaveButton.setEnabled(false);\n\t\tbuttonPane.add(saveButton);\n\n\t\treturn buttonPane;\n\t}\n",
    "72324": "\tpublic BufferedImage getPoster() {\n\t\treturn poster;\n\t}\n",
    "72326": "\tpublic void run() {\n\t\tif(info != null) {\n\t\t\tinfo.setBar(bar);\n\t\t\tinfo.start();\n\t\t}\n\t\telse if(imdbSearch != null) {\n\t\t\timdbSearch.start();\n\t\t}\n\t}\n",
    "72330": "\tpublic void setTitle(String title) {\n\t\tthis.title = title;\n\t}\n",
    "72340": "\tprivate Component createInputComponents() {\n\t\tcards = new JPanel(new CardLayout());\n\t\tcards.add(createCard1(), \"INPUT\");\n\t\tcards.add(createCard2(), \"SEARCHING\");\n\t\tcards.add(createCard3(), \"LIST\");\n\t\tcards.add(createCard4(), \"RETRIEVING\");\n\t\tcards.add(createCard5(), \"INFO\");\n\t\treturn cards;\n\t}\n",
    "72341": "\tpublic String getDirector() {\n\t\treturn director;\n\t}\n",
    "72342": "\tprivate Component createCard1() {\n\t\tJPanel p = new JPanel();\n\t\tp.setAlignmentX(0.5f);\n\t\tp.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\t\tJLabel l = new JLabel(\"Movie Title: \");\n\t\timdbSearch = new JTextField(20);\n        imdbSearch.addActionListener (this);\n\n\t\tp.add(l);\n\t\tp.add(imdbSearch);\n\n\t\tJPanel toReturn = new JPanel();\n\t\ttoReturn.setLayout(new BoxLayout(toReturn, BoxLayout.PAGE_AXIS));\n\t\ttoReturn.add(createTopTitle(\"Enter a movietitle to search for\", \"Step 1 of 5\"));\n\t\ttoReturn.add(p);\n\n\t\treturn toReturn;\n\t}\n",
    "72345": "\tpublic String getGenre() {\n\t\treturn genre;\n\t}\n",
    "72350": "\tpublic String getTagline() {\n\t\treturn tagline;\n\t}\n",
    "72354": "\tpublic String getPlot() {\n\t\treturn plot;\n\t}\n",
    "72360": "\tpublic String getRating() {\n\t\treturn rating;\n\t}\n",
    "72365": "\tpublic Class getColumnClass(int c) {\n\t\ttry {\n\t\t\treturn getValueAt(0, c).getClass();\n\t\t} catch (NullPointerException e) {\n\t\t\treturn String.class;\n\t\t}\n\t}\n",
    "72366": "\tpublic String getPosterUrl() {\n\t\treturn posterUrl;\n\t}\n",
    "72367": "\tpublic void setData(Vector v) {\n        if (v instanceof SortedVector) data = v;\n        else {\n            data.clear ();\n\n            for (int i = 0; i < v.size (); i++)\n                data.add (v.get (i));\n        }\n\t\tfireTableDataChanged();\n\t}\n",
    "72369": "    public void addMouseListenerToTableHeader (final JTable table) {\n        final MouseAdapter adapter = new MouseAdapter () {\n            public void mouseClicked (final MouseEvent e) {\n                final TableColumnModel columnModel = table.getColumnModel ();\n                final int x = columnModel.getColumnIndexAtX (e.getX ());\n                final int col = table.convertColumnIndexToModel (x);\n\n                if(e.getClickCount () == 1 && col != -1) {\n                    ((SortedVector)data).sortBy (col);\n                    fireTableDataChanged ();\n                }\n            }\n        };\n        table.getTableHeader ().addMouseListener (adapter);\n    }\n",
    "72371": "\tpublic String getAddress() {\n\t\treturn address;\n\t}\n",
    "72385": "    public int compare (final Object o1, final Object o2) {\n        final Object[] a = (Object[])o1, b = (Object[])o2;\n\n        return ((String)a[col]).compareTo (b[col]);\n    }\n",
    "72387": "    public boolean equals (final Object o) {\n        return o instanceof ColumnComparator && ((ColumnComparator)o).col == col;\n    }\n",
    "72389": "\tprivate Component createButtons() {\n\t\tJPanel buttonPane = new JPanel();\n\t\tbuttonPane.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n\t\tbuttonPane.setLayout(new FlowLayout());\n\n\t\tbackButton.addActionListener(this);\n\t\tbackButton.setEnabled(false);\n\t\tbuttonPane.add(backButton);\n\n\t\tnextButton.addActionListener(this);\n\t\tbuttonPane.add(nextButton);\n\n\t\tskipButton.addActionListener(this);\n\t\tbuttonPane.add(skipButton);\n\n\t\tcancelButton.addActionListener(this);\n\t\tbuttonPane.add(cancelButton);\n\n\t\treturn buttonPane;\n\t}\n",
    "72390": "    public boolean add (final Object o) {\n        final ColumnComparator cc = new ColumnComparator (col);\n\n        for (int i = 0; i < size (); i++) {\n            final int res = cc.compare (get (i), o) * (ascending ? 1 : -1);\n            if (res > 0) {\n                add (i, o);\n                return true;\n            }\n        }\n        return super.add (o);\n    }\n",
    "72391": "    public void sortBy (final int col) {\n        if (this.col == col || isSorted (col)) reverse ();\n        else {\n            this.col = col;\n            ascending = true;\n            if (size () > 1) Collections.sort (this, new ColumnComparator (col));\n        }\n    }\n",
    "72393": "    public void reverse () {\n        ascending = !ascending;\n        final int lastIdx = size () - 1;\n\n        for (int i = 0; i < lastIdx; i++)\n            add (i, remove (lastIdx));\n    }\n",
    "72397": "\tprivate Component createButtons() {\n\t\tJPanel buttonPane = new JPanel();\n\t\tbuttonPane.setLayout(new FlowLayout());\n\n\t\tnewButton.setName(\"new\");\n\t\tbuttonPane.add(newButton);\n\t\teditButton.setName(\"edit\");\n\t\teditButton.setEnabled(false);\n\t\tbuttonPane.add(editButton);\n\t\tdeleteButton.setName(\"delete\");\n\t\tdeleteButton.setEnabled(false);\n\t\tbuttonPane.add(deleteButton);\n\n\t\treturn buttonPane;\n\t}\n",
    "72402": "\tprivate JTable createTable() {\n\t\tDVDTableModel dvdModel = new DVDTableModel();\n\t\t//dvdModel.setData(dvdCollection);\n\t\tJTable table = new JTable(dvdModel);\n\t\ttable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        dvdModel.addMouseListenerToTableHeader (table);\n\n\t\treturn table;\n\t}\n",
    "72404": "\tpublic void updateTableData(Vector v) {\n\t\tDVDTableModel model = (DVDTableModel) dvdTable.getModel();\n\t\tVector data = new Vector();\n\t\tIterator i = v.iterator();\n\n\t\twhile (i.hasNext()) {\n\t\t\tDVD dvd = (DVD) i.next();\n\t\t\tdata.add(dvd.toArray());\n\t\t}\n\n\t\tmodel.setData(data);\n\t}\n",
    "72407": "\tpublic void enableEditDeleteButtons() {\n\t\teditButton.setEnabled(true);\n\t\tdeleteButton.setEnabled(true);\n\t}\n",
    "72410": "\tpublic void valueChanged(ListSelectionEvent e) {\n        //Ignore extra messages.\n        if (e.getValueIsAdjusting()) return;\n\n        ListSelectionModel lsm = (ListSelectionModel)e.getSource();\n        if (lsm.isSelectionEmpty()) {\n            //no rows are selected\n        \tmainFrame.disableEditDeleteButtons();\n        \tselectedRow = -1;\n\n        } else {\n        \t// a row has been selected\n             selectedRow = lsm.getMinSelectionIndex();\n             mainFrame.enableEditDeleteButtons();\n        }\n\n\t}\n",
    "72413": "\tpublic void disableEditDeleteButtons() {\n\t\teditButton.setEnabled(false);\n\t\tdeleteButton.setEnabled(false);\n\t}\n",
    "72414": "\tpublic void setPermanentType() {\n\t\tpermanent = true;\n\t}\n",
    "72419": "\tprivate void collectTypes() {\n\t\tboolean foundNewType = true;\n\t\tIterator i = types.iterator();\n\t\twhile (i.hasNext()) {\n\t\t\tString t = (String) i.next();\n\t\t\tif(t.equalsIgnoreCase(type)) {\n\t\t\t\tfoundNewType = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(foundNewType) {\n\t\t\tLog.print(3, \"New type found, added to the list: \" + type);\n\t\t\ttypes.add(type);\n\t\t}\n\t}\n",
    "72420": "\tpublic void mouseClicked(MouseEvent e){\n\t\tif (e.getClickCount() == 2){\n\t\t\tDVD dvd = (DVD)dvdCollection.get(selectedRow);\n\t\t\topenEditWindow(dvd);\n\t\t}\n\t}\n",
    "72427": "\tpublic void nextPage(ImdbInfo[] imdbAddresses) {\n\t\tCardLayout cl = (CardLayout) (cards.getLayout());\n\t\tcl.next(cards);\n\t\tcardNr++;\n\n\t\tString[] moviesFound = new String[imdbAddresses.length];\n\t\tfor(int i = 0; i < imdbAddresses.length; i++) {\n\t\t\tmoviesFound[i] = imdbAddresses[i].getTitle();\n\t\t}\n\n        //Arrays.sort (moviesFound, new RelevanceComparator (imdbSearch.getText ()));\n\n\t\tlist.setListData(moviesFound);\n\n\t\tthis.imdbAddresses = imdbAddresses;\n\n\t\tbackButton.setEnabled(true);\n\t\tnextButton.setEnabled(true);\n\t}\n",
    "72436": "\tpublic int compareTo(Object o) {\n\t\tif (o instanceof DVD) {\n\t\t\tDVD d = (DVD) o;\n\t\t\tField f = (Field) fields.get(0);\n\t\t\tField f2 = (Field) d.getFields().get(0);\n\t\t\treturn f.getValue().compareTo(f2.getValue());\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n",
    "72442": "\tpublic void setFromWizard(boolean wiz) {\n\t\twizard = wiz;\n\t}\n",
    "72448": "\tpublic boolean isFromWizard() {\n\t\treturn wizard;\n\t}\n",
    "72463": "\tpublic void enableMainWindow() {\n\t\tmainFrame.setEnabled(true);\n\t\tmainFrame.setVisible(true);\n\t}\n",
    "72471": "\tpublic void dvdDataUpdated() {\n\t\tCollections.sort(dvdCollection);\n\t\tmainFrame.updateTableData(dvdCollection);\n\t}\n",
    "72479": "\tpublic void addDVD(DVD d) {\n\t\tdvdCollection.add(d);\n\t}\n",
    "72487": "\tpublic boolean hasNextDVD() {\n\t\treturn (selectedRow < dvdCollection.size()-1);\n\t}\n",
    "72498": "\tpublic boolean hasPreviousDVD() {\n\t\treturn (selectedRow > 0);\n\t}\n",
    "72555": "    public void next() {\n        Event e = new Event();\n        e.type = Event.NEXT;\n        e.time = System.currentTimeMillis() + delay;\n        queue.add(e);\n    }\n",
    "72562": "    public void poke(int channel) {\n        Event e = new Event();\n        e.type = Event.POKE;\n        e.channel = channel;\n        e.time = System.currentTimeMillis() + delay;\n        queue.add(e);\n    }\n",
    "72565": "    public char getChannel(int channel) {\n        synchronized (scopes) {\n            return levels[(int)scopes[channel]];\n        }\n    }\n",
    "72570": "    public String getAllChannels() {\n        StringBuffer sb = new StringBuffer();\n        for (int n = 0; n < scopes.length; n++) {\n            sb.append(getChannel(n));\n        }\n        return sb.toString();\n    }\n",
    "72667": "    public double getInitialVolume(int track) {\n    \treturn initialTrackVolume[track];\n    }\n",
    "72680": "    public int getTrackCount() {\n        return getPatternAtPos(0).getTrackCount();\n    }\n",
    "72830": "    private void loadList(LineNumberReader lnr) throws IOException {\n        position = -1;\n        list = new ArrayList<String>();\n        String line = null;\n        while ((line = lnr.readLine()) != null) {\n            line = line.trim();\n            File file = new File(line);\n            if (file.exists() && file.isFile())\n                list.add(line);\n        }\n    }\n",
    "72842": "    public void remove() {\n        list.remove(position);\n    }\n",
    "72849": "    private PlayerThread createPlayerThread(Module module) {\n        Player player = new Player();\n        try {\n            player.init(\n                new JavaSoundOutput(new SoundDataFormat(BITS, RATE, CHANNELS), BUFFERSIZE),\n                INTERPOLATE);\n            player.load(module);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        PlayerThread playerthread = new PlayerThread(player);\n        playerthread.pause(true);\n        return playerthread;\n    }\n",
    "72852": "    private Module loadModule(int nextModule) {\n        int mc = fileList.size();\n        while (nextModule <= 0) nextModule += mc;\n        try {\n            theUrl = new URL(protocol, host, port, fileList.get((nextModule + mc) % mc));\n            return ModuleLoader.getModuleLoader(theUrl).getModule();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n",
    "72854": "    private ThreadedPlayer createPlayer(Module module) {\n        ThreadedPlayer player = new ThreadedPlayer();\n        try {\n            player.init(\n                new JavaSoundOutput(new SoundDataFormat(BITS, RATE, CHANNELS), BUFFERSIZE),\n                INTERPOLATE);\n            player.load(module);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        player.pause(true);\n        return player;\n    }\n",
    "72869": "        public void quit() {\n            run = false;\n        }\n",
    "72871": "    public void savePlayList() throws IOException {\n        savePlayList(new File(playListFile),playList);\n        Logger.debug(\"Saved playlist: \" + playListFile);\n    }\n",
    "72996": "    public void start() {\n        running = true;\n        t = new Thread(this);\n        t.start();\n    }\n",
    "72998": "    public void stop() {\n        running = false;\n    }\n",
    "73002": "    public boolean isRunning() {\n        return running;\n    }\n",
    "73003": "    public void pause(boolean pause) {\n        paused = pause;\n    }\n",
    "73007": "    public boolean isPaused() {\n        return paused;\n    }\n",
    "73009": "    public boolean hasFailed() {\n        return error;\n    }\n",
    "73012": "    public Throwable getFailiureCause() {\n        return errorCause;\n    }\n",
    "73085": "        public void setMute(boolean mute) {\n            this.mute = mute;\n        }\n",
    "73130": "    public boolean init(Output output, boolean interpolate) {\n        out = output;\n        lowLevelMixerClass = interpolate ? InterpolatingMixer.class : FastMixer.class;\n        return true;\n    }\n",
    "73132": "    public boolean load(String fileName) throws InvalidFormatException, IOException {\n        ModuleLoader ml = ModuleLoader.getModuleLoader(new File(fileName));\n        Module module = ml.getModule();\n        return load(module);\n    }\n",
    "73133": "    public boolean load(Module module) {\n        int tracks = module.getPatternAtPos(0).getTrackCount();\n\n        Mixer mixer = new DefaultMixer(out, lowLevelMixerClass, tracks);\n\n        ms = new ModuleState(module, mixer);\n\n        // do some mixer initialization...\n        mixer.setAmplification(getDefaultAmplification());\n\n        return out.open();\n    }\n",
    "73135": "    public boolean play() throws PlayerException {\n        return ms.play();\n    }\n",
    "73140": "    public ModuleState getModuleState() {\n        return ms;\n    }\n",
    "73141": "    public Module getModule() {\n        return getModuleState().getModule();\n    }\n",
    "73142": "    public double getDefaultAmplification() {\n        return getModuleState().getModule().getPatternAtPos(0).getTrackCount() / 4.0;\n    }\n",
    "73220": "    private void writeData(byte[] data, int ofs, int len) {\n        int count = 0;\n        int written = 0;\n        while (written < len) {\n            written += sdl.write(data, ofs + written, len - written);\n\n            // take a litle break if we couldn't write everything in 100\n            // tries...\n            count++;\n            if (count >= 100) {\n                try { Thread.sleep(10); } catch (InterruptedException e) { }\n                count = 0;\n            }\n        }\n    }\n",
    "74678": "\tprotected CatalogInquiry getCatalogService(){\n\t\treturn catalogService;\n\t}\n",
    "74681": "\tprotected AccountManagement getAccountService(){\n\t\treturn accountService;\n\t}\n",
    "74685": "\tprotected OrderEntry getOrderService(){\n\t\treturn orderService;\n\t}\n",
    "76469": "    public void shutdownServices() {\n\tif(services==null) return;\n\n        for(Iterator it = services.iterator();\n            it.hasNext();){\n               MPPlugin serv = (MPPlugin)it.next();\n\t       // Shutdown service\n\t       serv.shutdown();\n\t}\n\n\tservices = null;\n    }\n",
    "76483": "    private String getLocationString(SAXParseException ex) {\n\tStringBuffer str = new StringBuffer();\n\n\tString systemId = ex.getSystemId();\n\tif (systemId != null) {\n\t    int index = systemId.lastIndexOf('/');\n\t    if (index != -1) \n\t\tsystemId = systemId.substring(index + 1);\n\t    str.append(systemId);\n\t}\n\tstr.append(':');\n\tstr.append(ex.getLineNumber());\n\tstr.append(':');\n\tstr.append(ex.getColumnNumber());\n\n\treturn str.toString();\n\n    } // getLocationString(SAXParseException):String\n",
    "76485": "    public String getPassword() {\n        return password;\n    }\n",
    "76487": "  public void finished() {\n    workers.removeElement(this);\n    workersStart.remove(this);\n  }\n",
    "76489": "    public void setPassword(String newPassword) {\n        this.password = newPassword;\n    }\n",
    "76490": "  public void interrupt() {\n    Thread t = threadVar.get();\n    if (t != null) {\n      t.interrupt();\n    }\n    threadVar.clear();\n  }\n",
    "76492": "    public String getUserid() {\n        return userid;\n    }\n",
    "76493": "  public Object get() {\n    while (true) {  \n      Thread t = threadVar.get();\n      if (t == null) {\n\treturn getValue();\n      }\n      try {\n\tt.join();\n      }\n      catch (InterruptedException e) {\n\tThread.currentThread().interrupt(); // propagate\n\treturn null;\n      }\n    }\n  }\n",
    "76495": "    public void setUserid(String newUserid) {\n        this.userid = newUserid;\n    }\n",
    "76496": "  public void start(){\n    startThread.start();\n  }\n",
    "76498": "    public String getConnectUrl() {\n        return connectUrl;\n    }\n",
    "76501": "    public void setConnectUrl(String newConnectUrl) {\n        this.connectUrl = newConnectUrl;\n    }\n",
    "76505": "    public String getJdbcDriver() {\n        return jdbcDriver;\n    }\n",
    "76507": "    public void setJdbcDriver(String newJdbcDriver) {\n        this.jdbcDriver = newJdbcDriver;\n    }\n",
    "76525": "    public boolean isDoPopup() {\n        \n        return this.doPopup;\n    }\n",
    "76530": "    public void setDoPopup(boolean doPopup) {\n        this.doPopup = doPopup;\n    }\n",
    "76542": "    public File translateDocument(String inputDocument) throws Exception {\n\n        try {\n            documentTree = FileUtils.getInstance().stringToDocument(\n                    inputDocument);\n        } catch (Exception e) {\n            throw e;\n        }\n\n        result = new StringBuffer();\n        result.append(\"(deffacts patientSummary\");\n        result.append(\"\\n\");\n        buildResult(documentTree.getFirstChild(), \"\");\n        result.append(\"\\n\");\n        result.append(\")\");\n        File f = null;\n        try {\n            f = this.createFileFromStr(result.toString());\n        } catch (Exception e) {\n            throw e;\n        }\n        return f;\n\n    }\n",
    "76545": "    private File createFileFromStr(String str) throws Exception {\n        File file = new File(\"fileForIE.clp\");\n        FileWriter fileWriter;\n        try {\n            fileWriter = new FileWriter(file);\n            BufferedWriter out = new BufferedWriter(fileWriter);\n            out.write(str);\n            out.close();\n        } catch (IOException e) {\n            throw e;\n        }\n        return file;\n    }\n",
    "76607": "    private String getCurrentTime() {\n\n        Date now = new Date();\n        SimpleDateFormat df1 = new SimpleDateFormat(\"yyyyMMdd\");\n\n        return df1.format(now);\n    }\n",
    "76618": "    private String generateDocCode() {\n        // TO DO: come up with document code generation mechanism\n        return \"111\";\n    }\n",
    "76629": "    private String generateDocCodeSystem() {\n        // come up with document code generation mechanism\n        return \"111\";\n    }\n",
    "76670": "    private void registerIDocImport(IDocumentImport iDocumentImport) {\n        this.iDocumentImport = iDocumentImport;\n\n    }\n",
    "76672": "    private void registerIDocExport(IDocumentExport iDocumentExport) {\n        this.iDocumentExport = iDocumentExport;\n\n    }\n",
    "76675": "    private void registerIInference(IInference iInference) {\n        this.iInference = iInference;\n\n    }\n",
    "76679": "    private void registerIAuditLog(IAuditLog iAuditLog) {\n        this.iAuditLog = iAuditLog;\n\n    }\n",
    "76685": "    public boolean hasNext() {\n        return (position < length);\n    }\n",
    "76774": "    public PrimitiveType primitive(String name) {\n        return new PrimitiveType(this, name);\n    }\n",
    "76778": "    public PrimitiveType primitive(Token token) {\n        return primitive(token.getText());\n    }\n",
    "76780": "    public PrimitiveType primitive(Symbol symbol) {\n        return primitive(symbol.toString());\n    }\n",
    "76787": "    protected void visit(List nodes) {\n        Iterator iNodes = nodes.iterator();\n        while (iNodes.hasNext())\n            ((Node) iNodes.next()).apply(this);\n    }\n",
    "76790": "    protected void visit(Node node) {\n        node.apply(this);\n    }\n",
    "76794": "    protected void warning(String msg) {\n        logger.warning(msg);\n        // _errOut.println(msg);\n    }\n",
    "76795": "    public boolean hasErrors() {\n        return _errors;\n    }\n",
    "76804": "    public String getRecommendations(String patientSummary) {\n\n        helper = new SimpleWebServiceHelper();\n        String result = null;\n        try {\n            result = helper.getRecommendations(patientSummary);\n        } catch (EgadssException ex) {\n            logger.log(Level.SEVERE, ex.toString(), ex);\n        }\n        return result;\n\n    }\n",
    "76847": "    private void startSystem() throws Exception {\n        try {\n            this.createComponents();\n\n            this.initializeComponents();\n            log.info(\"EGADSS SYSTEM HAS BEEN STARTED\");\n\n        } catch (Exception e) {\n            throw e;\n        }\n\n    }\n",
    "76930": "    public String velocityClinicalGuideline()throws EgadssException {\n        if(!initialized)\n    throw new EgadssException(\"Configuration must be initialized before fields can be accessed\");\n        return this.velocityClinicalGuideline;\n    }\n",
    "76934": "    public void testValidateDocumentCase1() {\n        try {\n\n            if (documentValidator.validateDocument(FileUtils.getInstance()\n                    .filetoString(\n                            new File(Configuration.getInstance()\n                                    .testPatientXmlUri())), Configuration\n                    .getInstance().patientSummarySchemaUri())) {\n                assertTrue(true);\n            } else\n                assertTrue(false);\n        } catch (Exception e) {\n\n            logger.log(Level.WARNING, \"Case 1 Exception in DocumentValidator.validateDocument method: \"\n                            + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "76946": "    public void testGetInfo() {\n        try {\n            String componentInfo = iConfig.getInfo();\n            logger.fine(\"Returned Component info: \" + componentInfo);\n            logger.fine(\"Testing of getInfo method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Exception in testing getInfo method: \"\n                    + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "76949": "    public void testInitialize() {\n        try {\n            iConfig.initialize(docImpExCompMap);\n            assertTrue(true);\n            logger.fine(\"Testing of initialize method was successful\");\n        } catch (Exception e) {\n            logger\n                    .log(Level.WARNING,\n                            \"Exception in testing initialize method: \"\n                                    + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "76952": "    public void testTerminate() {\n        // try{\n        // iConfig.terminate();\n        // logger.fine(\"Testing of terminate method was successful\");\n        // assertTrue(true);\n        // }\n        // catch(Exception e){\n        // logger.log(Level.WARNING, \"Exception in testing initialize method:\n        // \"+e.getMessage(), e);\n        // }\n    }\n",
    "76956": "    public void testImportDocument() {\n        try {\n\n            iDocumentImport.importDocument(xmlDocumentStr);\n            logger.fine(\"Testing of importDocument method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            assertTrue(false);\n            logger.log(Level.WARNING, \"Exception in testing importDocument: \"\n                    + e.getMessage(), e);\n        }\n\n    }\n",
    "76959": "    public void testExportDocument() {\n\n        try {\n            outputFromIeFile = new File(Configuration.getInstance()\n                    .patientResultInstancesClpUri());\n            iDocumentImport.importDocument(xmlDocumentStr);\n            iDocumentExport.exportDocument(outputFromIeFile);\n            logger.fine(\"Testing of exportDocument method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            assertTrue(false);\n            logger.log(Level.WARNING, \"Exception in testing exportDocument: \"\n                    + e.getMessage(), e);\n        }\n\n    }\n",
    "76964": "    public void testGetInfo() {\n        try {\n            String componentInfo = iConfigTransController.getInfo();\n            logger.fine(\"Returned Component info: \" + componentInfo);\n            logger.fine(\"Testing of getInfo method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Exception in testing getInfo method: \"\n                    + e.getMessage(), e);\n        }\n    }\n",
    "76968": "    public void testInitialize() {\n        try {\n            iConfigTransController.initialize(transControllerCompMap);\n            assertTrue(true);\n            logger.fine(\"Testing of initialize method was successful\");\n        } catch (Exception e) {\n            logger\n                    .log(Level.WARNING,\n                            \"Exception in testing initialize method: \"\n                                    + e.getMessage(), e);\n        }\n    }\n",
    "76973": "    public void testParseKnowledgeModuleForXPath() {\n        try {\n\n            preprocessor.parseKnowledgeModuleForXPath(knowledgeModuleFile);\n            logger.fine(\"Testing of parseKnowledgeModuleForXPath method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Exception in testing preprocessXPath: \"\n                    + e.getMessage(), e);\n            assertTrue(false);\n\n        }\n\n    }\n",
    "76975": "    public void testTerminate() {\n        // try{\n        // iConfigTransController.terminate();\n        // assertTrue(true);\n        // }\n        // catch(Exception e){\n        // }\n    }\n",
    "76980": "    // public void testGetRecommendations() {\n    //\n    // this.testInitialize();\n    //\t\t\n    // //assert knowledge module into InferenceEngine\n    // try{\n    // ie.assertKnowledgeModule(testGuideline, \"Immunizations\");\n    // }catch(Exception e){\n    // assertTrue(false);\n    // }\n    //\t\t\n    // try{\n    //\t\t\t\n    //\t\t\t\n    // resultsDocument=iTrans.getRecommendations(inputDocument);\n    //\t\t\t\n    // assertTrue(true);\n    // }\n    // catch(Exception e){\n    // assertTrue(false);\n    // }\n    // }\n",
    "76987": "    public void testGetInfo() {\n        try {\n            String componentInfo = iConfigDataStorage.getInfo();\n            logger.fine(\"Returned Component info: \" + componentInfo);\n            logger.info(\"Testing of getInfo method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.INFO, \"Exception in testing getInfo method: \"\n                    + e.getMessage(), e);\n        }\n    }\n",
    "76990": "    public void testInitialize() {\n        try {\n            iConfigDataStorage.initialize(dataStorageComMap);\n            assertTrue(true);\n            logger.info(\"Testing of initialize method was successful\");\n        } catch (Exception e) {\n            logger.log(Level.INFO, \"Exception in testing initialize method: \"\n                    + e.getMessage(), e);\n        }\n    }\n",
    "76991": "    public void testWriteLogEntry() {\n        try {\n            iAuditLog.writeLogEntry(logEntry);\n            logger.info(\"Testing of writeLogEntry method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.INFO,\n                    \"Exception in testing writeLogEntry method: \"\n                            + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "76992": "    public void testTerminate() {\n        // try{\n        // docImpEx.terminate();\n        // assertTrue(true);\n        // }\n        // catch(Exception e){\n        // }\n    }\n",
    "76995": "    public void testGenerateAuditReport() {\n        try {\n            report = iAudit.generateAuditReport();\n            if (!(report == null)) {\n                logger.fine(\"Audit report string: \" + report);\n                logger\n                        .info(\"Testing of generateAuditReport method was successful\");\n                assertTrue(true);\n            } else {\n                assertTrue(false);\n            }\n        } catch (Exception e) {\n            logger.log(Level.INFO,\n                    \"Exception in testing generateAuditReport method: \"\n                            + e.getMessage(), e);\n            assertTrue(false);\n        }\n\n    }\n",
    "76997": "    public void testSetAndGetAuditingMode() {\n        try {\n            iAudit.setAuditingMode(\"privacy mode\");\n            if ((iAudit.getAuditingMode()).equals(\"privacy mode\")) {\n                logger\n                        .info(\"Testing of setAuditingMode and getAuditingMode methods was successful\");\n                assertTrue(true);\n            } else {\n                assertTrue(false);\n            }\n        } catch (Exception e) {\n            logger.log(Level.INFO,\n                    \"Exception in testing setAuditingMode method: \"\n                            + e.getMessage(), e);\n            assertTrue(false);\n        }\n\n    }\n",
    "77002": "    public void testShutSystemDown() {\n        // TO DO: figure out how to test methods that terminate the\n        // application...\n\n        \n\n    }\n",
    "77005": "    public void testViewSystemConfig() {\n        try {\n            config = iSysConfig.viewSystemConfig();\n            logger.fine(\"Config string: \" + config);\n            logger.info(\"Testing of viewSystemConfig method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.INFO,\n                    \"Exception in testing viewSystemConfig method: \"\n                            + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "77008": "    public void testGetInfo() {\n        try {\n            String componentInfo = iConfigConfigManager.getInfo();\n            logger.fine(\"Returned Component info: \" + componentInfo);\n            logger.info(\"Testing of getInfo method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.INFO, \"Exception in testing getInfo method: \"\n                    + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "77015": "    public void testInitialize() {\n        try {\n            iConfigConfigManager.initialize(configManagerCompMap);\n            assertTrue(true);\n            logger.info(\"Testing of initialize method was successful\");\n        } catch (Exception e) {\n            logger.log(Level.INFO, \"Exception in testing initialize method: \"\n                    + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "77021": "    public void testTerminate() {\n        // try{\n        // iConfigConfigManager.terminate();\n        // assertTrue(true);\n        // }\n        // catch(Exception e){\n        // assertTrue(false);\n        // }\n    }\n",
    "81092": "\tpublic void stop(BundleContext context) throws Exception {\n\t\tsuper.stop(context);\n\t}\n",
    "81105": "    public void trace(boolean onoff) {\n      try {\n        serverControl.trace(onoff);\n      } catch (Exception e) {\n          e.printStackTrace();\n        }\n    }\n",
    "81107": "    public void shutdown() {\n        try {\n            serverControl.shutdown();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n",
    "81108": "    public void start() {\n        try {\n\t\t\tserverControl.start(pw);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n",
    "81112": "\t public Connection getConnection(String dbUrl, Properties properties) {\n\t\t Connection conn = null;\n\t\t try {\n\t\t\tpw.println(\"[NsSampleWork] Thread id - \"+thread_id + \"; requests database connection, dbUrl =\"+dbUrl);\n\t\t\tconn = DriverManager.getConnection(dbUrl, properties);\n\t\t  } catch (Exception e) {\n\t\t\t System.out.println(\"[NsSampleWork] Thread id - \"+ thread_id + \"; failed to get database connection. Exception thrown:\");\n\t\t\t e.printStackTrace();\n\t\t    }\n\t\t  return conn;\n\t }\n",
    "81114": "\t public void setIsolationLevel(Connection conn, int level) {\n\t\t try {\n\t\t\tconn.setTransactionIsolation(level);\n\t\t } catch (Exception e) {\n\t\t\t pw.println(\"[NsSampleWork] Thread id - \"+ thread_id +\"; setIsolationLevel failed. Exception thrown: \");\n\t\t\t e.printStackTrace();\n\t\t   }\n\t }\n",
    "81131": "\tpublic long length() throws SQLException {\n\t\treturn dataLength;\n\t\t\n\t}\n",
    "81443": "\tprotected byte getCurrChainState() {\n\n\t\tif (!dssIsChainedWithSameID && !dssIsChainedWithDiffID)\n\t\t\treturn DssConstants.DSS_NOCHAIN;\n\n\t\tif (dssIsChainedWithSameID)\n\t\t\treturn DssConstants.DSSCHAIN_SAME_ID;\n\n\t\treturn DssConstants.DSSCHAIN;\n\n\t}\n",
    "81557": "\tprotected void endDss() {\n\t\tendDss(true);\n\t}\n",
    "81745": "\tprivate int getCorrelationID() {\n\n\t\tint cId;\n\t\tif (previousCorrId != DssConstants.CORRELATION_ID_UNKNOWN) {\n\t\t\tif (previousChainByte == DssConstants.DSSCHAIN_SAME_ID)\n\t\t\t// then we have to use the last correlation id we sent.\n\t\t\t\tcId = previousCorrId;\n\t\t\telse\n\t\t\t// get correlation id as normal.\n\t\t\t\tcId = nextCorrelationID++;\n\t\t}\n\t\telse {\n\t\t// must be the case that this is the first DSS we're\n\t\t// writing for this connection (because we haven't\n\t\t// called \"endDss\" yet).  So, get the corr id as\n\t\t// normal.\n\t\t\tcId = nextCorrelationID++;\n\t\t}\n\n\t\treturn cId;\n\n\t}\n",
    "82376": "\tpublic String getHtmlLabelledMessageInstance(LocalizedResource localUtil, String key, String id) {\n\n\t\tif (id == null)\n\t\t\tid = \"\";\n\n\t\treturn (\"<label for='\" + id + \"'>\" + localUtil.getTextMessage(key) +\n\t\t\t\"</label>\");\n\n\t}\n",
    "82378": "\tprivate void printAsContentHeader(String str) {\n\n\t\tout.println(\"<a name=\\\"navskip\\\"></a><h2>\" + str + \"</h2>\");\n\t\treturn;\n\n\t}\n",
    "82382": "\tprivate String escapeSingleQuotes(String str) {\n\n\t\tif ((str == null) || (str.indexOf(\"'\") < 0))\n\t\t\treturn str;\n\n\t\tchar [] cA = str.toCharArray();\n\n\t\t// Worst (and extremely unlikely) case is every \n\t\t// character is a single quote, which means the\n\t\t// escaped string would need to be 4 times as long.\n\t\tchar [] result = new char[4*cA.length];\n\n\t\tint j = 0;\n\t\tfor (int i = 0; i < cA.length; i++) {\n\n\t\t\tif (cA[i] == '\\'') {\n\t\t\t\tresult[j++] = '&';\n\t\t\t\tresult[j++] = '#';\n\t\t\t\tresult[j++] = '3';\n\t\t\t\tresult[j++] = '9';\n\t\t\t}\n\t\t\telse\n\t\t\t\tresult[j++] = cA[i];\n\n\t\t}\n\n\t\treturn new String(result, 0, j);\n\n\t}\n",
    "82653": "\tprivate String  buildPreformattedSqlerrmc(SQLException se) {\n\t\tif (se == null)\n\t\t\treturn \"\";\n\t\t\n\t\tStringBuffer sb = new StringBuffer(); \n\t\t // String buffer to build up message\n\t\tdo {\n\t\t\tsb.append(se.getLocalizedMessage());\n\t\t\tse = se.getNextException();\n\t\t\tif (se != null)\n\t\t\t\tsb.append(SQLERRMC_PREFORMATTED_MESSAGE_DELIMITER + \n\t\t\t\t\t\t\"SQLSTATE: \" + se.getSQLState());\n\t\t} while (se != null);\t\t\t\n\t\treturn sb.toString();\t\t\n\t}\n",
    "82659": "\tprivate String buildTokenizedSqlerrmc(EmbedSQLException se) {\n\t\t\n\t\tString sqlerrmc = \"\";\n\t\tdo {\n\t\t\tString messageId = se.getMessageId();\n\t\t\t// arguments are variable part of a message\n\t\t\tObject[] args = se.getArguments();\n\t\t\tfor (int i = 0; args != null &&  i < args.length; i++)\n\t\t\t\tsqlerrmc += args[i] + SQLERRMC_TOKEN_DELIMITER;\n\t\t\tsqlerrmc += messageId;\n\t\t\tse = (EmbedSQLException) se.getNextException();\n\t\t\tif (se != null)\n\t\t\t{\n\t\t\t\tsqlerrmc += SQLERRMC_MESSAGE_DELIMITER + se.getSQLState() + \":\";\t\t\t\t\n\t\t\t}\n\t\t} while (se != null);\n\t\treturn sqlerrmc;\n\t}\n",
    "83118": "\tprivate void finalizeChain() throws DRDAProtocolException {\n\n\t\twriter.finalizeChain(reader.getCurrChainState(), getOutputStream());\n\t\treturn;\n\n\t}\n",
    "83491": "    public int getTransactionTimeout() throws XAException {\n        if (conn_.agent_.loggingEnabled()) {\n            conn_.agent_.logWriter_.traceEntry(this, \"getTransactionTimeout\");\n        }\n        exceptionsOnXA = null;\n        if (conn_.isPhysicalConnClosed()) {\n            connectionClosedFailure();\n        }\n\n        if (conn_.agent_.loggingEnabled()) {\n            conn_.agent_.logWriter_.traceExit(this, \"getTransactionTimeout\", 0);\n        }\n        return 0; // we don't support transaction timeout\n    }\n",
    "83501": "    public boolean setTransactionTimeout(int seconds) throws XAException {\n        if (conn_.agent_.loggingEnabled()) {\n            conn_.agent_.logWriter_.traceExit(this, \"setTransactionTimeout\", false);\n        }\n        exceptionsOnXA = null;\n        return false; // we don't support transaction timeout in our layer.\n        /* int rc = xaSetTransTimeOut(seconds);\n           if (rc != XAResource.XA_OK)\n             throwXAException(rc); */\n    }\n",
    "84264": "    public String getCatalogName(int column) throws SqlException {\n        checkForClosedStatement();\n        checkForValidColumnIndex(column);\n        return \"\";\n    }\n",
    "84396": "    public void setPKGNAMCBytes(byte[] b, int resultSetHoldability) {\n        if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.HOLD_CURSORS_OVER_COMMIT) {\n            agent_.sectionManager_.holdPKGNAMCBytes = b;\n        } else if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.CLOSE_CURSORS_AT_COMMIT) {\n            agent_.sectionManager_.noHoldPKGNAMCBytes = b;\n        }\n    }\n",
    "84636": "    public boolean isPhysicalConnClosed() {\n    return !open_ && !availableForReuse_; \n   }\n",
    "84681": "    public void setPKGNAMCBytes(byte[] b) {\n        if (isGenerated) {\n            PKGNAMCBytes = b;\n        } else {\n            agent_.sectionManager_.setPKGNAMCBytes(b, resultSetHoldability_);\n        }\n    }\n",
    "84794": "    public Object run() {\n        this.systemProperties_ = System.getProperties();\n        return this.systemProperties_;\n    }\n",
    "84802": "    public Connection getConnection() throws SQLException {\n        return getConnection(user, password);\n    }\n",
    "84803": "    public Connection getConnection(String user, String password) throws SQLException {\n        // Jdbc 2 connections will write driver trace info on a\n        // datasource-wide basis using the jdbc 2 data source log writer.\n        // This log writer may be narrowed to the connection-level\n        // This log writer will be passed to the agent constructor.\n\n        LogWriter dncLogWriter = super.computeDncLogWriterForNewConnection(\"_sds\");\n        updateDataSourceValues(tokenizeAttributes(connectionAttributes, null));\n        return new NetConnection((NetLogWriter) dncLogWriter, user, password, this, -1, false);\n    }\n",
    "84869": "\tprotected void runTestSet() throws T_Fail {\n\n\t\t// Set up the expected error handling\n\t\ttry {\n\t\t\t\n\t\t\tS001();\n\t\t\tS002();\n\t\t\tS003();\n\t\t\tS004();\n\t\t\tS005();\n\t\t\tS007();\n\t\t\tS008();\n\n\t\t\tM001();\n\t\t\tM002();\n\t\t\tM003();\n\t\t\tM004();\n\t\t\t\n\n\t\t} catch (StandardException se) {\n\n\t\t\tthrow T_Fail.exceptionFail(se);\n\n\t\t}\n\t}\n",
    "84901": "\tpublic void clearIdentity() {\n\t\tkeyValue = null;\n\t}\n",
    "84903": "\tpublic Object getIdentity() {\n\t\treturn keyValue;\n\t}\n",
    "84907": "\tpublic void lockEvent(Latch lockInfo) {\n        if (SanityManager.DEBUG)\n            SanityManager.ASSERT(lockInfo.getQualifier() == null);\n\n\t\tlatch = lockInfo;\n\n\t\tcount++;\n\t}\n",
    "84913": "\tpublic void unlockEvent(Latch lockInfo) {\n        if (SanityManager.DEBUG)\n            SanityManager.ASSERT(lockInfo.getQualifier() == null);\n\t\t\n\t\tcount--;\n        if (SanityManager.DEBUG)\n            SanityManager.ASSERT(count >= 0);\n\t\tlatch = null;\n\t}\n",
    "84927": "\tpublic boolean isDirty() {\n\t\tsynchronized (this) {\n\t\t\treturn isDirty;\n\t\t}\n\t}\n",
    "84948": "\tprotected String getModuleToTestProtocolName() {\n\t\treturn org.apache.derby.iapi.reference.Module.CacheFactory;\n\t}\n",
    "84958": "\tprotected void t_findCachedFail(CacheManager cm, Object key) throws StandardException, T_Fail {\n\t\tCacheable entry = cm.findCached(key);\n\t\tif (entry != null) {\n\t\t\tthrow T_Fail.testFailMsg(\"found cached item unexpectedly\");\n\t\t}\n\t}\n",
    "84959": "\tprotected Cacheable t_findCachedSucceed(CacheManager cm, Object key) throws StandardException, T_Fail {\n\t\tCacheable entry = cm.findCached(key);\n\t\tif (entry == null) {\n\t\t\tthrow T_Fail.testFailMsg(\"expected item to be in cache\");\n\t\t}\n\n\t\tif (!entry.getIdentity().equals(key))\n\t\t\tthrow T_Fail.testFailMsg(\"item returned does not match key\");\n\t\treturn entry;\n\t}\n",
    "84961": "\tprotected void t_findFail(CacheManager cm, Object key) throws T_Fail, StandardException {\n\t\tCacheable entry = cm.find(key);\n\t\tif (entry != null) {\n\t\t\tthrow T_Fail.testFailMsg(\"found item unexpectedly\");\n\t\t}\n\t}\n",
    "84963": "\tprotected Cacheable t_findSucceed(CacheManager cm, Object key) throws T_Fail, StandardException {\n\t\tCacheable entry = cm.find(key);\n\t\tif (entry == null) {\n\t\t\tthrow T_Fail.testFailMsg(\"expected item to be found\");\n\t\t}\n\t\tif (!entry.getIdentity().equals(key))\n\t\t\tthrow T_Fail.testFailMsg(\"item returned does not match key\");\n\n\t\treturn entry;\n\t}\n",
    "84995": "\tprotected boolean FAIL(String msg) {\n\t\tout.println(\"[\" + Thread.currentThread().getName() + \"] FAIL - \" + msg);\n\t\treturn false;\n\t}\n",
    "84996": "\tprotected boolean PASS(String testName) {\n\t\tout.println(\"[\" + Thread.currentThread().getName() + \"] Pass - \"+shortModuleToTestName +\" \" + testName);\n\t\treturn true;\n\t}\n",
    "84997": "\tpublic void REPORT(String msg) {\n\t\tout.println(\"[\" + Thread.currentThread().getName() + \"]     \" + msg);\n\t}\n",
    "85040": "\tprotected void joinSetupTest() throws T_Fail {\n\n\t\tT_Fail.T_ASSERT(factory != null, \"raw store factory not setup \");\n\t\tT_Fail.T_ASSERT(contextService != null, \"Context service not setup \");\n\t\tT_Fail.T_ASSERT(commonContainer != -1, \"common container not setup \");\n\n\t\tt_util = new T_Util(factory, lf, contextService);\n\n\t}\n",
    "85098": "\tpublic Page t_getLastPage(ContainerHandle c) throws T_Fail, StandardException {\n\n\t\tPage page = c.getFirstPage();\n\t\tif (page != null)\n\t\t{\n\t\t\tPage nextPage;\n\t\t\twhile((nextPage = c.getNextPage(page.getPageNumber())) != null)\n\t\t\t{\n\t\t\t\tpage.unlatch();\n\t\t\t\tpage = nextPage;\n\t\t\t}\n\t\t}\n\n\t\treturn page;\n\t}\n",
    "85100": "\tpublic Page t_getPage(ContainerHandle c, long pageNumber) throws T_Fail, StandardException {\n\n\t\tPage page = c.getPage(pageNumber);\n\t\tif (page == null)\n\t\t\tthrow T_Fail.testFailMsg(\"fail to get page \" + pageNumber + \" from container \" + c);\n\n\t\tif (page.getPageNumber() != pageNumber)\n\t\t\tthrow T_Fail.testFailMsg(\"page expected to have page number \" +\n\t\t\t\tpageNumber + \", has \" + page.getPageNumber() + \" Container \" + c);\n\n\t\treturn page;\n\t}\n",
    "85104": "\tpublic Page t_addPage(ContainerHandle c) throws T_Fail, StandardException {\n\n\t\tPage page = c.addPage();\n\n\t\tif (page == null)\n\t\t\tthrow T_Fail.testFailMsg(\"addPage() returned null\");\n\n\t\treturn page;\n\t}\n",
    "85120": "\tpublic void t_genRandomFile(String fileName, String mode, int size) throws T_Fail {\n\n\t\tRandomAccessFile iFile = null;\n\t\ttry {\n\t\t\tiFile = new RandomAccessFile(fileName, mode);\n\t\t\tfor (int i = 0; i < size; i++){\n\t\t\t\tbyte b = (byte) (i & 0xff);\n\t\t\t\tb = (byte) (((b >= ' ') && (b <= '~')) ? b : ' ');\n\t\t\t\tiFile.write(b);\n\t\t\t}\n\t\t\tiFile.close();\n\t\t} catch (FileNotFoundException fnfe) {\n\t\t\tthrow T_Fail.testFailMsg(\"cannot create new file\");\n\t\t} catch (IOException ioe) {\n\t\t\tthrow T_Fail.testFailMsg(\"io error, test failed\");\n\t\t}\n\n\t}\n",
    "85124": "\tpublic FormatableBitSet getValidColumns() {\n\t\treturn validColumns;\n\t} \n",
    "85127": "\tpublic boolean needsRowLocation() {\n\t\treturn false;\n\t}\n",
    "85129": "\tpublic void rowLocation(RowLocation rl) {\n\n\t\trl = null;\n\t}\n",
    "85366": "\tprotected void runTestSet() throws T_Fail {\n\n\t\t// get a utility helper\n\n\t\tContextManager cm1 = contextService.newContextManager();\n\t\tcontextService.setCurrentContextManager(cm1);\n\n\t\ttry {\n\n\t\t\trunCostEstimationTests();\n\t\t\trunAllocationTests();\n\n\t\t} catch (StandardException se) {\n\n\t\t\tcm1.cleanupOnError(se);\n\t\t\tthrow T_Fail.exceptionFail(se);\n\t\t}\n\t\tfinally {\n\n\t\t\tcontextService.resetCurrentContextManager(cm1);\n\t\t}\n\t}\n",
    "85374": "\tprotected void joinSetupTest() throws T_Fail {\n\n\t\tT_Fail.T_ASSERT(factory != null, \"raw store factory not setup \");\n\t\tT_Fail.T_ASSERT(lf != null, \"Lock factory not setup \");\n\t\tT_Fail.T_ASSERT(contextService != null, \"Context service not setup \");\n\n\t\ttestRollback = testRollbackProperty;\n\n\t}\n",
    "85419": "\tprotected void T000() throws T_Fail, StandardException {\n\n\t\tTransaction t1 = t_util.t_startTransaction();\n\n\t\tt1.close();\n\n\n\t\tt1 = t_util.t_startInternalTransaction();\n\n\t\tt1.close();\n\n\t\tt1 = t_util.t_startTransaction();\n\t\tTransaction ti = t_util.t_startInternalTransaction();\n\n\t\tti.close();\n\n\t\tt1.close();\n\n\t\tPASS(\"T000\");\n\t}\n",
    "85422": "\tprotected void T001() throws T_Fail, StandardException {\n\n\t\tTransaction t1 = t_util.t_startTransaction();\n\n\t\tt_util.t_commit(t1);\n\n\t\tt1.close();\n\n\t\tPASS(\"T001\");\n\t}\n",
    "85427": "\tprotected void T002() throws T_Fail, StandardException {\n\n\t\tTransaction t1 = t_util.t_startTransaction();\n\n\t\tt_util.t_abort(t1);\n\n\t\tt1.close();\n\n\t\tPASS(\"T002\");\n\t}\n",
    "85432": "\tprotected void T003() throws T_Fail, StandardException {\n\n\t\tTransaction t1 = t_util.t_startTransaction();\n\n\t\tt_util.t_commit(t1);\n\n\t\tt_util.t_commit(t1);\n\t\tt_util.t_abort(t1);\n\n\t\tt1.close();\n\n\t\tPASS(\"T003\");\n\t}\n",
    "85438": "\tprotected void T004() throws T_Fail, StandardException {\n\n\t\tTransaction t1 = t_util.t_startTransaction();\n\n\t\tt_util.t_abort(t1);\n\n\t\tt_util.t_commit(t1);\n\n\t\tt_util.t_abort(t1);\n\n\t\tt1.close();\n\n\t\tPASS(\"T004\");\n\t}\n",
    "85480": "\tprotected void C010(int segment) throws T_Fail, StandardException {\n\n\t\tTransaction t = t_util.t_startTransaction();\n\n\t\tlong cid = t_util.t_addContainer(t, segment);\n\n\t\tt_util.t_commit(t);\n\t\n\t\tContainerHandle c1, c2;\n\n\t\tc1 = t_util.t_openContainer(t, segment, cid, true);\n\t\tc1 = t_util.t_openContainer(t, segment, cid, true);\n\t\tt_util.t_dropContainer(t, segment, cid);\t// cleanup\n\n\n\t\tt_util.t_commit(t);\n\t\tt.close();\n\n\t\tPASS(\"C010\");\n\n\t}\n",
    "85485": "\tprotected void C011() throws T_Fail, StandardException {\n\n\t\tTransaction t = t_util.t_startTransaction();\n\n\t\tlong cid = t_util.t_addContainer(t, 0);\n\n\t\tt_util.t_commit(t);\n\t\n\t\tContainerHandle c1, c2;\n\n\t\tc1 = t_util.t_openContainer(t, 0, cid, false);\n\t\tc1 = t_util.t_openContainer(t, 0, cid, true);\n\n\t\tt_util.t_dropContainer(t, 0, cid);\t// cleanup\n\n\t\tt_util.t_commit(t);\n\t\tt.close();\n\t\tPASS(\"C011\");\n\n\t}\n",
    "86122": "\tprotected Statement createFloatStatementForStateChecking(Connection conn) throws SQLException {\n\t\tStatement s = internalCreateFloatStatementForStateChecking(conn);\n\t\ts.setCursorName(\"StokeNewington\");\n\t\ts.setFetchDirection(ResultSet.FETCH_REVERSE);\n\t\ts.setFetchSize(444);\n\t\ts.setMaxFieldSize(713);\n\t\ts.setMaxRows(19);\n\n\t\tshowStatementState(\"Create \", s);\n\t\treturn s;\n\t}\n",
    "86148": "\tstatic private void expectedException (SQLException se, String expectedSQLState) {\n           if( se.getSQLState() != null && (se.getSQLState().equals(expectedSQLState))) { \n                System.out.println(\"PASS -- expected exception\");\n                while (se != null) {\n                    System.out.println(\"SQLSTATE(\"+se.getSQLState()+\"): \"+se.getMessage());\n                    se = se.getNextException();\n                }\n            } else {\n\t        System.out.println(\"FAIL--Unexpected SQLException: \" +\n\t\t\t\t\t\t\t   \"SQLSTATE(\" +se.getSQLState() + \")\" +\n\t\t\t\t\t\t\t   se.getMessage());\n\t        se.printStackTrace(System.out);\n\t    }\n\t}\n",
    "86149": "     static private void unexpectedSQLException(SQLException se) {\n\t System.out.println(\"FAIL -- Unexpected Exception: \"+ \n\t\t\t\t\t\t\"SQLSTATE(\" +se.getSQLState() +\")\" +\n\t\t\t\t\t\tse.getMessage());\n\t se.printStackTrace(System.out);\n     }\n",
    "86190": "\tprotected void dumpRS(ResultSet rs) throws SQLException {\n\t\tdumpRS(IGNORE_PROC_ID, rs);\n\t}\n",
    "86192": "\tprotected Connection createConnection(String[] args) throws Exception {\n\n\t\tConnection con;\n\n\t\t// use the ij utility to read the property file and\n\t\t// make the initial connection.\n\t\tij.getPropertyArg(args);\n\t\tcon = ij.startJBMS();\n\t\t//con.setAutoCommit(true); // make sure it is true\n\t\tcon.setAutoCommit(false);\n\n\t\treturn con;\n\n\t}\n",
    "86244": "\tpublic void unlatch(Latch heldLatch) {\n\t\tlockTable.unlock(heldLatch, 1);\n\t}\n",
    "86250": "\tprotected boolean setPotentiallyGranted() {\n\t\tif (!potentiallyGranted) {\n\t\t\tpotentiallyGranted = true;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "86252": "\tprotected void clearPotentiallyGranted() {\n\t\tpotentiallyGranted = false;\n\t}\n",
    "86261": "\tpublic Control shallowClone() {\n\t\treturn this;\n\t}\n",
    "86264": "\tpublic void unlockGroup(Object compatabilitySpace, Object group) {\n\n\t\tif (SanityManager.DEBUG) {\n\t\t\tif (SanityManager.DEBUG_ON(Constants.LOCK_TRACE)) {\n\t\t\t\tD_LockControl.debugLock(\"Lock Unlock Group: \", compatabilitySpace, group);\n\t\t\t}\n\t\t}\n\n\t\tLockSpace ls = (LockSpace) get(compatabilitySpace);\n\t\tif (ls == null)\n\t\t\treturn;\n\n\t\tls.unlockGroup(lockTable, group);\n\t}\n",
    "86275": "\tpublic boolean anyoneBlocked() {\n\t\treturn lockTable.anyoneBlocked();\n\t}\n",
    "86278": "\tpublic boolean areLocksHeld(Object compatabilitySpace, Object group) {\n\n\t\tLockSpace ls = (LockSpace) get(compatabilitySpace);\n\t\tif (ls == null)\n\t\t\treturn false;\n\n\t\t// there is a window where someone could remove the LockSpace from the \n        // spaces Hashtable, since we do not hold the spaces' monitor. This is \n        // Ok as the LockSpace will have no locks and this method will \n        // correctly return false.\n\n\t\treturn ls.areLocksHeld(group);\n\t}\n",
    "86280": "\tpublic boolean areLocksHeld(Object compatabilitySpace) {\n\t\tLockSpace ls = (LockSpace) get(compatabilitySpace);\n\t\tif (ls == null)\n\t\t\treturn false;\n\t\treturn !ls.isEmpty();\n\t}\n",
    "86286": "\tpublic void clearLimit(Object compatabilitySpace, Object group) {\n\t\tLockSpace ls = (LockSpace) get(compatabilitySpace);\n\t\tif (ls == null)\n\t\t\treturn;\n\n\t\tls.clearLimit(group);\n\t}\n",
    "86287": "\tpublic ActiveLock firstWaiter() {\n\t\tif ((waiting == null) || waiting.isEmpty())\n\t\t\treturn null;\n\t\treturn (ActiveLock) waiting.get(0);\n\t}\n",
    "86289": "\tpublic Lockable getLockable() {\n\t\treturn ref;\n\t}\n",
    "86301": "\tpublic void addWaiters(Dictionary waiters) {\n\t\t\n\t\tif ((waiting == null) || waiting.isEmpty())\n\t\t\treturn;\n\n\t\tObject previous = this;\n\t\tfor (ListIterator li = waiting.listIterator(); li.hasNext(); ) {\n\n\t\t\tActiveLock waitingLock = ((ActiveLock) li.next());\n\n\t\t\tObject waiter = waitingLock.getCompatabilitySpace();\n\n\t\t\twaiters.put(waiter, waitingLock);\n\t\t\twaiters.put(waitingLock, previous);\n\t\t\tprevious = waitingLock;\n\t\t}\n\t}\n",
    "86311": "\tprivate Object popFrontWaiter(List waiting, LockSet ls) {\n\t\t// Maintain count of waiters\n\t\tls.oneLessWaiter();\n\n\t\t// Remove and return the first lock request\n\t\treturn waiting.remove(0);\n\t}\n",
    "86329": "    private void cpArray( String toCp, int start, int end )\n    {   // build a field in the output string\n        int i = 0;\n        int totalAllowWrite = end - start;\n\n        if( toCp != null )\n        {\n            for( ; i < toCp.length() ; i++ )\n            {\n                if( (totalAllowWrite-i) == 0 )\n                    break;\n\n                outputRow[ i + start ] = toCp.charAt(i);\n            }\n        }\n        for( ; i + start != end; i++ )\n            outputRow[ i + start ] = ' ';\n\n        outputRow[ end ] = SEPARATOR;\n    }\n",
    "86343": "\tpublic void notifyModifyClasspath(String classpath) throws StandardException {\n\n\t\tif (applicationLoader != null) {\n\t\t\tapplicationLoader.modifyClasspath(classpath);\n\t\t}\n\t}\n",
    "86362": "\tprivate InputStream getRawStream(ZipFile zip, String name) {\n\n\t\ttry {\n\t\t\tZipEntry ze = zip.getEntry(name);\n\t\t\tif (ze == null)\n\t\t\t\treturn null;\n\n\t\t\treturn zip.getInputStream(ze);\n\t\t} catch (IOException ioe) {\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "86364": "\tprivate InputStream getRawStream(InputStream in, String name) { \n\n\t\tZipInputStream zipIn = null;\n\t\ttry {\n\t\t\tzipIn = new ZipInputStream(in);\n\n\t\t\tZipEntry ze;\n\t\t\twhile ((ze = jf.getNextEntry(zipIn)) != null) {\n\n\t\t\t\tif (ze.getName().equals(name)) {\n\t\t\t\t\tLimitInputStream lis = new LimitInputStream(zipIn);\n\t\t\t\t\tlis.setLimit((int) ze.getSize());\n\t\t\t\t\treturn lis;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tzipIn.close();\n\n\t\t} catch (IOException ioe) {\n\t\t\tif (zipIn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tzipIn.close();\n\t\t\t\t} catch (IOException ioe2) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "86371": "\tprivate HeaderPrintWriter makeStream() {\n\n\t\t// get the header\n\t\tPrintWriterGetHeader header = makeHeader();\n\t\tHeaderPrintWriter hpw = makeHPW(header);\n\n\t\t// If hpw == null then no properties were specified for the stream\n\t\t// so use/create the default stream.\n\t\tif (hpw == null)\n\t\t\thpw = createDefaultStream(header);\n\t\treturn hpw;\n\t}\n",
    "86372": "\tprivate PrintWriterGetHeader makeHeader() {\n\n\t\treturn new BasicGetLogHeader(true, true, (String) null);\n\t}\n",
    "86373": "\tprivate HeaderPrintWriter makeHPW(PrintWriterGetHeader header) {\n\n\t\t// the type of target is based on which property is used\n\t\t// to set it. choices are file, method, field, stream\n\n\t\tString target = PropertyUtil.\n                   getSystemProperty(Property.ERRORLOG_FILE_PROPERTY);\n\t\tif (target!=null)\n\t\t\treturn makeFileHPW(target, header);\n\n\t\ttarget = PropertyUtil.\n                   getSystemProperty(Property.ERRORLOG_METHOD_PROPERTY);\n\t\tif (target!=null) \n\t\t\treturn makeMethodHPW(target, header);\n\n\t\ttarget = PropertyUtil.\n                   getSystemProperty(Property.ERRORLOG_FIELD_PROPERTY);\n\t\tif (target!=null) \n\t\t\treturn makeFieldHPW(target, header);\n\n\t\treturn null;\n\t}\n",
    "86379": "\tprivate HeaderPrintWriter createDefaultStream(PrintWriterGetHeader header) {\n\t\treturn makeFileHPW(\"derby.log\", header);\n\t}\n",
    "86380": "\tprivate HeaderPrintWriter useDefaultStream(PrintWriterGetHeader header) {\n\n\t\treturn new BasicHeaderPrintWriter(System.err, header, false, \"System.err\");\n\t}\n",
    "86384": "\tpublic void keepAfterSearch() {\n\t\tkeepCount++;\n\t\tsetUsed(true);\n\t}\n",
    "86392": "\tpublic Cacheable getEntry() {\n\t\treturn entry;\n\t}\n",
    "86414": "\tpublic void cleanAll() throws StandardException {\n\t\tstat.cleanAll++;\n\t\tcleanCache((Matchable) null);\n\t}\n",
    "86417": "\tpublic void clean(Matchable partialKey) throws StandardException {\n\n\t\tcleanCache(partialKey);\n\t}\n",
    "86422": "\tpublic void shutdown() throws StandardException {\n\n\t\tif (cleaner != null) {\n\t\t\tcleaner.unsubscribe(myClientNumber);\n\t\t\tcleaner = null;\n\t\t}\n\n\t\tsynchronized (this) {\n\t\t\tactive = false;\n\t\t}\n\n\t\tageOut();\n\t\tcleanAll();\n\t\tageOut();\n\t}\n",
    "86461": "\tpublic Object put(Object key, Object value) {\n\t\tObject ref = defaults.put(key, value);\n\t\tif (!((String) key).startsWith(Property.PROPERTY_RUNTIME_PREFIX))\n\t\t\tupdate();\n\t\treturn ref;\n\t}\n",
    "86462": "\tpublic Object remove(Object key) {\n\t\tObject ref = defaults.remove(key);\n\t\tif ((ref != null) &&\n\t\t\t(!((String) key).startsWith(Property.PROPERTY_RUNTIME_PREFIX)))\n\t\t\tupdate();\n\t\treturn ref;\n\t}\n",
    "86474": "\tpublic void shutdown(Object serviceModule) {\n\t\tif (serviceModule == null)\n\t\t\treturn;\n\n\t\tTopService ts = findTopService(serviceModule);\n\t\tif (ts == null)\n\t\t\treturn;\n\n\t\t// shutdown() returns false if the service is already being shutdown\n\t\tboolean removeService = true;\n\t\ttry {\n\t\t\tremoveService = ts.shutdown();\n\t\t} finally {\n\t\t\tsynchronized (this) {\n\t\t\t\tif (removeService) {\n\t\t\t\t\tboolean found = services.removeElement(ts);\n\t\t\t\t\tif (SanityManager.DEBUG) {\n\t\t\t\t\t\tSanityManager.ASSERT(found, \"service was not found \" + serviceModule);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "86484": "\tpublic String getServiceName(Object serviceModule) {\n\n\t\tTopService ts = findTopService(serviceModule);\n\n\t\tif (ts == null)\n\t\t\treturn null;\n\n\t\treturn ts.getServiceType().getUserServiceName(ts.getKey().getIdentifier());\n\t}\n",
    "86488": "\tprotected long removeIdentity(CachedItem item) {\n\n        long shrink = 1;\n        \n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(!item.isKept(), \"item is kept\");\n\t\t\tSanityManager.ASSERT(item.isValid(), \"item is not valid\");\n\n\t\t}\n\n        if( useByteCount)\n            shrink = ((SizedCacheable) item.getEntry()).getSize();\n\t\tremove(item.getEntry().getIdentity());\t\t\t\t\n\t\titem.setValidState(false);\n        validItemCount--;\n\t\titem.getEntry().clearIdentity();\n        if( useByteCount)\n        {\n            shrink -= ((SizedCacheable) item.getEntry()).getSize();\n            currentByteCount -= shrink;\n        }\n        return shrink;\n\t}\n",
    "86493": "\tpublic PersistentService getServiceType(Object serviceModule) {\n\t\tTopService ts = findTopService(serviceModule);\n\n\t\tif (ts == null)\n\t\t\treturn null;\n\n\t\treturn ts.getServiceType();\n\t}\n",
    "86522": "\tprotected void report(String message)\t{\n\n\t\tPrintWriter tpw = getTempWriter();\n\n\t\tif (tpw != null)\n\t\t\ttpw.println(message);\n\n\t\tif (systemStreams != null)\n\t\t\tsystemStreams.stream().printlnWithHeader(message);\n\t}\n",
    "86570": "\tprotected void bootServiceProviders() {\n\n\t\tif (serviceProviders == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Enumeration e = serviceProviders.keys(); e.hasMoreElements(); ) {\n\n\t\t\tString serviceType = (String) e.nextElement();\n\t\t\tObject provider = serviceProviders.get(serviceType);\n\n\t\t\t// see if this provider can live in this environment\n\t\t\tif (!BaseMonitor.canSupport(provider, (Properties) null)) {\n\t\t\t\tserviceProviders.remove(serviceType);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n",
    "86574": "\tprotected void bootPersistentServices() {\n\t\tfor (Enumeration e = new ProviderEnumeration( applicationProperties); ; ) {\n\n\t\t\tPersistentService provider = (PersistentService) e.nextElement();\n\t\t\tbootProviderServices(provider);\n\t\t}\n\n\t}\n",
    "86575": "\tpublic int getRelativePC() {\n\t\treturn cout.size() - codeOffset;\n\t}\n",
    "86576": "\tpublic LocalField addField(String javaType, String name, int modifiers) {\n\n\t\tType type = factory.type(javaType);\n\t\t// put it into the class holder right away.\n\t\tClassMember field = classHold.addMember(name, type.vmName(), modifiers);\n\t\tint cpi = classHold.addFieldReference(field);\n\n\t\treturn new BCLocalField(type, cpi);\n\t}\n",
    "86595": "\tpublic String getName() {\n\t\treturn myName;\n\t}\n",
    "86600": "\tpublic void addThrownException(String exceptionClass) {\n\t\t\n\t\t// cannot add exceptions after code generation has started.\n\t\t// Allowing this would cause the method overflow/split to\n\t\t// break as the top-level method would not have the exception\n\t\t// added in the sub method.\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tif (myCode.getRelativePC() != 0)\n\t\t\t\tSanityManager.THROWASSERT(\"Adding exception after code generation \" + exceptionClass\n\t\t\t\t\t\t+ \" to method \" + getName());\n\t\t}\n\n\t\tif (thrownExceptions == null)\n\t\t\tthrownExceptions = new Vector();\n\t\tthrownExceptions.addElement(exceptionClass);\n\t}\n",
    "86601": "\tpublic void complete() {\n\t\t// write exceptions attribute info\n\t\twriteExceptions();\n\t\t\n\t\t// get the code attribute to put itself into the class\n\t\t// provide the final header information needed\n\t\tmyCode.complete(modClass, myEntry, maxStack, currentVarNum);\n\t}\n",
    "86635": "\tpublic UUIDFactory getUUIDFactory()\t{\n\n\t\treturn uuidFactory;\n\t}\n",
    "86648": "\tpublic ResourceBundle getBundle(String messageId) {\n\t\tContextManager cm;\n\t\ttry {\n\t\t\tcm = ContextService.getFactory().getCurrentContextManager();\n\t\t} catch (ShutdownException se) {\n\t\t\tcm = null;\n\t\t}\n\n\t\tif (cm != null) {\n\t\t\treturn MessageService.getBundleForLocale(cm.getMessageLocale(), messageId);\n\t\t}\n\t\treturn null;\n\t}\n",
    "86663": "\tpublic void getStaticField(String declaringClass, String fieldName, String fieldType) {\n\t\tgetField(VMOpcode.GETSTATIC, declaringClass, fieldName, fieldType);\n\t}\n",
    "86667": "\tpublic void setField(LocalField field) {\n\t\tBCLocalField lf = (BCLocalField) field;\n\t\tType lt = lf.type;\n\n\t\tputField(lf.type, lf.cpi, false);\n\n\t\tif (stackDepth == 0)\n\t\t\toverflowMethodCheck();\n\t}\n",
    "86669": "\tpublic void putField(LocalField field) {\n\t\tBCLocalField lf = (BCLocalField) field;\n\t\tType lt = lf.type;\n\n\t\tputField(lf.type, lf.cpi, true);\n\t}\n",
    "86675": "\tpublic void boot(boolean create, Properties properties) throws StandardException {\n\n\t\tCacheFactory cf =\n\t\t\t(CacheFactory) Monitor.startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory);\n\n\t\t/*\n\t\t** The initial and maximum cache sizes are based on experiments\n\t\t** that I did with some of the language tests.  I found that\n\t\t** the size quickly grew to about 40, then continued to grow\n\t\t** slowly after that.\n\t\t**\n\t\t**\t\t\t-\tJeff\n\t\t*/\n\t\tvmTypeIdCache =\n\t\t\tcf.newCacheManager(\n\t\t\t\tthis,\n\t\t\t\t\"VMTypeIdCache\",\n\t\t\t\t64,\n\t\t\t\t256);\n\t}\n",
    "86677": "\tpublic void stop() {\n\t}\n",
    "86700": "\tprotected void TC004all() throws StandardException, T_Fail {\n\t\tint[] modes = {\n\t\t\t0,\n\t\t\tContainerHandle.MODE_DROP_ON_COMMIT,\n\t\t\tContainerHandle.MODE_TRUNCATE_ON_COMMIT\n\t\t};\n\n\t\tfor (int m1 = 0; m1 < modes.length; m1++) {\n\t\t\tfor (int m2 = 0; m2 < modes.length; m2++) {\n\t\t\t\tfor (int m3 = 0; m3 < modes.length; m3++) {\n\n\t\t\t\t\tTC004(m1, m2, m3, false, false);\n\t\t\t\t\tTC004(m1, m2, m3, false, true);\n\t\t\t\t\tTC004(m1, m2, m3, true, false);\n\t\t\t\t\tTC004(m1, m2, m3, true, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n",
    "86718": "  public ResultSetMetaData getMetaData() {\n    return importResultSetMetaData;\n  }\n",
    "86719": "  public int getRow() throws SQLException {\n    return (importReadData.getCurrentRowNumber());\n  }\n",
    "86721": "  public void close() throws SQLException {\n    try {\n\t\tif(importReadData!=null)\n\t\t\timportReadData.closeStream();\n    } catch (Exception ex) {\n\t\tthrow LoadError.unexpectedError(ex);\n    }\n  }\n",
    "86736": "\tprotected ImportReadData getImportReadData() throws Exception {\n\t\treturn new ImportReadData(inputFileName, controlFileReader);\n\t}\n",
    "86758": "  protected void ignoreFirstRow() throws Exception {\n    readNextToken(recordSeparator, 0, recordSeparatorLength, true);\n  }\n",
    "86775": "  public void closeStream() throws Exception {\n    if (streamOpenForReading) {\n       bufferedReader.close();\n       streamOpenForReading = false;\n    }\n  }\n",
    "86834": "  public int getCurrentRowNumber() {\n    return lineNumber;\n  }\n",
    "86844": "\tpublic ResultColumnDescriptor getColumnDescriptor(int position) {\n\t\treturn columns[position-1];\n\t}\n",
    "86861": "\tpublic boolean isActive() {\n\t\treturn active;\n\t}\n",
    "86981": "\tpublic\tint\tgetTypeFormatId()\t{\n\t\treturn majorVersionNumber == DataDictionary.DD_VERSION_CS_5_1 ?\n\t\t\tStoredFormatIds.DD_ARWEN_VERSION_ID : StoredFormatIds.DD_DB2J72_VERSION_ID;\n\t}\n",
    "87063": "\tpublic void setDroppedInSavepointLevel(int droppededInSavepointLevel) {\n    this.droppededInSavepointLevel = droppededInSavepointLevel;\n  }\n",
    "87076": "\tpublic GenericPreparedStatement getPreparedStatement() {\n\t\treturn ps;\n\t}\n",
    "87090": "\tpublic void resetSavePoint() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tif (SanityManager.DEBUG_ON(\"traceSavepoints\"))\n\t\t\t{\n\t\t\t\tSanityManager.DEBUG_PRINT(\n\t\t\t\t\t\"GenericStatementContext.resetSavePoint()\",\n\t\t\t\t\tinternalSavePointName);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tif (inUse && setSavePoint)\n\t\t{\t\t\n\t\t\t// RESOLVE PLUGIN ???. For the plugin, there will be no transaction controller\n\t\t\tif ( tc != null ) { tc.setSavePoint(internalSavePointName, null); }\n\t\t\t// stage buffer management\n\t\t}\n\t}\n",
    "87117": "\tpublic void setParentRollback() {\n\t\trollbackParentContext = true;\n\t}\n",
    "87118": "\tpublic void setSystemCode() {\n\t\tisSystemCode = true;\n\t}\n",
    "87120": "\tpublic boolean getSystemCode() {\n\t\treturn isSystemCode;\n\t}\n",
    "87135": "\tpublic ExecutionFactory\tgetExecutionFactory() {\n\t\treturn ef;\n\t}\n",
    "87139": "\tpublic OptimizerFactory\tgetOptimizerFactory() {\n\t\treturn of;\n\t}\n",
    "87140": "\tpublic TypeCompilerFactory getTypeCompilerFactory() {\n\t\treturn tcf;\n\t}\n",
    "87141": "\tpublic DataValueFactory\t\tgetDataValueFactory() {\n\t\treturn dvf;\n\t}\n",
    "87144": "\tpublic boolean canSupport(Properties startParams) {\n\n\t\treturn Monitor.isDesiredType( startParams, EngineType.STANDALONE_DB);\n\t}\n",
    "87173": "\tpublic void boot(boolean create, Properties startParams) throws StandardException \n\t{\t\t\n\t\tLanguageConnectionFactory lcf = (LanguageConnectionFactory)  Monitor.findServiceModule(this, LanguageConnectionFactory.MODULE);\n\t\tPropertyFactory pf = lcf.getPropertyFactory();\n\t\tif (pf != null)\n\t\t\tpf.addPropertySetNotification(new LanguageDbPropertySetter());\n\n\t\temptySet = new GenericParameterValueSet(null, 0, false);\n\t}\n",
    "87202": "\tpublic void addActivation(Activation a) {\n\t\tacts.addElement(a);\n\n\t\tif (SanityManager.DEBUG) {\n\n\t\t\tif (SanityManager.DEBUG_ON(\"memoryLeakTrace\")) {\n\n\t\t\t\tif (acts.size() > 20)\n\t\t\t\t\tSystem.out.println(\"memoryLeakTrace:GenericLanguageContext:activations \" + acts.size());\n\t\t\t}\n\t\t}\n\t}\n",
    "87210": "\tprotected void clearProviderDependency(UUID p, Dependency d) {\n\t\tList deps = (List) providers.get(p);\n\n\t\tif (deps == null)\n\t\t\treturn;\n\n\t\tdeps.remove(d);\n\n\t\tif (deps.size() == 0)\n\t\t\tproviders.remove(p);\n\t}\n",
    "87237": "\tpublic UUID getProviderKey() {\n\t\treturn provider.getObjectID();\n\t}\n",
    "87238": "\tpublic Provider getProvider() {\n\t\treturn provider;\n\t}\n",
    "87239": "\tpublic Dependent getDependent() {\n\t\treturn dependent;\n\t}\n",
    "87264": "\tpublic boolean checkNoDeclaredOutputParameters() {\n\n\t\tboolean hasDeclaredOutputParameter = false;\n\t\tfor (int i=0; i<parms.length; i++) {\n\n\t\t\tGenericParameter gp = parms[i];\n\n\t\t\tswitch (gp.parameterMode) {\n\t\t\tcase JDBC30Translation.PARAMETER_MODE_IN:\n\t\t\t\tbreak;\n\t\t\tcase JDBC30Translation.PARAMETER_MODE_IN_OUT:\n\t\t\tcase JDBC30Translation.PARAMETER_MODE_OUT:\n\t\t\t\thasDeclaredOutputParameter = true;\n\t\t\t\tbreak;\n\t\t\tcase JDBC30Translation.PARAMETER_MODE_UNKNOWN:\n\t\t\t\tgp.parameterMode = JDBC30Translation.PARAMETER_MODE_IN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn hasDeclaredOutputParameter;\n\t}\n",
    "87281": "\tpublic OrderByColumn getOrderByColumn(int position) {\n\t\tif (SanityManager.DEBUG)\n\t\tSanityManager.ASSERT(position >=0 && position < size());\n\t\treturn (OrderByColumn) elementAt(position);\n\t}\n",
    "87283": "\tpublic void printSubNodes(int depth) {\n\n\t\tif (SanityManager.DEBUG) \n\t\t{\n\t\t\tfor (int index = 0; index < size(); index++)\n\t\t\t{\n\t\t\t\t( (OrderByColumn) (elementAt(index)) ).treePrint(depth);\n\t\t\t}\n\t\t}\n\t}\n",
    "87297": "\tpublic int getActivationCount() {\n\t\treturn acts.size();\n\t}\n",
    "87307": "\tpublic CursorActivation lookupCursorActivation(String cursorName) {\n\n\t\tint size = acts.size();\n\t\tif (size > 0)\n\t\t{\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t Activation a = (Activation) acts.elementAt(i);\n\n\t\t\t\t if (!a.isInUse())\n\t\t\t\t {\n\t\t\t\t\tcontinue;\n\t\t\t\t }\n\n\n\n\t\t\t\tString executingCursorName = a.getCursorName();\n\n\t\t\t\t if (cursorName.equals(executingCursorName)) {\n\n\t\t\t\t\tResultSet rs = a.getResultSet();\n\t\t\t\t\tif (rs == null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t // if the result set is closed, the the cursor doesn't exist\n\t\t\t\t\t if (rs.isClosed()) {\t\t\t\t\t\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t }\n\n\t\t\t\t \treturn (CursorActivation)a;\n\t\t\t\t }\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "87313": "\tpublic String getReceiverInterfaceName() {\n\t    return ClassName.DataValueDescriptor;\n\t}\n",
    "87439": "\tpublic DataValueFactory getDataValueFactory() {\n\t\treturn dataFactory;\n\t}\n",
    "87443": "\tpublic LanguageFactory getLanguageFactory() {\n\t\treturn langFactory;\n\t}\n",
    "87448": "\tpublic LanguageConnectionFactory getLanguageConnectionFactory() {\n\t\treturn connFactory;\n\t}\n",
    "87479": "\tpublic void emptyCache() {\n\t\t/* We know prepared statements don't become dirty\n\t\t** statementCache.cleanAll(); \n\t\t*/\n\t\tif (statementCache != null)\n\t\t\tstatementCache.ageOut(); \n\t}\n",
    "87554": "\tpublic\tint\t\tgetStatementDepth()\n\t{ return statementDepth; }\n",
    "87621": "\tprivate void finishDDTransaction() throws StandardException {\n\n\t\t/* Was the data dictionary put into write mode? */\n\t\tif (ddWriteMode) {\n\t\t\tDataDictionary dd = getDataDictionary();\n\n\t\t\t/* Tell the data dictionary that the transaction is finished */\n\t\t\tdd.transactionFinished();\n\n\t\t\t/* The data dictionary isn't in write mode any more */\n\t\t\tddWriteMode = false;\n\t\t}\n\t}\n",
    "87664": "\tpublic String toString() {\n\t\tif (SanityManager.DEBUG) {\n\t\t\treturn expression.toString();\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n",
    "87665": "\tpublic void setDescending() {\n\t\tascending = false;\n\t}\n",
    "87666": "\tpublic boolean isAscending() {\n\t\treturn ascending;\n\t}\n",
    "87831": "\tpublic String getReceiverInterfaceName() {\n\t    return ClassName.ConcatableDataValue;\n\t}\n",
    "87990": "\tpublic String getReceiverInterfaceName() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(receiver!=null,\"can't get receiver interface name until receiver is set\");\n\t\t}\n\n\t\treturn receiver.getTypeCompiler().interfaceName();\n\t}\n",
    "88021": "\tpublic void init(Object field, Object operand) {\n\t\textractField = ((Integer) field).intValue();\n\t\tsuper.init( operand,\n\t\t\t\t\t\"EXTRACT \"+fieldName[extractField],\n\t\t\t\t\tfieldMethod[extractField] );\n\t}\n",
    "88329": "    public\tString\tgetPackageName()\n\t{\treturn\tCodeGeneration.GENERATED_PACKAGE_PREFIX; }\n",
    "88330": "\tpublic String getBaseClassName() {\n\t    return ClassName.BaseActivation;\n\t}\n",
    "88994": "\tpublic String getReceiverInterfaceName() {\n\t    return ClassName.StringDataValue;\n\t}\n",
    "89015": "\t//public int\tgetLength() throws StandardException {\n\t//\treturn TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN;\n\t//}\n",
    "89233": "\tpublic void printSubNodes(int depth) {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tsuper.printSubNodes(depth);\n\n\t\t\tprintLabel(depth, \"cursor: \");\n\t\t}\n\t}\n",
    "89234": "\tpublic String toString() {\n\t\tif (SanityManager.DEBUG) {\n\t\t\treturn \"preparedStatement: \" +\n\t\t    \t(preStmt == null? \"no prepared statement yet\\n\" :\n\t\t\t \tpreStmt.toString() + \"\\n\")+\n\t\t\t\tcursorName + \"\\n\" +\n\t\t\t\tsuper.toString();\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n",
    "89467": "\tpublic boolean checkVersion(int requiredMajorVersion, String feature) throws StandardException {\n\n\t\tif (requiredMajorVersion == DataDictionary.DD_VERSION_CURRENT) {\n\t\t\trequiredMajorVersion = softwareVersion.majorVersionNumber;\n\t\t}\n\n\t\treturn dictionaryVersion.checkVersion(requiredMajorVersion, feature);\n\t}\n",
    "89612": "\tpublic String getReceiverInterfaceName() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(operand!=null,\n\t\t\t\t\t\t\t\t\"cannot get interface without operand\");\n\t\t}\n\n\t\tif (operatorType != -1)\n\t\t\treturn receiverInterfaceType;\n\t\t\n\t\treturn operand.getTypeCompiler().interfaceName();\n\t}\n",
    "89786": "\tpublic MethodBuilder getExecuteMethod() {\n\t\treturn executeMethod;\n\t}\n",
    "89795": "\tpublic MethodBuilder newGeneratedFun(String returnType, int modifiers) {\n\n\t\treturn newGeneratedFun(returnType, modifiers,\n\t\t\t\t\t\t\t   (String[]) null);\n\t}\n",
    "89803": "\tpublic void pushMethodReference(MethodBuilder mb, MethodBuilder exprMethod) {\n\n\t\tmb.pushThis(); // instance\n\t\tmb.push(exprMethod.getName()); // arg\n\t\tmb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.GeneratedByteCode,\n\t\t\t\t\"getMethod\",\n\t\t\t\tClassName.GeneratedMethod,\n\t\t\t\t1\n\t\t\t\t);\n\t}\n",
    "89804": "\tpublic MethodBuilder newUserExprFun() {\n\n\t\tMethodBuilder mb = newExprFun();\n\t\tmb.addThrownException(\"java.lang.Exception\");\n\t\treturn mb;\n\t}\n",
    "89806": "\tpublic void getCurrentDateExpression(MethodBuilder mb) {\n\t\t// do any needed setup\n\t\tLocalField lf = getCurrentSetup();\n\n\t\t// generated Java:\n\t\t//\t  this.cdt.getCurrentDate();\n\t\tmb.getField(lf);\n\t\tmb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, \"getCurrentDate\", \"java.sql.Date\", 0);\n\t}\n",
    "89807": "\tpublic void getCurrentTimeExpression(MethodBuilder mb) {\n\t\t// do any needed setup\n\t\tLocalField lf = getCurrentSetup();\n\n\t\t// generated Java:\n\t\t//\t  this.cdt.getCurrentTime();\n\t\tmb.getField(lf);\n\t\tmb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, \"getCurrentTime\", \"java.sql.Time\", 0);\n\t}\n",
    "89809": "\tpublic void getCurrentTimestampExpression(MethodBuilder mb) {\n\t\t// do any needed setup\n\t\tLocalField lf = getCurrentSetup();\n\n\t\t// generated Java:\n\t\t//\t  this.cdt.getCurrentTimestamp();\n\t\tmb.getField(lf);\n\t\tmb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null,\n\t\t\t\"getCurrentTimestamp\", \"java.sql.Timestamp\", 0);\n\t}\n",
    "89823": "\tpublic void pushResultSetClosedMethodFieldAccess(MethodBuilder mb) {\n\t\tif (resultSetClosedMethod != null)\n\t\t\tpushMethodReference(mb, resultSetClosedMethod);\n\t\telse\n\t\t\tmb.pushNull(ClassName.GeneratedMethod);\n\t}\n",
    "89827": "\t//private void pushRowArrayReference(MethodBuilder mb)\n\t//{ \t\t\n\t\t// PUSHCOMPILE - cache\n\t//\tmb.pushThis();\n\t//\tmb.getField(ClassName.BaseActivation, \"row\", ClassName.ExecRow + \"[]\");\n\t//}\n",
    "89836": "\tpublic GeneratedClass getGeneratedClass(ByteArray savedBytes) throws StandardException {\n\t\tif (gc != null) return gc;\n\n\t\tif (savedBytes != null)\n\t\t{\n\t\t\tByteArray classBytecode = cb.getClassBytecode();\n\n\t\t\t// note: be sure to set the length since\n\t\t\t// the class builder allocates the byte array\n\t\t\t// in big chunks\n\t\t\tsavedBytes.setBytes(classBytecode.getArray());\n\t\t\tsavedBytes.setLength(classBytecode.getLength());\n\t\t}\n\n\t    gc =  cb.getGeneratedClass();\n\n\t\treturn gc; // !! yippee !! here it is...\n\t}\n",
    "89838": "\tpublic void pushThisAsActivation(MethodBuilder mb) {\n\t\t// PUSHCOMPILER - WASCACHED\n\t\tmb.pushThis();\n\t\tmb.upCast(ClassName.Activation);\n\t}\n",
    "89839": "\tpublic void generateNull(MethodBuilder mb, TypeCompiler tc) {\n\t\tpushDataValueFactory(mb);\n\t\tmb.pushNull(tc.interfaceName());\n\t\ttc.generateNull(mb);\n\t}\n",
    "89841": "\tpublic void generateNullWithExpress(MethodBuilder mb, TypeCompiler tc) {\n\t\tpushDataValueFactory(mb);\n\t\tmb.swap(); // need the dvf as the instance\n\t\tmb.cast(tc.interfaceName());\n\t\ttc.generateNull(mb);\n\t}\n",
    "89842": "\tpublic void generateDataValue(MethodBuilder mb, TypeCompiler tc, LocalField field) {\n\t\tpushDataValueFactory(mb);\n\t\tmb.swap(); // need the dvf as the instance\n\t\ttc.generateDataValue(mb, field);\n\t}\n",
    "89962": "\tpublic\tString\t\tgetSQLtext()\n\t{\treturn\tSQLtext; }\n",
    "90128": "\tpublic\tNodeFactory\tgetNodeFactory()\n\t{\treturn lcf.getNodeFactory(); }\n",
    "90195": "\tpublic void addWarning(SQLWarning warning) {\n\t\tif (warnings == null)\n\t\t\twarnings = warning;\n\t\telse\n\t\t\twarnings.setNextWarning(warning);\n\t}\n",
    "90197": "\tpublic SQLWarning getWarnings() {\n\t\treturn warnings;\n\t}\n",
    "90348": "\tpublic void checkReliability(ValueNode sqlNode) throws StandardException {\n        sqlNode.checkReliability( \n                CompilerContext.FUNCTION_CALL_ILLEGAL,\n                SQLState.LANG_JAVA_METHOD_CALL_OR_FIELD_REF\n                );\n\t}\n",
    "90419": "\tpublic void setSingleExecution() {\n\t\tac.setSingleExecution();\n\t}\n",
    "90420": "\tpublic boolean isSingleExecution() {\n\t\treturn ac.isSingleExecution();\n\t}\n",
    "90422": "\tpublic int getNumSubqueries() {\n\t\treturn ac.getNumSubqueries();\n\t}\n",
    "90466": "\tpublic RowLocation getRowLocation() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.ASSERT(source instanceof CursorResultSet, \"source not instance of CursorResultSet\");\n\t\treturn ( (CursorResultSet)source ).getRowLocation();\n\t}\n",
    "90528": "\tpublic void\topenCore() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t    \tSanityManager.ASSERT( ! isOpen, \"CurrentOfResultSet already open\");\n\n\t\t// get the cursor\n\t\tgetCursor();\n\n\t\tnext = false;\n\t    isOpen = true;\n\t}\n",
    "90536": "\tpublic RowLocation getRowLocation()  {\n\t\treturn rowLocation;\n\t}\n",
    "90671": "\tpublic RowLocation getRowLocation() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.ASSERT(source instanceof CursorResultSet, \"source is not CursorResultSet\");\n\t\treturn ( (CursorResultSet)source ).getRowLocation();\n\t}\n",
    "90739": "\tpublic RowLocation getRowLocation() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"Join used in positioned update/delete\");\n\t\treturn null;\n\t}\n",
    "90740": "\tpublic ExecRow getCurrentRow() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"Join used in positioned update/delete\");\n\t\treturn null;\n\t}\n",
    "90770": "\tpublic boolean\tisClosed() {\n\t    return ( ! isOpen );\n\t}\n",
    "90774": "\tpublic ResultDescription getResultDescription() {\n\t    return resultDescription;\n\t}\n",
    "90797": "\tpublic\tboolean\tupToDate()\n\t{ return true; }\n",
    "90915": "\tpublic ResultDescription getResultDescription() {\n\t    return activation.getResultDescription();\n\t}\n",
    "90917": "\tpublic String getCursorName() {\n\n\t\tString cursorName = activation.getCursorName();\n\t\tif ((cursorName == null) && isForUpdate()) {\n\n\t\t\tactivation.setCursorName(activation.getLanguageConnectionContext().getUniqueCursorName());\n\n\t\t\tcursorName = activation.getCursorName();\n\t\t}\n\n\t\treturn cursorName;\n\t}\n",
    "90924": "\tpublic RowLocation getRowLocation() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"RowResultSet used in positioned update/delete\");\n\t\treturn null;\n\t}\n",
    "90928": "\tpublic ExecRow getCurrentRow() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"RowResultSet used in positioned update/delete\");\n\t\treturn null;\n\t}\n",
    "90977": "\tpublic void\treopenCore() throws StandardException {\n\t\tTransactionController\t\ttc;\n\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(isOpen,\n\t\t\t\t\t\"HashScanResultSet already open\");\n\t\t}\n\n\t\tbeginTime = getCurrentTimeMillis();\n\n\t\tresetProbeVariables();\n\n\t\tnumOpens++;\n\t\topenTime += getElapsedMillis(beginTime);\n\t}\n",
    "90994": "\tpublic boolean isClosed() {\n\t\treturn isClosed;\n\t\t//return true;\n\t}\n",
    "91015": "\tpublic String getCursorName() {\n\t\treturn null;\n\t}\n",
    "91061": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_ROW_RS);\n  }\n",
    "91066": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_PR);\n  }\n",
    "91071": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_UPDATE);\n  }\n",
    "91074": "  public Vector getChildren(){\n    return new Vector();\n  }\n",
    "91076": "  public long getTotalTime(){\n    //The method below is the original calculation.  However, the constructor\n    //time was found to be inaccurate, and was therefore removed from the calculation.\n\t  //return constructorTime + openTime + nextTime + closeTime;\n\t  return openTime + nextTime + closeTime;\n  }\n",
    "91077": "  public long getChildrenTime(){\n    long childrenTime = 0;\n    java.util.Enumeration e = getChildren().elements();\n    while (e.hasMoreElements()){\n      childrenTime = childrenTime + ((RealBasicNoPutResultSetStatistics)e.nextElement()).getTotalTime();\n    }\n    return childrenTime;\n  }\n",
    "91080": "  public long getNodeTime(){\n    return getTotalTime() - getChildrenTime();\n  }\n",
    "91088": "  public String getNodeName(){\n\treturn MessageService.getTextMessage(\n\t\t\t\tindexName == null ?\n\t\t\t\tSQLState.RTS_TABLE_SCAN :\n\t\t\t\tSQLState.RTS_INDEX_SCAN);\n  }\n",
    "91097": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_HASH_SCAN);\n  }\n",
    "91104": "  public Vector getChildren(){\n    Vector children = new Vector();\n    children.addElement(sourceResultSetStatistics);\n    return children;\n  }\n",
    "91112": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_DELETE_VTI);\n  }\n",
    "91121": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_IRTBR);\n  }\n",
    "91130": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_SORT);\n  }\n",
    "91133": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_VTI);\n  }\n",
    "91141": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_INSERT_VTI);\n  }\n",
    "91142": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_MATERIALIZED_RS);\n  }\n",
    "91149": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_DISTINCT_SCALAR_AGG);\n  }\n",
    "91150": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_SCROLL_INSENSITIVE_RS);\n  }\n",
    "91157": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_NORMALIZE_RS);\n  }\n",
    "91158": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_GROUPED_AGG);\n  }\n",
    "91159": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_JOIN);\n  }\n",
    "91166": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_INSERT);\n  }\n",
    "91175": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_ONCE_RS);\n  }\n",
    "91178": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_UNION);\n  }\n",
    "91182": "  public String getNodeName(){\n\t// NOTE: Not internationalizing because \"CURRENT OF\" are keywords.\n    return \"Current Of\";\n  }\n",
    "91187": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_ANY_RS);\n  }\n",
    "91188": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_DELETE_CASCADE);\n  }\n",
    "91193": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_DELETE);\n  }\n",
    "91202": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_HASH_TABLE);\n  }\n",
    "91208": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_SCALAR_AGG);\n  }\n",
    "91244": "  public Vector getChildren(){\n    Vector children = new Vector();\n    children.addElement(topResultSetStatistics);\n    return children;\n  }\n",
    "91279": "\tpublic ResultDescription getResultDescription() {\n\t    return source1.getResultDescription();\n\t}\n",
    "91286": "\tpublic RowLocation getRowLocation() throws StandardException {\n\t    switch (whichSource) {\n\t        case 1 : \n\t\t\t\tif (SanityManager.DEBUG)\n\t\t\t\t\tSanityManager.ASSERT(source1 instanceof CursorResultSet, \"source not CursorResultSet\");\n\t\t\t\treturn ((CursorResultSet)source1).getRowLocation();\n\t        case 2 : \n\t\t\t\tif (SanityManager.DEBUG)\n\t\t\t\t\tSanityManager.ASSERT(source2 instanceof CursorResultSet, \"source2 not CursorResultSet\");\n\t\t\t\treturn ((CursorResultSet)source2).getRowLocation();\n\t        default: \n\t\t\t\tif (SanityManager.DEBUG)\n\t\t\t\t\tSanityManager.THROWASSERT( \"Bad source number in union\" );\n\t            return null;\n\t    }\n\t}\n",
    "91292": "\tpublic void forget() {\n\t\tcurrentDatetime = null;\n\t\tcurrentDate = null;\n\t\tcurrentTime = null;\n\t\tcurrentTimestamp = null;\n\t}\n",
    "91330": "\tpublic void markAsTopResultSet()\n\t{ }\n",
    "91411": "\tpublic ExecRow\tgetNextRowCore() throws StandardException {\n\n\t\tcurrentRow = null;\n\t\tbeginTime = getCurrentTimeMillis();\n\t\tif (isOpen) \n\t\t{\n\t\t\tif (!next) \n\t\t\t{\n\t            next = true;\n\t\t\t\tif (currentRow == null)\n\t\t\t\t{\n\t\t\t\t\tif (cachedRow != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentRow = cachedRow;\n\t\t\t\t\t}\n\t\t\t\t\telse if (row != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentRow = (ExecRow) row.invoke(activation);\n\t\t\t\t\t\tif (canCacheRow)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcachedRow = currentRow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trowsReturned++;\n\t\t\t}\n\t\t\tsetCurrentRow(currentRow);\n\n\t\t\tnextTime += getElapsedMillis(beginTime);\n\t    }\n\t    return currentRow;\n\t}\n",
    "91490": "\tpublic String getReferencedTableName()\n\t{ return tableName; }\n",
    "91491": "\tpublic int getReferentialActionUpdateRule()\n\t{ return raUpdateRule; }\n",
    "91493": "\tpublic int getReferentialActionDeleteRule()\n\t{ return raDeleteRule; }\n",
    "91567": "\tprotected void closeActivationAction() throws Exception {\n\t\t// no code to be added here as generated code\n\t\t// will not call super.closeActivationAction()\n\t}\n",
    "91570": "\tpublic boolean isClosed() {\n\t\treturn closed;\n\t}\n",
    "91573": "\tpublic void setSingleExecution() {\n\t\tsingleExecution = true;\n\t}\n",
    "91576": "\tpublic boolean isSingleExecution() {\n\t\treturn singleExecution;\n\t}\n",
    "91579": "\tpublic int getNumSubqueries() {\n\t\treturn numSubqueries;\n\t}\n",
    "91621": "\tpublic String getCursorName() {\n\n\t\treturn isCursorActivation() ? cursorName : null;\n\t}\n",
    "91632": "\tpublic ResultSetFactory getResultSetFactory() {\n\t\treturn rsFactory;\n\t}\n",
    "91636": "\tpublic ExecutionFactory getExecutionFactory() {\n\t\treturn exFactory;\n\t}\n",
    "91638": "\tpublic CursorResultSet getTargetResultSet() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"Must be overridden to be used.\");\n\t\treturn null;\n\t}\n",
    "91642": "\tpublic CursorResultSet getCursorResultSet() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"Must be overridden to be used.\");\n\t\treturn null;\n\t}\n",
    "91643": "\tpublic void throwIfClosed(String op) throws StandardException {\n\t\tif (closed)\n\t\t\tthrow StandardException.newException(SQLState.LANG_ACTIVATION_CLOSED, op);\n\t}\n",
    "91735": "\tpublic void\treopenCore() throws StandardException {\n\t\tTransactionController\t\ttc;\n\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(isOpen,\n\t\t\t\t\t\"IndexRowToBaseRowResultSet already open\");\n\t\t}\n\n\t\tbeginTime = getCurrentTimeMillis();\n\n\t\tsource.reopenCore();\n\n\t\tnumOpens++;\n\t\topenTime += getElapsedMillis(beginTime);\n\t}\n",
    "91741": "\tpublic RowLocation getRowLocation() throws StandardException {\n\t\treturn baseRowLocation;\n\t}\n",
    "91760": "\tpublic Connection getCurrentConnection() throws SQLException {\n\n\t\tConnectionContext cc = \n\t\t\t(ConnectionContext) cm.getContext(ConnectionContext.CONTEXT_ID);\n\n\t\treturn cc.getNestedConnection(true);\n\t}\t\n",
    "91763": "\tpublic int getMaxDynamicResults() {\n\t\treturn 0;\n\t}\n",
    "91880": "\tpublic boolean isValid() {\n\t\treturn isValid;\n\t}\n",
    "91942": "\tpublic int\tgetUpdateMode() {\n\t\treturn updateMode;\n\t}\n",
    "91988": "    public String nativeSQL(String sql) {\n\t\t// we don't massage the strings at all, so this is easy:\n\t\treturn sql;\n\t}\n",
    "91992": "\tpublic void setAutoCommit(boolean autoCommit) throws SQLException {\n\n\t\t// Is this a nested connection\n\t\tif (rootConnection != this) {\n\t\t\tif (autoCommit)\n\t\t\t\tthrow newSQLException(SQLState.NO_AUTO_COMMIT_ON);\n\t\t}\n\n\t\tif (this.autoCommit != autoCommit)\n\t\t\tcommit();\n\n\t\tthis.autoCommit = autoCommit;\n\t}\n",
    "91995": "    public boolean getAutoCommit() {\n\t\treturn autoCommit;\n\t}\n",
    "91998": "    public void commit() throws SQLException {\n\t\tsynchronized (getConnectionSynchronization())\n\t\t{\n\t\t\t/*\n\t\t\t** Note that the context stack is\n\t\t\t** needed even for rollback & commit\n\t\t\t*/\n            setupContextStack();\n\n\t\t\ttry\n\t\t\t{\n\t\t    \tgetTR().commit();\n\t\t\t}\n            catch (Throwable t)\n\t\t\t{\n\t\t\t\tthrow handleException(t);\n\t\t\t}\n\t\t\tfinally \n\t\t\t{\n\t\t\t\trestoreContextStack();\n\t\t\t}\n\n\t\t\tneedCommit = false;\n\t\t}\n\t}\n",
    "92002": "    public void rollback() throws SQLException {\n\n\t\tsynchronized (getConnectionSynchronization())\n\t\t{\n\t\t\t/*\n\t\t\t** Note that the context stack is\n\t\t\t** needed even for rollback & commit\n\t\t\t*/\n            setupContextStack();\n\t\t\ttry\n\t\t\t{\n\t\t    \tgetTR().rollback();\n\t\t\t} catch (Throwable t) {\n\t\t\t\tthrow handleException(t);\n\t\t\t}\n\t\t\tfinally \n\t\t\t{\n\t\t\t\trestoreContextStack();\n\t\t\t}\n\t\t\tneedCommit = false;\n\t\t} \n\t}\n",
    "92005": "    public void close() throws SQLException {\n\t\t// JDK 1.4 javadoc indicates close on a closed connection is a no-op\n\t\tif (isClosed())\n\t\t   \treturn;\n\n\n\t\tif (rootConnection == this)\n\t\t{\n\t\t\t/* Throw error to match DB2/JDBC if a tran is pending in non-autocommit mode */\n\t\t\tif (!autoCommit && !transactionIsIdle()) {\n\t\t\t\tthrow newSQLException(SQLState.LANG_INVALID_TRANSACTION_STATE);\n\t\t\t}\n\n\t\t\tclose(exceptionClose);\n\t\t}\n\t\telse\n\t\t\tsetInactive(); // nested connection\n\t}\n",
    "92011": "    public DatabaseMetaData getMetaData() throws SQLException {\n\t\tif (isClosed())\n\t\t\tthrow Util.noCurrentConnection();\n\n\t\tif (dbMetadata == null) {\n\n \t\t\t// There is a case where dbname can be null.\n\t\t\t// Replication client of this method does not have a\n\t\t\t// JDBC connection; therefore dbname is null and this\n\t\t\t// is expected.\n\t\t\t//\n\t\t\tdbMetadata = factory.newEmbedDatabaseMetaData(this, getTR().getUrl());\n\t\t}\n\t\treturn dbMetadata;\n\t}\n",
    "92016": "    public void setCatalog(String catalog) throws SQLException {\n\t\t// silently ignoring this request like the javadoc said.\n\t\treturn;\n\t}\n",
    "92020": "\tpublic String getCatalog() throws SQLException {\n\t\t// we do not have support for Catalog, just return null as\n\t\t// the JDBC specs mentions then.\n\t\treturn null;\n\t}\n",
    "92035": "    protected void needCommit() {\n\t\tif (!needCommit) needCommit = true;\n\t}\n",
    "92070": "\tprotected void finalize() throws Throwable {\n\t\tsuper.finalize();\n\n\t\t/*\n\t\t** We mark the activation as not being used and\n\t \t** that is it.  We rely on the connection to sweep\n\t\t** through the activations to find the ones that\n\t\t** aren't in use, and to close them.  We cannot\n\t \t** do a activation.close() here because there are\n\t\t** synchronized methods under close that cannot\n\t\t** be called during finalization.\n\t\t*/\n\t\tif (activation != null) \n\t\t{\n\t\t\tactivation.markUnused();\n\t\t}\n\t}\n",
    "92071": "\tprotected void closeActions() throws SQLException {\n\n\t\t//we release the resource for preparedStatement\n\t\tpreparedStatement = null;\n\n\t\ttry{\n\t\t\tsetupContextStack();\n\t\t} catch (SQLException se) {\n\t\t\t//we may have already committed the transaction in which case\n\t\t\t//setupContextStack will fail, the close should just return\n\t\t\treturn;\n\t\t}\n\t\ttry\n\t\t{\n\t\t    activation.close();\n\t\t\tactivation = null;\n\t\t} catch (Throwable t)\n\t\t{\n\t\t\tthrow handleException(t);\n\t\t} finally {\n\t\t    restoreContextStack();\n\t\t}\n\t}\n",
    "92073": "    public void setNull(int parameterIndex, int sqlType) throws SQLException {\n\n\t\tcheckStatus();\n\n\t\tint jdbcTypeId = getParameterJDBCType(parameterIndex);\n\t\t\n\t\tif (!DataTypeDescriptor.isJDBCTypeEquivalent(jdbcTypeId, sqlType)) {\n\n\t\t\tthrow dataTypeConversion(parameterIndex, Util.typeName(sqlType));\n\t\t}\n\t\t\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setToNull();\n\t\t} catch (StandardException t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\n\t}\n",
    "92074": "    public void setBoolean(int parameterIndex, boolean x) throws SQLException {\n\t\t\n\t\tcheckStatus();\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (StandardException t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\t}\n",
    "92077": "    public void setByte(int parameterIndex, byte x) throws SQLException {\n\n\t\tcheckStatus();\n\t\ttry {\n\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\t}\n",
    "92079": "    public void setShort(int parameterIndex, short x) throws SQLException {\n\n\t\tcheckStatus();\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\t}\n",
    "92081": "    public void setInt(int parameterIndex, int x) throws SQLException {\n\t\tcheckStatus();\n\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\t}\n",
    "92082": "    public void setLong(int parameterIndex, long x) throws SQLException {\n\t\tcheckStatus();\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\n\t}\n",
    "92084": "    public void setFloat(int parameterIndex, float x) throws SQLException {\n\t\tcheckStatus();\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\n\t}\n",
    "92085": "    public void setDouble(int parameterIndex, double x) throws SQLException {\n\t\tcheckStatus();\n\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\n\t}\n",
    "92089": "    public void setString(int parameterIndex, String x) throws SQLException {\n\t\tcheckStatus();\t\t\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\t}\n",
    "92091": "\tpublic void resetFromPool() throws SQLException {\n\t\tsynchronized (getConnectionSynchronization())\n\t\t{\n\t\t\tsetupContextStack();\n\t\t\ttry {\n\t\t\t\tgetLanguageConnection().resetFromPool();\n\t\t\t} catch (StandardException t) {\n\t\t\t\tthrow handleException(t);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\trestoreContextStack();\n\t\t\t}\n\t\t}\n\t}\n",
    "92092": "    public void setBytes(int parameterIndex, byte x[]) throws SQLException {\n\t\tcheckStatus();\n\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\n\t}\n",
    "92093": "    public void setDate(int parameterIndex, Date x) throws SQLException {\n        setDate( parameterIndex, x, (Calendar) null);\n\t}\n",
    "92095": "    public void setTime(int parameterIndex, Time x) throws SQLException {\n        setTime( parameterIndex, x, (Calendar) null);\n\t}\n",
    "92110": "    public void clearParameters() throws SQLException {\n\t\tcheckStatus();\n\n\t\tParameterValueSet pvs = getParms();\n\t\tif (pvs != null)\n\t\t\tpvs.clearParameters();\n\t}\n",
    "92129": "\tpublic int getColumnCount()\t{\n\t\treturn columnInfo == null ? 0 : columnInfo.length;\n\t}\n",
    "92130": "\tpublic boolean isAutoIncrement(int column) throws SQLException\t{\n\n\t\tResultColumnDescriptor rcd = columnInfo[column - 1];\n\t\treturn rcd.isAutoincrement();\n\t}\n",
    "92132": "\tpublic boolean isCaseSensitive(int column) throws SQLException\t{\n\t  return DataTypeUtilities.isCaseSensitive(getColumnTypeDescriptor(column));\n\t}\n",
    "92133": "\tpublic boolean isSearchable(int column) throws SQLException\t{\n\t\tvalidColumnNumber(column);\n\n\t\t// we have no restrictions yet, so this is always true\n\t\t// might eventually be false for e.g. extra-long columns?\n\t\treturn true;\n\t}\n",
    "92134": "\tpublic boolean isCurrency(int column) throws SQLException\t{\n\n\t\treturn DataTypeUtilities.isCurrency(getColumnTypeDescriptor(column));\n\t}\n",
    "92135": "\tpublic int isNullable(int column) throws SQLException\t{\n\t\treturn DataTypeUtilities.isNullable(getColumnTypeDescriptor(column));\n\t}\n",
    "92136": "\tpublic boolean isSigned(int column) throws SQLException\t{\n\t\treturn DataTypeUtilities.isSigned(getColumnTypeDescriptor(column));\n\t}\n",
    "92138": "\tpublic int getColumnDisplaySize(int column) throws SQLException\t{\n\t\treturn DataTypeUtilities.getColumnDisplaySize(getColumnTypeDescriptor(column));\n\t}\n",
    "92139": "\tpublic String getColumnLabel(int column) throws SQLException {\n\t\tResultColumnDescriptor cd = columnInfo[column - 1];\n\t\tString s = cd.getName();\n\n\t\t// we could get fancier than this, but it's simple\n    \treturn (s==null? \"Column\"+Integer.toString(column) : s);\n\t}\n",
    "92140": "\tpublic String getColumnName(int column) throws SQLException\t{\n\t\tResultColumnDescriptor cd = columnInfo[column - 1];\n\t\tString s = cd.getName();\n\t\t// database returns null when no column name to differentiate from empty name\n    \treturn (s==null? \"\" : s);\n\n\t}\n",
    "92141": "\tpublic String getSchemaName(int column) throws SQLException\t{\n\t\tResultColumnDescriptor cd = columnInfo[column - 1];\n\n\t\tString s = cd.getSourceSchemaName();\n\t\t// database returns null when no schema name to differentiate from empty name\n\t\treturn (s==null? \"\" : s);\n\t}\n",
    "92142": "\tpublic int getPrecision(int column) throws SQLException\t{\n\t\treturn DataTypeUtilities.getDigitPrecision(getColumnTypeDescriptor(column));\n\t}\n",
    "92144": "\tpublic int getScale(int column) throws SQLException\t{\n\t\tDataTypeDescriptor dtd = getColumnTypeDescriptor(column);\n\t\t// REMIND -- check it is valid to ask for scale\n\t\treturn dtd.getScale();\n\t}\n",
    "92145": "\tpublic String getTableName(int column) throws SQLException {\n\t\tResultColumnDescriptor cd = columnInfo[column - 1];\n\t\tString s = cd.getSourceTableName();\n\n\t\t// database returns null when no table name to differentiate from empty name\n\t\treturn (s==null? \"\" : s);\n\t}\n",
    "92146": "\tpublic String getCatalogName(int column) throws SQLException {\n\t\tvalidColumnNumber(column);\n\t\treturn \"\";\n\t}\n",
    "92147": "\tpublic int getColumnType(int column) throws SQLException {\n\t\tDataTypeDescriptor dtd = getColumnTypeDescriptor(column);\n\t\treturn dtd.getTypeId().getJDBCTypeId();\n\t}\n",
    "92149": "\tpublic String toString() {\n\t\treturn \"SQL Warning: \" + getMessage();\n\t}\n",
    "92150": "\tpublic String getColumnTypeName(int column) throws SQLException\t{\n\t\tDataTypeDescriptor dtd = getColumnTypeDescriptor(column);\n\t\treturn dtd.getTypeId().getSQLTypeName();\n\t}\n",
    "92153": "\tpublic boolean isReadOnly(int column) throws SQLException {\n\t\tvalidColumnNumber(column);\n\n\t\t// we just don't know if it is a base table column or not\n\t\treturn false;\n\t}\n",
    "92157": "\tpublic boolean isWritable(int column) throws SQLException {\n\t\tvalidColumnNumber(column);\n\t\treturn columnInfo[column - 1].updatableByCursor();\n\t}\n",
    "92160": "\tpublic boolean isDefinitelyWritable(int column) throws SQLException\t{\n\t\tvalidColumnNumber(column);\n\n\t\t// we just don't know if it is a base table column or not\n\t\treturn false;\n\t}\n",
    "92175": "\tprotected void finalize() throws Throwable {\n\t\tsuper.finalize();\n\n\t\tif (finalizeActivation != null) {\n\t\t\tfinalizeActivation.markUnused();\n\t\t}\t\t\n\t}\n",
    "92184": "\tpublic int getMaxFieldSize() throws SQLException {\n\t\tcheckStatus();\n\n        return MaxFieldSize;\n\t}\n",
    "92192": "\tpublic void setEscapeProcessing(boolean enable) throws SQLException\t{\n\t\tcheckStatus();\n        // Nothing to do in our server , just ignore it.\n\n\t}\n",
    "92193": "\tpublic int getQueryTimeout() throws SQLException {\n        // Currently Cloudscape does not support any sort of timeout, so always\n        // return 0, which means that timeout is unlimited.\n        return(0);\n\t}\n",
    "92195": "\tpublic void setQueryTimeout(int seconds) throws SQLException {\n\t\tif (seconds != 0)\n\t\t\tthrow Util.notImplemented(\"setQueryTimeout\");\n\t}\n",
    "92196": "\tpublic void cancel() throws SQLException {\n\t\tthrow Util.notImplemented(\"cancel\");\n\t}\n",
    "92198": "\tpublic SQLWarning getWarnings() throws SQLException\t{\n\t\tcheckStatus();\n\t\treturn warnings;\n\t}\n",
    "92199": "\tpublic void clearWarnings() throws SQLException\t{\n\t\tcheckStatus();\n\t\twarnings = null;\n\t}\n",
    "92202": "\tpublic void setCursorName(String name) throws SQLException {\n\t\tcheckStatus();\n\t\tcursorName = name;\n\t}\n",
    "92207": "    public ResultSetMetaData getMetaData() throws SQLException {\n\n\t  checkIfClosed(\"getMetaData\");\t// checking result set closure does not depend\n\t\t\t\t\t\t\t\t// on the underlying connection.  Do this\n\t\t\t\t\t\t\t\t// outside of the connection synchronization.\n\n\t  synchronized (getConnectionSynchronization()) {\n\n\n\t\tif (rMetaData == null) {\n\t\t\t// cache this object and keep returning it\n\t\t\trMetaData = newEmbedResultSetMetaData(resultDescription);\n\t\t}\n\t\treturn rMetaData;\n\t  }\n\t}\n",
    "92226": "\tprotected boolean executeBatchElement(Object batchElement) throws SQLException, StandardException {\n\t\treturn execute((String)batchElement, false, true, JDBC30Translation.NO_GENERATED_KEYS, null, null);\n\t}\n",
    "92241": "\tpublic void transferBatch(EmbedStatement other) throws SQLException {\n\t\t\n\t\tsynchronized (getConnectionSynchronization()) {\n\t\t\tother.batchStatements = batchStatements;\n\t\t\tbatchStatements = null;\n\t\t}\n\t}\n",
    "92266": "\tpublic void printStackTrace() {\n\t\tThrowable je = getJavaException();\n\t\tif (je != null)\n\t\t\tje.printStackTrace();\n\t\telse\n\t\t\tsuper.printStackTrace();\n\t}\n",
    "92267": "\tpublic void printStackTrace(PrintStream s) {\n\t\tThrowable je = getJavaException();\n\t\tif (je != null)\n\t\t\tje.printStackTrace(s);\n\t\telse\n\t\t\tsuper.printStackTrace(s);\n\t}\n",
    "92268": "\tpublic void printStackTrace(PrintWriter s) {\n\t\tThrowable je = getJavaException();\n\t\tif (je != null)\n\t\t\tje.printStackTrace(s);\n\t\telse\n\t\t\tsuper.printStackTrace(s);\n\t}\n",
    "92269": "\tpublic String toString() {\n\t\treturn \"SQL Exception: \" + getMessage();\n\t}\n",
    "92277": "\tpublic String getProperty(String key) {\n\n\t\tString propertyValue = null;\n\t\tTransactionController tc = null;\n\n\t\ttry {\n\n\t\t  if (store != null)\n          {\n            tc = store.getTransaction(\n                ContextService.getFactory().getCurrentContextManager());\n          }\n\n\t\t  propertyValue =\n\t\t\tPropertyUtil.getServiceProperty(tc,\n\t\t\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\t\t\t(String) null);\n\t\t  if (tc != null) {\n\t\t\ttc.commit();\n\t\t\ttc = null;\n\t\t  }\n\n\t\t} catch (StandardException se) {\n\t\t\t// Do nothing and just return\n\t\t}\n\n\t\treturn propertyValue;\n\t}\n",
    "92286": "\tpublic boolean canSupport(Properties properties) {\n\n\t\tif (!requireAuthentication(properties))\n\t\t\treturn false;\n\n\t\t//\n\t\t// We check 2 System/Database properties:\n\t\t//\n\t\t//\n\t\t// - if derby.authentication.provider is set to 'BUILTIN'.\n\t\t//\n\t\t// and in that case we are the authentication service that should\n\t\t// be run.\n\t\t//\n\n\t\tString authenticationProvider = PropertyUtil.getPropertyFromSet(\n\t\t\t\t\tproperties,\n\t\t\t\t\torg.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_PARAMETER);\n\n\t\tif ( (authenticationProvider != null) &&\n\t\t\t (authenticationProvider.length() != 0) &&\n\t\t\t (!(StringUtil.SQLEqualsIgnoreCase(authenticationProvider,\n\t\t\t\t  org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_BUILTIN))))\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\t// Yep, we're on!\n\t}\n",
    "92289": "\tpublic boolean canSupport(Properties properties) {\n\n\t\tif (!requireAuthentication(properties))\n\t\t\treturn false;\n\n\t\t//\n\t\t// we check 2 things:\n\t\t//\n\t\t// - if derby.connection.requireAuthentication system\n\t\t//   property is set to true.\n\t\t// - if derby.authentication.provider is set to one\n\t\t// of the JNDI scheme we support (i.e. LDAP).\n\t\t//\n\n\t\tauthenticationProvider = PropertyUtil.getPropertyFromSet(\n\t\t\t\t\tproperties,\n\t\t\t\t\t\torg.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_PARAMETER);\n\n\t\t if ( (authenticationProvider != null) &&\n\t\t\t   (StringUtil.SQLEqualsIgnoreCase(authenticationProvider,\n\t\t\t\t  \torg.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_LDAP)))\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n",
    "92299": "\tprivate void setInitDirContextEnv(Properties dbProps) {\n\n\t\t//\n\t\t// We retrieve JNDI properties set at the database level\t\n\t\t// if any.\n\t\t//\n\t\tinitDirContextEnv = new Properties();\n\n\t\tfor (Enumeration keys = dbProps.propertyNames(); keys.hasMoreElements(); ) {\n\n\t\t\tString key = (String) keys.nextElement();\n\n\t\t\tif (key.startsWith(\"java.naming.\")) {\n\t\t\t\tinitDirContextEnv.put(key, dbProps.getProperty(key));\n\t\t\t}\n\t\t}\n\t}\n",
    "92300": "\tpublic boolean canSupport(Properties properties) {\n\n\t\treturn !requireAuthentication(properties);\n\t}\n",
    "92303": "\tpublic int read() throws IOException {\n\n\t\tif (dummyBytes != 0) {\n\t\t\tdummyBytes--;\n\t\t\treturn 0;\n\t\t}\n\n\t\tint ret = super.read();\n\n\t\tif (ret < 0)\n\t\t\tcheckSufficientData();\n\n\t\treturn ret;\n\t}\n",
    "92305": "\tpublic int read(byte b[], int off, int len) throws IOException {\n\n\t\tint dlen = dummyBytes;\n\n\t\tif (dlen != 0) {\n\t\t\tif (len < dlen)\n\t\t\t\tdlen = len;\n\t\t\tfor (int i = 0; i < dlen; i++) {\n\t\t\t\tb[off+i] = 0;\n\t\t\t}\n\t\t\tdummyBytes -= dlen;\n\n\t\t\toff += dlen;\n\t\t\tlen -= dlen;\n\t\t}\n\n\t\tint realRead = super.read(b, off, len);\n\n\t\tif (realRead < 0)\n\t\t{\n\t\t\tif (dlen != 0)\n\t\t\t\treturn dlen;\n\n\t\t\tcheckSufficientData();\n\n\t\t\treturn realRead;\n\t\t}\n\n\t\treturn dlen + realRead;\n\t}\n",
    "92353": "\tpublic boolean allProceduresAreCallable() {\n\t\treturn true;\n\t}\n",
    "92356": "\tpublic boolean allTablesAreSelectable() {\n\t\treturn true;\n\t}\n",
    "92359": "\tpublic String getUserName() {\n\t\treturn (getEmbedConnection().getTR().getUserName());\n\t}\n",
    "92360": "\tpublic boolean isReadOnly() {\n\t\treturn getLanguageConnectionContext().getDatabase().isReadOnly();\n\t}\n",
    "92364": "\tpublic boolean nullsAreSortedHigh() {\n\t\treturn true;\n\t}\n",
    "92365": "\tpublic boolean nullsAreSortedLow() {\n\t\treturn false;\n\t}\n",
    "92367": "\tpublic boolean nullsAreSortedAtStart() {\n\t\treturn false;\n\t}\n",
    "92369": "\tpublic boolean nullsAreSortedAtEnd() {\n\t\treturn false;\n\t}\n",
    "92372": "\tpublic String getDatabaseProductName() {\n\t\treturn Monitor.getMonitor().getEngineVersion().getProductName();\n\t}\n",
    "92374": "\tpublic String getDatabaseProductVersion() {\n\t\tProductVersionHolder myPVH = Monitor.getMonitor().getEngineVersion();\n\n\t\treturn myPVH.getVersionBuildString(false);\n\t}\n",
    "92376": "\tpublic String getDriverName() {\n\t\treturn \"Apache Derby Embedded JDBC Driver\";\n\t}\n",
    "92380": "\tpublic String getDriverVersion()  {\n\t\treturn getDatabaseProductVersion();\n\t}\n",
    "92381": "\tpublic int getDriverMajorVersion() {\n\t\treturn getEmbedConnection().getLocalDriver().getMajorVersion();\n\t}\n",
    "92383": "\tpublic int getDriverMinorVersion() {\n\t\treturn getEmbedConnection().getLocalDriver().getMinorVersion();\n\t}\n",
    "92386": "\tpublic boolean usesLocalFiles() {\n\t\treturn true;\n\t}\n",
    "92388": "\tpublic boolean usesLocalFilePerTable() {\n\t\treturn true;\n\t}\n",
    "92390": "\tpublic boolean supportsMixedCaseIdentifiers() {\n\t\treturn false;\n\t}\n",
    "92392": "\tpublic boolean storesUpperCaseIdentifiers() {\n\t\treturn true;\n\t}\n",
    "92395": "\tpublic boolean storesLowerCaseIdentifiers() {\n\t\treturn false;\n\t}\n",
    "92397": "\tpublic boolean storesMixedCaseIdentifiers() {\n\t\treturn false;\n\t}\n",
    "92400": "\tpublic boolean supportsMixedCaseQuotedIdentifiers() {\n\t\treturn true;\n\t}\n",
    "92402": "\tpublic boolean storesUpperCaseQuotedIdentifiers() {\n\t\treturn false;\n\t}\n",
    "92404": "\tpublic boolean storesLowerCaseQuotedIdentifiers() {\n\t\treturn false;\n\t}\n",
    "92405": "\tpublic boolean storesMixedCaseQuotedIdentifiers() {\n\t\treturn true;\n\t}\n",
    "92409": "\tpublic String getIdentifierQuoteString() {\n\t\treturn \"\\\"\";\n\t}\n",
    "92411": "\tpublic String getSQLKeywords() {\n\t\treturn \"ALIAS,BIGINT,BOOLEAN,CALL,CLASS,COPY,DB2J_DEBUG,EXECUTE,EXPLAIN,FILE,FILTER,\"\n\t\t\t+  \"GETCURRENTCONNECTION,INDEX,INSTANCEOF,METHOD,NEW,OFF,PROPERTIES,PUBLICATION,RECOMPILE,\"\n\t\t\t+  \"REFRESH,RENAME,RUNTIMESTATISTICS,STATEMENT,STATISTICS,TIMING,WAIT\";\n\t}\n",
    "92412": "\tpublic String getNumericFunctions() {\n\t\treturn \"ABS,SQRT\";\n\t}\n",
    "92415": "\tpublic String getStringFunctions() {\n\t\treturn \"LENGTH,LOWER,LTRIM,RTRIM,SUBSTR,SUBSTRING,UPPER\";\n\t}\n",
    "92418": "\tpublic String getSystemFunctions()  {\n\t\treturn \"CURRENT_USER,getCurrentConnection,runTimeStatistics,SESSION_USER,USER,CURRENT SCHEMA\";\n\t}\n",
    "92420": "\tpublic String getTimeDateFunctions() {\n\t\treturn \"CURDATE,CURTIME,CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,EXTRACT\";\n\t}\n",
    "92422": "\tpublic String getSearchStringEscape()  {\n\t\treturn \"\";\n\t}\n",
    "92425": "\tpublic String getExtraNameCharacters()  {\n\t\treturn \"\";\n\t}\n",
    "92427": "\tpublic boolean supportsAlterTableWithAddColumn() {\n\t\treturn true;\n\t}\n",
    "92429": "\tpublic boolean supportsAlterTableWithDropColumn() {\n\t\treturn true;\n\t}\n",
    "92432": "\tpublic boolean supportsColumnAliasing() {\n\t\treturn true;\n\t}\n",
    "92433": "\tpublic boolean nullPlusNonNullIsNull()  {\n\t\treturn true;\n\t}\n",
    "92437": "\tpublic boolean supportsConvert() {\n\t\treturn true;\n\t}\n",
    "92440": "\tpublic boolean supportsConvert(int fromType, int toType) {\n\t\t/*\n\t\t * at the moment we don't support CONVERT at all, so we take the easy\n\t\t * way out.  Eventually we need to figure out how to handle this\n\t\t * cleanly.\n\t\t */\n\t\treturn false;\n\t}\n",
    "92441": "\tpublic boolean supportsTableCorrelationNames()  {\n\t\treturn true;\n\t}\n",
    "92444": "\tpublic boolean supportsDifferentTableCorrelationNames() {\n\t\treturn true;\n\t}\n",
    "92446": "\tpublic boolean supportsExpressionsInOrderBy() {\n\t\treturn false;\n\t}\n",
    "92448": "\tpublic boolean supportsOrderByUnrelated() {\n\t\treturn false;\n\t}\n",
    "92450": "\tpublic boolean supportsGroupBy() {\n\t\treturn true;\n\t}\n",
    "92454": "\tpublic boolean supportsGroupByUnrelated()  {\n\t\treturn true;\n\t}\n",
    "92456": "\tpublic boolean supportsGroupByBeyondSelect() {\n\t\treturn true;\n\t}\n",
    "92458": "\tpublic boolean supportsLikeEscapeClause() {\n\t\treturn true;\n\t}\n",
    "92461": "\tpublic boolean supportsMultipleResultSets()  {\n\t\treturn true;\n\t}\n",
    "92462": "\tpublic boolean supportsMultipleTransactions() {\n\t\treturn true;\n\t}\n",
    "92465": "\tpublic boolean supportsNonNullableColumns()  {\n\t\treturn true;\n\t}\n",
    "92466": "\tpublic boolean supportsMinimumSQLGrammar() {\n\t\treturn true;\n\t}\n",
    "92469": "\tpublic boolean supportsCoreSQLGrammar() {\n\t\treturn false;\n\t}\n",
    "92473": "\tpublic boolean supportsExtendedSQLGrammar() {\n\t\treturn false;\n\t}\n",
    "92474": "\tpublic boolean supportsANSI92EntryLevelSQL() {\n\t\treturn false;\n\t}\n",
    "92477": "\tpublic boolean supportsANSI92IntermediateSQL() {\n\t\treturn false;\n\t}\n",
    "92479": "\tpublic boolean supportsANSI92FullSQL() {\n\t\treturn false;\n\t}\n",
    "92481": "\tpublic boolean supportsIntegrityEnhancementFacility() {\n\t\treturn false;\n\t}\n",
    "92483": "\tpublic boolean supportsOuterJoins() {\n\t\treturn true;\n\t}\n",
    "92486": "\tpublic boolean supportsFullOuterJoins()  {\n\t\treturn false;\n\t}\n",
    "92488": "\tpublic boolean supportsLimitedOuterJoins() {\n\t\treturn true;\n\t}\n",
    "92491": "\tpublic String getSchemaTerm() {\n\t\treturn \"SCHEMA\";\n\t}\n",
    "92494": "\tpublic String getProcedureTerm() {\n\t\treturn \"PROCEDURE\";\n\t}\n",
    "92495": "\tpublic String getCatalogTerm() {\n\t\treturn \"CATALOG\";\n\t}\n",
    "92498": "\tpublic boolean isCatalogAtStart() {\n\t\treturn false;\n\t}\n",
    "92500": "\tpublic String getCatalogSeparator() {\n\t\treturn \"\";\n\t}\n",
    "92502": "\tpublic boolean supportsSchemasInDataManipulation() {\n\t\treturn true;\n\t}\n",
    "92505": "\tpublic boolean supportsSchemasInProcedureCalls() {\n\t\treturn true;\n\t}\n",
    "92508": "\tpublic boolean supportsSchemasInTableDefinitions() {\n\t\treturn true;\n\t}\n",
    "92510": "\tpublic boolean supportsSchemasInIndexDefinitions() {\n\t\treturn true;\n\t}\n",
    "92512": "\tpublic boolean supportsSchemasInPrivilegeDefinitions() {\n\t\treturn true;\n\t}\n",
    "92515": "\tpublic boolean supportsCatalogsInDataManipulation() {\n\t\treturn false;\n\t}\n",
    "92517": "\tpublic boolean supportsCatalogsInProcedureCalls() {\n\t\treturn false;\n\t}\n",
    "92519": "\tpublic boolean supportsCatalogsInTableDefinitions() {\n\t\treturn false;\n\t}\n",
    "92522": "\tpublic boolean supportsCatalogsInIndexDefinitions() {\n\t\treturn false;\n\t}\n",
    "92523": "\tpublic boolean supportsCatalogsInPrivilegeDefinitions() {\n\t\treturn false;\n\t}\n",
    "92527": "\tpublic boolean supportsPositionedDelete() {\n\t\treturn true;\n\t}\n",
    "92529": "\tpublic boolean supportsPositionedUpdate() {\n\t\treturn true;\n\t}\n",
    "92532": "\tpublic boolean supportsSelectForUpdate() {\n\t\treturn true;\n\t}\n",
    "92534": "\tpublic boolean supportsStoredProcedures() {\n\t\treturn true;\n\t}\n",
    "92536": "\tpublic boolean supportsSubqueriesInComparisons() {\n\t\treturn true;\n\t}\n",
    "92539": "\tpublic boolean supportsSubqueriesInExists() {\n\t\treturn true;\n\t}\n",
    "92540": "\tpublic boolean supportsSubqueriesInIns() {\n\t\treturn true;\n\t}\n",
    "92547": "\tpublic boolean supportsCorrelatedSubqueries() {\n\t\treturn true;\n\t}\n",
    "92548": "\tpublic boolean supportsUnion() {\n\t\treturn true;\n\t}\n",
    "92551": "\tpublic boolean supportsUnionAll() {\n\t\treturn true;\n\t}\n",
    "92555": "\tpublic boolean supportsOpenCursorsAcrossRollback() {\n\t\treturn false;\n\t}\n",
    "92558": "\tpublic boolean supportsOpenStatementsAcrossCommit() {\n\t\treturn true;\n\t}\n",
    "92561": "\tpublic boolean supportsOpenStatementsAcrossRollback() {\n\t\treturn false;\n\t}\n",
    "92564": "\tpublic int getMaxBinaryLiteralLength() {\n\t\treturn 0;\n\t}\n",
    "92565": "\tpublic int getMaxCharLiteralLength() {\n\t\treturn 0;\n\t}\n",
    "92568": "\tpublic int getMaxColumnNameLength() {\n\t\treturn Limits.MAX_IDENTIFIER_LENGTH;\n\t}\n",
    "92570": "\tpublic int getMaxColumnsInGroupBy() {\n\t\treturn 0;\n\t}\n",
    "92572": "\tpublic int getMaxColumnsInIndex() {\n\t\treturn 0;\n\t}\n",
    "92575": "\tpublic int getMaxColumnsInOrderBy() {\n\t\treturn 0;\n\t}\n",
    "92577": "\tpublic int getMaxColumnsInSelect() {\n\t\treturn 0;\n\t}\n",
    "92580": "\tpublic int getMaxColumnsInTable()  {\n\t\treturn 0;\n\t}\n",
    "92582": "\tpublic int getMaxConnections() {\n\t\treturn 0;\n\t}\n",
    "92585": "\tpublic int getMaxCursorNameLength() {\n\t\treturn Limits.MAX_IDENTIFIER_LENGTH;\n\t}\n",
    "92587": "\tpublic int getMaxIndexLength() {\n\t\treturn 0;\n\t}\n",
    "92589": "\tpublic int getMaxSchemaNameLength()  {\n\t\treturn Limits.MAX_IDENTIFIER_LENGTH;\n\t}\n",
    "92592": "\tpublic int getMaxProcedureNameLength() {\n\t\treturn Limits.MAX_IDENTIFIER_LENGTH;\n\t}\n",
    "92593": "\tpublic int getMaxCatalogNameLength()  {\n\t\treturn 0;\n\t}\n",
    "92597": "\tpublic int getMaxRowSize() {\n\t\treturn 0;\n\t}\n",
    "92600": "\tpublic boolean doesMaxRowSizeIncludeBlobs() {\n\t\treturn true;\n\t}\n",
    "92601": "\tpublic int getMaxStatementLength() {\n\t\treturn 0;\n\t}\n",
    "92604": "\tpublic int getMaxStatements() {\n\t\treturn 0;\n\t}\n",
    "92606": "\tpublic int getMaxTableNameLength() {\n\t\treturn Limits.MAX_IDENTIFIER_LENGTH;\n\t}\n",
    "92615": "\tpublic int getMaxTablesInSelect() {\n\t\treturn 0;\n\t}\n",
    "92622": "\tpublic int getMaxUserNameLength() {\n\t\treturn Limits.DB2_MAX_USERID_LENGTH;\n\t}\n",
    "92630": "\tpublic int getDefaultTransactionIsolation() {\n\t\treturn java.sql.Connection.TRANSACTION_READ_COMMITTED;\n\t}\n",
    "92639": "\tpublic boolean supportsTransactions()  {\n\t\treturn true;\n\t}\n",
    "92656": "\tpublic boolean supportsDataDefinitionAndDataManipulationTransactions() {\n\t\t\t return true;\n\t}\n",
    "92668": "\tpublic boolean dataDefinitionCausesTransactionCommit() {\n\t\treturn false;\n\t}\n",
    "92676": "\tpublic boolean dataDefinitionIgnoredInTransactions(){\n\t\treturn false;\n\t}\n",
    "92771": "\tpublic ResultSet getSchemas() throws SQLException {\n\t\treturn getSimpleQuery(\"getSchemas\");\n\t}\n",
    "92775": "\tpublic ResultSet getCatalogs() throws SQLException {\n\t\treturn getSimpleQuery(\"getCatalogs\");\n\t}\n",
    "92779": "\tpublic ResultSet getTableTypes() throws SQLException {\n\t\treturn getSimpleQuery(\"getTableTypes\");\n\t}\n",
    "92850": "\tpublic ResultSet getTypeInfo() throws SQLException {\n\t\treturn getSimpleQuery(\"getTypeInfo\");\n\t}\n",
    "92854": "\tpublic ResultSet getTypeInfoForODBC() throws SQLException {\n\t\treturn getSimpleQuery(\"odbc_getTypeInfo\");\n\t}\n",
    "92859": "\tpublic void resetCacheStats(String cacheName) {\n\t\tgetRawStoreXact().resetCacheStats(cacheName);\n\t}\n",
    "93292": "\tpublic void writeExternal_v36(ObjectOutput out) throws IOException {\n\t\tsuper.writeExternal(out);\n\t\tout.writeLong(baseConglomerateId);\n\t\tout.writeInt(rowLocationColumn);\n\t}\n",
    "93320": "\tpublic int getColumnId() {\n\t\treturn columnId;\n\t}\n",
    "93321": "\tpublic DataValueDescriptor getOrderable() {\n\t\treturn value;\n\t}\n",
    "93322": "\tpublic int getOperator() {\n\t\treturn DataValueDescriptor.ORDER_OP_EQUALS;\n\n\t}\n",
    "93324": "\tpublic boolean negateCompareResult() {\n\t\treturn false;\n\t}\n",
    "93326": "    public boolean getUnknownRV() {\n\t\treturn false;\n\t}\n",
    "93543": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.ACCESS_HEAP_ROW_LOCATION_V1_ID;\n\t}\n",
    "93631": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_CHECKSUM;\n\t}\n",
    "93688": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_CHECKPOINT;\n\t}\n",
    "93711": "\tpublic long getValueAsLong() {\n\t\treturn makeLogInstantAsLong(fileNumber, filePosition);\n\t}\n",
    "93715": "\tpublic void readExternal(ObjectInput oi) throws IOException, ClassNotFoundException {\n\t\tfileNumber = CompressedNumber.readLong(oi);\n\t\tfilePosition = CompressedNumber.readLong(oi);\n\t}\n",
    "93716": "\tpublic void writeExternal(ObjectOutput oo) throws IOException {\n\t\tCompressedNumber.writeLong(oo,fileNumber);\n\t\tCompressedNumber.writeLong(oo,filePosition);\n\t}\n",
    "93733": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.FILE_STREAM_LOG_FILE;\n\t}\n",
    "93746": "\tpublic int\tgetId() {\n\t\treturn recordId;\n\t}\n",
    "93753": "\tpublic boolean lockerAlwaysCompatible() {\n\t\treturn true;\n\t}\n",
    "93757": "\tpublic boolean equals(Object ref) {\n\n\t\tif (!(ref instanceof RecordId))\n\t\t\treturn false;\n\n\t\tRecordId other = (RecordId) ref;\n\n\t\treturn ((recordId == other.recordId)\n\t\t\t&& pageId.equals(other.pageId));\n\t}\n",
    "93758": "\tpublic int hashCode() {\n\n\t\treturn (int) recordId ^ pageId.hashCode();\n\t}\n",
    "93764": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_INVALIDATE_PAGE;\n\t}\n",
    "93773": "\tpublic void removeContainer() throws StandardException {\n\t\tcontainer.removeContainer();\n\t}\n",
    "93774": "\tpublic Logger getLogger() {\n\n\t\tif (ReadOnlyDB)\n\t\t\treturn null;\n\t\telse\n\t\t\treturn new FileLogger(this);\n\t}\n",
    "93775": "\tpublic ContainerKey getId() {\n\t\treturn identity;\n\t}\n",
    "93777": "\tpublic boolean useContainer() throws StandardException {\n\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(!active);\n\t\t\tSanityManager.ASSERT(container != null);\n\t\t}\n\n\t\t// always set forUpdate to false\n\t\tif (!container.use(this)) {\n\t\t\tcontainer = null;\n\t\t\treturn false;\n\t\t}\n\n\t\tactive = true;\n\n\t\t// watch transaction and close ourseleves just before it completes.\n        if (!hold)\n        {\n            xact.addObserver(this);\n            xact.addObserver(new DropOnCommit(identity, true));\n        }\n\n\t\treturn true;\n\t}\n",
    "93788": "\tpublic Page addPage(int flag) throws StandardException {\n\n\t\tif ((flag & ContainerHandle.ADD_PAGE_BULK) != 0 && active && forUpdate)\n\t\t{\n\t\t\t// start preallocating immediatelly, don't wait for the\n\t\t\t// preallocation threshold to be crossed.  Don't go wild and\n\t\t\t// preallocate a bunch of pages either, use preAllocate for that. \n\t\t\tcontainer.clearPreallocThreshold();\n\t\t}\n\n\t\treturn addPage();\n\t}\n",
    "93879": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_UPDATE;\n\t}\n",
    "93880": "\tpublic int getNextStartColumn() {\n\t\treturn nextColumn;\n\t}\n",
    "93931": "\tpublic Cacheable setIdentity(Object key) throws StandardException {\n\n\t\tContainerKey newIdentity = (ContainerKey) key;\n\n\t\t// if this is an open for a temp container then return an object of that type\n\t\tif (newIdentity.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT) {\n\n\t\t\tTempRAFContainer tmpContainer = new TempRAFContainer(dataFactory);\n\t\t\treturn tmpContainer.setIdent(newIdentity);\n\t\t}\n\n\t\treturn setIdent(newIdentity);\n\t}\n",
    "93950": "\tprotected void flushAll() throws StandardException {\n\n\t\tpageCache.clean(identity);\n\n\t\t// now clean myself which will sync all my pages.\n\t\tclean(false);\n\t}\n",
    "93980": "\tpublic boolean isDirty() {\n\n\t\tsynchronized (this) {\n\t\t\treturn isDirty || preDirty;\n\t\t}\n\t}\n",
    "93981": "\tpublic boolean isActuallyDirty() {\n\n\t\tsynchronized (this) {\n\t\t\treturn isDirty;\n\t\t}\n\t\t\n\t}\n",
    "93998": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_REMOVE_FILE;\n\t}\n",
    "94007": "\tprotected void createContainer(ContainerKey newIdentity) throws StandardException {\n\t\t// RESOLVE - probably should throw an error ...\n\t}\n",
    "94008": "\tprotected void readPositionedPage(long pageOffset, byte[] pageData) throws IOException {\n\n\n\t\tInputStream is = null;\n\t\ttry {\n\t\t\t// no need to synchronize as each caller gets a new stream\n\t\t\tis = getInputStream();\n\n\t\t\tInputStreamUtil.skipBytes(is, pageOffset);\n\n\t\t\tInputStreamUtil.readFully(is, pageData, 0, pageSize);\n\n\t\t\tis.close();\n\t\t\tis = null;\n\t\t} finally {\n\t\t\tif (is != null) {\n\t\t\t\ttry {is.close();} catch (IOException ioe) {}\n\t\t\t}\n\t\t}\n\t}\n",
    "94017": "\tpublic InputStream getReplayStream() throws IOException {\n\t\tbh.startReading();\n\t\trecording = false;\n\t\treturn new ByteHolderInputStream(bh);\n\t}\n",
    "94018": "\tpublic ByteHolder getByteHolder() throws IOException {\n\t\treturn bh;\n\t}\n",
    "94020": "\tpublic void clear() throws IOException {\n\t\tbh.clear();\n\t\trecording = true;\n\t}\n",
    "94021": "\tpublic void setInput(InputStream in) {\n\t\tthis.in = in;\n\t}\n",
    "94022": "\tpublic boolean recording() {\n\t\treturn recording;\n\t}\n",
    "94023": "\tpublic int available() throws IOException {\n\t\t// may not have set reading to be true, then,\n\t\t// we are getting available in negative numbers.\n\t\tint remainingBytes = bh.available();\n\t\tremainingBytes = remainingBytes > 0 ? remainingBytes : (-1) * remainingBytes;\n\t\treturn remainingBytes;\n\t}\n",
    "94025": "\tpublic int shiftToFront() throws IOException {\n\t\tint bytesShifted = bh.shiftToFront();\n\t\treturn bytesShifted;\n\t}\n",
    "94059": "\tpublic Object getIdentity() {\n\t\treturn identity;\n\t}\n",
    "94087": "\tpublic void unlatch() {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(isLatched());\n\t\t}\n\n\t   releaseExclusive();\n\t}\n",
    "94104": "\tpublic boolean requestCompatible(Object requestedQualifier, Object grantedQualifier) {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(owner != null, \"Should only be called when locked\");\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "94108": "\tpublic boolean lockerAlwaysCompatible() {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(owner != null, \"Should only be called when locked\");\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "94109": "\tpublic void unlockEvent(Latch lockInfo) {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(owner != null, \"Should only be called when locked\");\n\t\t}\n\n\t\tsynchronized (this) {\n\n\t\t\tif (SanityManager.DEBUG) {\n\t\t\t\tif (nestedLatch != 0)\n\t\t\t\t\tSanityManager.THROWASSERT(\"nestedLatch is non-zero on unlockEvent - value = \" + nestedLatch);\n\t\t\t}\n\n\t\t\towner.deleteObserver(this);\n\t\t\towner = null;\n\t\t\tmyLatch = null;\n\t\t\tif (inClean)\n\t\t\t\tnotifyAll();\n\t\t}\n\t}\n",
    "94115": "\tpublic PageKey getPageId() {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(identity != null);\n\t\t}\n\n\t\treturn identity;\n\t}\n",
    "94118": "\tprotected void releaseExclusive() /* throws StandardException */ {\n\n\t\tif (SanityManager.DEBUG) {\n            if (!isLatched())\n            {\n                SanityManager.THROWASSERT(\n                    \"releaseExclusive failed, nestedLatch = \" + nestedLatch);\n            }\n\t\t}\n\n\t\tif (nestedLatch > 0) {\n\t\t\tnestedLatch--;\n\t\t\treturn;\n\t\t}\n\n\t\tRawTransaction t = owner.getTransaction();\n\t\tt.getLockFactory().unlatch(myLatch);\n\t}\n",
    "94122": "\tpublic int setDeleteStatus(int slot, boolean delete) throws StandardException, IOException {\n\n\t\tif (SanityManager.DEBUG) {\n\t\t\t// latch check performed in checkSlotOnPage\n\t\t\tcheckSlotOnPage(slot);;\n\t\t}\n\n\t\treturn (getHeaderAtSlot(slot).setDeleted(delete));\n\t}\n",
    "94129": "\tpublic int findRecordById(int recordId, int slotHint) {\n\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(isLatched());\n\t\t}\n\n\t\tif (slotHint == FIRST_SLOT_NUMBER)\n\t\t\tslotHint = recordId - RecordHandle.FIRST_RECORD_ID;\n\n\t\tint\tmaxSlot = recordCount();\n\n       if ((slotHint > FIRST_SLOT_NUMBER)        &&\n            (slotHint < maxSlot)                   && \n            (recordId == getHeaderAtSlot(slotHint).getId())) {\n            return(slotHint);\n        } else {\n            for (int slot = FIRST_SLOT_NUMBER; slot < maxSlot; slot++) {\n\t\t\t\tif (recordId == getHeaderAtSlot(slot).getId()) {\n                    return slot;\n\t\t\t\t}\n            }\n        }\n\n\t\treturn -1;\n\t}\n",
    "94292": "\tprotected void letGo(BaseContainerHandle handle) {\n\n\t\tRawTransaction t = handle.getTransaction();\n\n\t\thandle.getLockingPolicy().unlockContainer(t, handle);\n\t}\n",
    "94304": "\tprotected void setDroppedState(boolean isDropped) {\n\t\tthis.isDropped = isDropped;\n\t}\n",
    "94311": "\tpublic void update(Observable obj, Object arg) {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tif (arg == null)\n\t\t\t\tSanityManager.THROWASSERT(\"still on observr list \" + this);\n\t\t}\n\n\t\tif (arg.equals(RawTransaction.COMMIT) || arg.equals(RawTransaction.ABORT)) {\n\n\t\t\tRawTransaction xact = (RawTransaction) obj;\n\n\t\t\ttry {\n\t\t\t\tif (this.isStreamContainer)\n\t\t\t\t\txact.dropStreamContainer(identity.getSegmentId(), identity.getContainerId());\n\t\t\t\telse\n\t\t\t\t\txact.dropContainer(identity);\n\t\t\t} catch (StandardException se) {\n\t\t\t\txact.setObserverException(se);\n\t\t\t}\n\n\t\t\tobj.deleteObserver(this);\n\t\t}\n\t}\n",
    "94332": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_SET_RESERVED_SPACE;\n\t}\n",
    "94378": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_CHAIN_ALLOC_PAGE;\n\t}\n",
    "94475": "\tpublic StandardException markCorrupt(StandardException originalError) {\n\t\tboolean firsttime = !isCorrupt;\n\n\t\tisCorrupt = true;\n\t\tif (getLogFactory() != null)\n\t\t\tgetLogFactory().markCorrupt(originalError);\n\n\t\t// if firsttime markCorrupt is called, release the JBMS lock so user\n\t\t// can move the database if so desired.\n\t\tif (firsttime)\n\t\t{\n\t\t\t// get rid of everything from the cache without first cleaning them\n\t\t\tif (pageCache != null)\n\t\t\t\tpageCache.discard(null);\n\n\t\t\tif (containerCache != null)\n\t\t\t\tcontainerCache.discard(null);\n\n\t\t\t// don't read in any more pages \n\t\t\tpageCache = null;\n\t\t\tcontainerCache = null;\n\n\t\t\treleaseJBMSLockOnDB();\n\t\t}\n\n\t\treturn originalError;\n\t}\n",
    "94490": "\tpublic String getRootDirectory() {\n\t\treturn dataDirectory;\n\t}\n",
    "94511": "\tprivate boolean handleServiceType( Properties startParams, String type) {\n        try\n        {\n            PersistentService ps = Monitor.getMonitor().getServiceProvider( startParams, type);\n            return ps != null && ps.hasStorageFactory();\n        }\n        catch( StandardException se){ return false;}\n\t}\n",
    "94538": "\tpublic void postRecovery() throws StandardException {\n\n\t\t// hook up the cache cleaner daemon after recovery is finished\n\t\tDaemonService daemon = rawStoreFactory.getDaemon();\n\n\t\tif (daemon == null)\n\t\t\treturn;\n\n\t\tcontainerCache.useDaemonService(daemon);\n\n\t\tpageCache.useDaemonService(daemon);\n\t\tif (postRecoveryRemovedFiles != null) {\n\n            synchronized( this)\n            {\n                actionCode = POST_RECOVERY_REMOVE_ACTION;\n                try\n                {\n                    AccessController.doPrivileged( this);\n                }\n                catch( PrivilegedActionException pae){} // POST_RECOVERY_REMOVE does not throw an exception\n            }\n\t\t\tpostRecoveryRemovedFiles = null;\n\t\t}\n\t}\n",
    "94554": "\tpublic boolean isReadOnly() {\n\t\t// return what the baseDataFileFactory thinks\n\t\treturn readOnly;\n\t}\n",
    "94561": "  final public void methodCallParameterList(Vector parameterList) throws ParseException, StandardException {\n    jj_consume_token(LEFT_PAREN);\n    if (jj_2_30(1)) {\n      methodParameter(parameterList);\n      label_17:\n      while (true) {\n        switch (jj_nt.kind) {\n        case COMMA:\n          ;\n          break;\n        default:\n          jj_la1[145] = jj_gen;\n          break label_17;\n        }\n        jj_consume_token(COMMA);\n        methodParameter(parameterList);\n      }\n    } else {\n      ;\n    }\n    jj_consume_token(RIGHT_PAREN);\n  }\n",
    "94576": "\tprotected void letGo(BaseContainerHandle handle) {\n\t\tsuper.letGo(handle);\n\n\t\tcontainerCache.release(this);\n\t}\n",
    "94584": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_COMPRESS_SPACE;\n\t}\n",
    "94614": "\tprotected void letGo(BaseContainerHandle handle) {\n\n\t\tinUseCount--;\n\t\tsuper.letGo(handle);\n\t}\n",
    "94616": "\tpublic boolean isSingleUser() {\n\t\treturn inUseCount == 1;\n\t}\n",
    "94638": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_UPDATE_FIELD;\n\t}\n",
    "94656": "\tpublic boolean equals(Object other) {\n\t\tif (other instanceof ContainerActionOnCommit) {\n\t\t\tif (!identity.equals(((ContainerActionOnCommit) other).identity))\n\t\t\t\treturn false;\n\n\t\t\t// the class of the types must match as well\n\t\t\treturn getClass().equals(other.getClass());\n\t\t}\n\t\treturn false;\n\t}\n",
    "94716": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.RAW_STORE_GLOBAL_XACT_ID_NEW;\n\t}\n",
    "94725": "\tpublic void resetCacheStats(String cacheName)  {\n\t\tgetDataFactory().resetCacheStats(cacheName);\n\t}\n",
    "94726": "\tpublic boolean anyoneBlocked() {\n\t\treturn getLockFactory().anyoneBlocked();\n\t}\n",
    "94746": "\tpublic void setTransactionId(GlobalTransactionId extid, TransactionId localid) {\n\n\t\tif (SanityManager.DEBUG) {\n\n\t\t\t//SanityManager.ASSERT(myGlobalId == null, \"my globalId is not null\");\n            if (!(state == IDLE || state == Xact.ACTIVE || \n                  (state== CLOSED && justCreated)))\n            {\n                SanityManager.THROWASSERT(\n                    \"my state is not idle nor active \" + state);\n            }\n\t\t}\n\n\t\tmyGlobalId = extid;\n\t\tmyId = localid;\n\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tif (SanityManager.DEBUG_ON(\"XATrace\") && extid != null)\n            {\n\t\t\t\tSanityManager.DEBUG(\n                    \"XATrace\",\"setting xid: \" + myId + \" \" + myGlobalId \n\t\t\t\t\t\t\t   + \" state \" + state + \" \" + this);\n\n                SanityManager.showTrace(new Throwable());\n                // Thread.dumpStack();\n            }\n\t\t}\n\n\t}\n",
    "94813": "\tprivate void getLogger() {\n\n\t\tlogger = logFactory.getLogger();\n\t}\n",
    "94898": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_BEGIN_XACT;\n\t}\n",
    "94908": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.RAW_STORE_TRANSACTION_TABLE_ENTRY;\n\t}\n",
    "94991": "\tpublic LockFactory getLockFactory() {\n\t\treturn lockFactory;\n\t}\n",
    "95011": "\tpublic StandardException markCorrupt(StandardException originalError) {\n\t\tlogFactory.markCorrupt(originalError);\n\t\treturn originalError;\n\t}\n",
    "95040": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.RAW_STORE_XACT_ID;\n\t}\n",
    "95048": "\tpublic boolean canSupport(Properties startParams) {\n\t\treturn true;\n\t}\n",
    "95052": "\tpublic boolean isReadOnly() {\n\t\treturn dataFactory.isReadOnly();\n\t}\n",
    "95131": "\tpublic String getString(int columnNumber)\n\t{\t\t\n\t\tString val = (String)currentRow.get(columnInfo[columnNumber-1].getName());\n\t\twasNull = (val == null);\n\n\t\treturn  val;\n\t}\n",
    "95455": "\tpublic boolean isAutoIncrement(int column) throws SQLException {\n\t\tthrow new SQLException(\"isAutoIncrement\");\n\t}\n",
    "95457": "\tpublic boolean isCaseSensitive(int column) throws SQLException {\n\t\tthrow new SQLException(\"isCaseSensitive\");\n\t}\n",
    "95458": "\tpublic boolean isSearchable(int column) throws SQLException{\n\t\tthrow new SQLException(\"isSearchable\");\n\t}\n",
    "95459": "\tpublic boolean isCurrency(int column) throws SQLException{\n\t\tthrow new SQLException(\"isCurrency\");\n\t}\n",
    "95460": "\tpublic int isNullable(int column) throws SQLException{\n\t\tthrow new SQLException(\"isNullable\");\n\t}\n",
    "95461": "\tpublic boolean isSigned(int column) throws SQLException {\n\t\tthrow new SQLException(\"isSigned\");\n\t}\n",
    "95463": "\tpublic  int getColumnDisplaySize(int column) throws SQLException {\n\t\tthrow new SQLException(\"getColumnDisplaySize\");\n\t}\n",
    "95465": "\tpublic String getColumnLabel(int column) throws SQLException {\n\t\tthrow new SQLException(\"getColumnLabel\");\n\t}\n",
    "95466": "\tpublic String getColumnName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getColumnName\");\n\t}\n",
    "95467": "\tpublic  String getSchemaName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getSchemaName\");\n\t}\n",
    "95468": "\tpublic int getPrecision(int column) throws SQLException {\n\t\tthrow new SQLException(\"getPrecision\");\n\t}\n",
    "95469": "\tpublic  int getScale(int column) throws SQLException {\n\t\tthrow new SQLException(\"getScale\");\n\t}\n",
    "95471": "\tpublic  String getTableName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getTableName\");\n\t}\n",
    "95472": "\tpublic String getCatalogName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getCatalogName\");\n\t}\n",
    "95473": "\tpublic  String getColumnTypeName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getColumnTypeName\");\n\t}\n",
    "95474": "\tpublic  boolean isReadOnly(int column) throws SQLException {\n\t\treturn true;\n\t}\n",
    "95475": "\tpublic  boolean isWritable(int column) throws SQLException {\n\t\treturn false;\n\t}\n",
    "95476": "\tpublic boolean isDefinitelyWritable(int column) throws SQLException {\n\t\treturn false;\n\t}\n",
    "95477": "\tpublic String getColumnClassName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getColumnClassName\");\n\t}\n",
    "95612": "\tpublic void skipField(ObjectInput in) throws IOException {\n\n\n\t\tint fieldStatus = StoredFieldHeader.readStatus(in);\n\t\tint fieldDataLength = StoredFieldHeader.readFieldDataLength(in, fieldStatus, slotFieldSize);\n\n\t\tif (fieldDataLength != 0) {\n\t\t\tin.skipBytes(fieldDataLength);\n\t\t}\n\t}\n",
    "95656": "\tprotected void closeCurrentConnectionHandle() throws SQLException {\n\t\tif (currentConnectionHandle != null)\n\t\t{\n\t\t\tVector tmpEventListener = eventListener;\n\t\t\teventListener = null;\n\n\t\t\ttry {\n\t\t\t\tcurrentConnectionHandle.close();\n\t\t\t} finally {\n\t\t\t\teventListener = tmpEventListener;\n\t\t\t}\n\n\t\t\tcurrentConnectionHandle = null;\n\t\t}\n\t}\n",
    "95659": "\tpublic void notifyException(SQLException sqle) {\n\t\tthis.notifyError(sqle);\n\t}\n",
    "95662": "\tpublic void checkHoldCursors(int holdability) throws SQLException {\n\t}\n",
    "95663": "\tpublic void checkSavepoint() throws SQLException {\n\t}\n",
    "95665": "\tpublic void checkRollback() throws SQLException {\n\t}\n",
    "95666": "\tpublic void checkCommit() throws SQLException {\n\t}\n",
    "95667": "\tpublic boolean closingConnection() throws SQLException {\n\t\tnotifyClose();\n\t\tcurrentConnectionHandle = null;\n\t\treturn false;\n\t}\n",
    "95669": "\tpublic Statement wrapStatement(Statement s) throws SQLException {\n\t\treturn s;\n\t}\n",
    "95670": "\tpublic PreparedStatement wrapStatement(PreparedStatement ps, String sql, Object generatedKeys) throws SQLException {\n\t\treturn ps;\n\t}\n",
    "95671": "\tpublic CallableStatement wrapStatement(CallableStatement cs, String sql) throws SQLException {\n\t\treturn cs;\n\t}\n",
    "95695": "\tpublic int getLoginTimeout() throws SQLException {\n\t\treturn loginTimeout;\n\t}\n",
    "95696": "\tpublic void setLoginTimeout(int seconds) throws SQLException {\n\t\tloginTimeout = seconds;\n\t}\n",
    "95697": "\tpublic PrintWriter getLogWriter() throws SQLException {\n\t\treturn printer;\n\t}\n",
    "95698": "\tpublic void setLogWriter(PrintWriter out) throws SQLException {\n\t\tprinter = out;\n\t}\n",
    "95703": "\tpublic boolean acceptsURL(String url) throws SQLException {\n\t\treturn getRegisteredDriver().acceptsURL(url);\n\t}\n",
    "95705": "\tpublic int getMajorVersion() {\n\t\ttry {\n\t\t\treturn (getRegisteredDriver().getMajorVersion());\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\treturn 0;\n\t\t}\n\t}\n",
    "95706": "\tpublic int getMinorVersion() {\n\t\ttry {\n\t\t\treturn (getRegisteredDriver().getMinorVersion());\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\treturn 0;\n\t\t}\n\t}\n",
    "95707": "\tpublic boolean jdbcCompliant() {\n\t\ttry {\n\t\t\treturn (getRegisteredDriver().jdbcCompliant());\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "95714": "\tpublic void checkHoldCursors(int holdability) throws SQLException {\n\t\txaConnection.checkHoldCursors(holdability);\n\t}\n",
    "95718": "\tpublic void checkAutoCommit(boolean autoCommit) throws SQLException {\n\t\tif (autoCommit && (currentXid != null))\n\t\t\tthrow Util.generateCsSQLException(SQLState.CANNOT_AUTOCOMMIT_XA);\n\n\t\tsuper.checkAutoCommit(autoCommit);\n\t}\n",
    "95720": "\tpublic void checkHoldCursors(int holdability) throws SQLException {\n\n\t\tif (holdability == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {\t\t\n\t\t\tif (currentXid != null)\n\t\t\t\tthrow Util.generateCsSQLException(SQLState.CANNOT_HOLD_CURSOR_XA);\n\t\t}\n\n\t\tsuper.checkHoldCursors(holdability);\n\t}\n",
    "95723": "\tpublic void checkSavepoint() throws SQLException {\n\n\t\tif (currentXid != null)\n\t\t\tthrow Util.generateCsSQLException(SQLState.CANNOT_ROLLBACK_XA);\n\n\t\tsuper.checkSavepoint();\n\t}\n",
    "95724": "\tpublic void checkRollback() throws SQLException {\n\n\t\tif (currentXid != null)\n\t\t\tthrow Util.generateCsSQLException(SQLState.CANNOT_ROLLBACK_XA);\n\n\t\tsuper.checkRollback();\n\t}\n",
    "95725": "\tpublic void checkCommit() throws SQLException {\n\n\t\tif (currentXid != null)\n\t\t\tthrow Util.generateCsSQLException(SQLState.CANNOT_COMMIT_XA);\n\n\t\tsuper.checkCommit();\n\t}\n",
    "95727": "\tpublic Statement wrapStatement(Statement s) throws SQLException {\n\t\tXAStatementControl sc = new XAStatementControl(this, s);\n\t\treturn sc.applicationStatement;\n\t}\n",
    "95728": "\tpublic PreparedStatement wrapStatement(PreparedStatement ps, String sql, Object generatedKeys) throws SQLException {\n\t\tXAStatementControl sc = new XAStatementControl(this, ps, sql, generatedKeys);\n\t\treturn (PreparedStatement) sc.applicationStatement;\n\t}\n",
    "95730": "\tpublic CallableStatement wrapStatement(CallableStatement cs, String sql) throws SQLException {\n\t\tXAStatementControl sc = new XAStatementControl(this, cs, sql);\n\t\treturn (CallableStatement) sc.applicationStatement;\n\t}\n",
    "95763": "\tpublic String getErrorProperty(String type) {\n\t\treturn getErrorProperty(getMessageId(), type);\n\t}\n",
    "95764": "\tpublic String toString() {\n\t\tString msg = getMessage();\n\n\t\treturn \"ERROR \" + getSQLState() + \": \" + msg;\n\t}\n",
    "95796": "\tpublic ByteArray getFileFormat() throws IOException {\n\n\t\tint classFileSize = 4 + (10 * 2);\n\t\tclassFileSize += cptEstimatedSize;\n\n\t\tif (interfaces != null)\n\t\t\tclassFileSize += (interfaces.length * 2);\n\n\t\tif (field_info != null)\n\t\t\tclassFileSize += field_info.classFileSize();\n\n\t\tif (method_info != null)\n\t\t\tclassFileSize += method_info.classFileSize();\n\n\t\tif (attribute_info != null)\n\t\t\tclassFileSize += attribute_info.classFileSize();\n\n\t\n\t\tClassFormatOutput cfo = new ClassFormatOutput(classFileSize + 200);\n\n\t\tput(cfo);\n\n\t\treturn new ByteArray(cfo.getData(), 0, cfo.size());\n\n\t}\n",
    "95824": "\tprotected int addEntry(Object key, ConstantPoolEntry item) {\n\n\t\titem.setIndex(cptEntries.size());\n\t\tif (key != null)\n\t\t\tcptHashTable.put(key, item);\n\t\tcptEntries.addElement(item);\n\n\t\tcptEstimatedSize += item.classFileSize();\n\n\t\tif (item.doubleSlot()) {\n\t\t\tcptEntries.addElement(null);\n\t\t\treturn 2;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n",
    "95825": "\tprivate int addDirectEntry(ConstantPoolEntry item) {\n\t\tConstantPoolEntry existingItem = findMatchingEntry(item);\n\t\tif (existingItem != null) {\n\t\t\titem = existingItem;\n\t\t\t//foundCount++;\n\t\t}\n\t\telse {\n\t\t\taddEntry(item.getKey(), item);\n\t\t}\n\t\treturn item.getIndex();\n\t}\n",
    "95826": "\tprivate int addIndexReference(int tag, int i1, int i2) {\n\n\t\t// search for the item using the pre-allocated object \n\t\tsearchIndex.set(tag, i1, i2);\n\n\t\tConstantPoolEntry item = findMatchingEntry(searchIndex);\n\n\t\tif (item == null) {\n\t\t\titem = new CONSTANT_Index_info(tag, i1, i2);\n\t\t\taddEntry(item.getKey(), item);\n\t\t}\n\n\t\treturn item.getIndex();\n\t}\n",
    "95827": "\tpublic int addClassReference(String fullyQualifiedName) {\n\t\tif (ClassHolder.isExternalClassName(fullyQualifiedName)) {\n\t\t\tfullyQualifiedName = ClassHolder.convertToInternalClassName(fullyQualifiedName);\n\t\t\t// System.out.println(\"addClassReference \" + fullyQualifiedName);\n\t\t}\n\n\t\tint name_index = addUtf8Entry(fullyQualifiedName).getIndex();\n\n\t\treturn addIndexReference(VMDescriptor.CONSTANT_Class, name_index, 0);\n\t}\n",
    "95828": "\tprivate int addNameAndType(String name, String descriptor) {\n\t\tint nameIndex = addUtf8Entry(name).getIndex();\n\n\t\tint descriptorIndex = addUtf8Entry(descriptor).getIndex();\n\n\t\treturn addIndexReference(VMDescriptor.CONSTANT_NameAndType, nameIndex, descriptorIndex);\n\t}\n",
    "95831": "\tprivate CONSTANT_Utf8_info addUtf8Entry(String value) {\n\n\t\tCONSTANT_Utf8_info item = (CONSTANT_Utf8_info) findMatchingEntry(value);\n\n\t\tif (item == null) {\n\n\t\t\titem = new CONSTANT_Utf8_info(value);\n\t\t\taddEntry(value, item);\n\t\t}\n\t\treturn item;\n\t}\n",
    "95833": "\tprivate CONSTANT_Utf8_info addExtraUtf8(String value) {\n\n\t\tCONSTANT_Utf8_info item = new CONSTANT_Utf8_info(value);\n\t\taddEntry(null, item);\n\n\t\treturn item;\n\t}\n",
    "95834": "\tprivate int addString(String value) {\n\t\tCONSTANT_Utf8_info sutf = addUtf8Entry(value);\n\t\tint valueIndex = sutf.setAsString();\n\t\tif (valueIndex == 0) {\n\t\t\t// string is already being used as code\n\t\t\tvalueIndex = addExtraUtf8(value).getIndex();\n\t\t\tsutf.setAlternative(valueIndex);\n\t\t}\n\n\t\treturn addIndexReference(VMDescriptor.CONSTANT_String, valueIndex, 0);\n\t}\n",
    "95835": "\tprivate int addCodeUtf8(String value) {\n\t\tCONSTANT_Utf8_info sutf = addUtf8Entry(value);\n\t\tint index = sutf.setAsCode();\n\t\tif (index == 0) {\n\t\t\t// code string is already being used as string\n\t\t\tCONSTANT_Utf8_info eutf = addExtraUtf8(value);\n\t\t\teutf.setAsCode(); // ensure the replace will happen\n\t\t\tindex = eutf.getIndex();\n\t\t\tsutf.setAlternative(index);\n\t\t}\n\n\t\treturn index;\n\t}\n",
    "95838": "\tpublic int findClass(String fullyQualifiedName) {\n\t\tString internalName = ClassHolder.convertToInternalClassName(fullyQualifiedName);\n\t\tint utf_index = findUtf8(internalName);\n\t\tif (utf_index < 0)\n\t\t\treturn -1;\n\n\t\treturn findIndexIndex(VMDescriptor.CONSTANT_Class,\n\t\t\tutf_index, 0);\n\t}\n",
    "95839": "\tpublic int findNameAndType(String name, String descriptor) {\n\n\t\tint name_index = findUtf8(name);\n\t\tif (name_index < 0)\n\t\t\treturn -1;\n\t\tint descriptor_index = findUtf8(descriptor);\n\t\tif (descriptor_index < 0)\n\t\t\treturn -1;\n\n\t\treturn findIndexIndex(VMDescriptor.CONSTANT_NameAndType,\n\t\t\tname_index, descriptor_index);\n\t}\n",
    "95850": "\tstatic private String makeDesc (String className, int arity, boolean descriptor) {\n\n\t\tif (!descriptor && (arity == 0)) {\n\t\t\treturn className.replace('.','/');\n\t\t}\n\n\t\tStringBuffer desc = new StringBuffer(arity+2+className.length());\n\n\t\tfor (int i=0;i<arity;i++)\n\t\t\tdesc.append(VMDescriptor.C_ARRAY);\n\n\t\tdesc.append(VMDescriptor.C_CLASS);\n\n\t\tdesc.append(className.replace('.','/'));\n\n\t\tdesc.append(VMDescriptor.C_ENDCLASS);\n\n\t\treturn desc.toString();\n\t}\n",
    "95892": "\tprivate void checkInterrupt() {\n\t\tif (shutdown) {\n\t\t\t// system must have changed underneath us\n\t\t\tthrow new ShutdownException();\n\t\t}\n\t}\n",
    "95893": "\tpublic void setLocaleFinder(LocaleFinder finder) {\n\t\tthis.finder = finder;\n\t}\n",
    "95906": "\tpublic ContextManager getCurrentContextManager() {\n\n\t\tThread me = Thread.currentThread();\n\n\t\tObject list = threadContextList.get();\n\n\t\tif (list instanceof ContextManager) {\n\t\t\t\n\t\t\tContextManager cm = (ContextManager) list;\n\t\t\tif (cm.activeThread == me)\n\t\t\t\treturn cm;\n\t\t\treturn null;\n\t\t}\n\n\t\tif (list == null)\n\t\t\treturn null;\n\n\t\tjava.util.Stack stack = (java.util.Stack) list;\n\t\treturn (ContextManager) (stack.peek());\n\n\n\t//\tif (list == null)\n\t//\t\treturn null;\n\n\t\t/*\t\tThread me = Thread.currentThread();\n\t\t\n\t\tsynchronized (this) {\n\t\t\tfor (Iterator i = allContexts.iterator(); i.hasNext(); ) {\n\n\t\t\t\tContextManager cm = (ContextManager) i.next();\n\t\t\t\tif (cm.activeThread == me)\n\t\t\t\t\treturn cm;\n\t\t\t}\n\t\t}\n\t\t//OLDreturn (ContextManager) get(me);\n\t\treturn null;\n*/\t}\n",
    "95924": "\tstatic public void DEBUG_PRINT(String flag, String message) {\n\t\tjava.io.PrintWriter debugStream = GET_DEBUG_STREAM();\n\n\t\tdebugStream.println(\"DEBUG \"+flag+\" OUTPUT: \" + message);\n\t\tdebugStream.flush();\n\t}\n",
    "95931": "\tpublic int getCount() {\n\t\treturn count;\n\t}\n",
    "95933": "\tpublic void setLimit(int limit) {\n\n\t\tcount = 0;\n\n\t\tthis.limit = limit;\n\n\t\treturn;\n\t}\n",
    "95935": "\tpublic  void write(int b) throws IOException {\n\t\t\n\t\tif ((limit >= 0) && ((count + 1) > limit)) {\n\t\t\tthrow new EOFException();\n\t\t}\n\n\t\tout.write(b);\n\t\tcount++;\n\t}\n",
    "95937": "\tpublic void write(byte b[], int off, int len) throws IOException {\n\n\t\tif ((limit >= 0) && ((count + len) > limit)) {\n\t\t\tthrow new EOFException();\n\t\t}\n\n\t\tout.write(b, off, len);\n\t\tcount += len;\n\t}\n",
    "95967": "\tpublic void setData(byte[] data) {\n\t\tpageData = data;\n\t\tclearLimit();\n\t}\n",
    "95977": "\tpublic int setLimit(int offset, int length) throws IOException {\n\n\t\tif ((offset < 0) || (length < 0)) {\n\t\t\tstart = end = position = 0;\n\t\t\tthrow new EOFException();\n\t\t}\n\n\t\tstart = offset;\n\t\tend = offset + length;\n\n\t\tif (end > pageData.length) {\n\t\t\tstart = end = position = 0;\n\t\t\tthrow new EOFException();\n\t\t}\n\n\t\tposition = start;\n\n\t\treturn length;\n\t}\n",
    "95982": "\tpublic  void write(int b)  {\n\t}\n",
    "95983": "\tpublic void write(byte b[]) {\n\t}\n",
    "95984": "\tpublic void write(byte b[], int off, int len)  {\n\t}\n",
    "96002": "\tpublic void discardLeft(int amountToShrinkBy) {\n\n\t\tSystem.arraycopy(buf, amountToShrinkBy, buf, 0,\n\t\t\tused - amountToShrinkBy);\n\n\t\tposition -= amountToShrinkBy;\n\t\tused -= amountToShrinkBy;\n\t}\n",
    "96022": "\tpublic void setLimit(int length) {\n\t\tremainingBytes = length;\n\t\tlimitInPlace = true;\n\t\treturn;\n\t}\n",
    "96023": "\tpublic int clearLimit() {\n\t\tint leftOver = remainingBytes;\n\t\tlimitInPlace = false;\n\t\tremainingBytes = -1;\n\t\treturn leftOver;\n\t}\n",
    "96038": "\tpublic void clearDefaults() {\n\t\tdefaults = null;\n\t}\n",
    "96055": "\tpublic int getLength() {\n\t\treturn lengthAsBits;\n\t}\n",
    "96104": "\tprivate boolean isLong(int fieldSize, int overflowThreshold) {\n\n\t\tif (SanityManager.DEBUG) {\n\t\t\tif (overflowThreshold == 0) \n\t\t\t\tSanityManager.THROWASSERT(\"overflowThreshold cannot be 0\");\n\t\t}\n\n\t\t// if a field size is over the threshold, then it becomes a long column\n\t\tint maxThresholdSize = maxFieldSize * overflowThreshold / 100;\n\t\treturn (fieldSize > maxThresholdSize);\n\t}\n",
    "96106": "\tprivate boolean isMethodMoreSpecificOrEqual(Member T, Member U, boolean[] isParam) {\n\n\t\tClass[] TC;\n\t\tClass[] UC;\n\n\t\tif (T instanceof Method) {\n\t\t\tif (!classConvertableFromTo(T.getDeclaringClass(), U.getDeclaringClass(), true))\n\t\t\t\treturn false;\n\n\t\t\tTC = ((Method) T).getParameterTypes();\n\t\t\tUC = ((Method) U).getParameterTypes();\n\t\t} else {\n\t\t\tTC = ((Constructor) T).getParameterTypes();\n\t\t\tUC = ((Constructor) U).getParameterTypes();\n\t\t}\n\n\t\treturn signatureConvertableFromTo(TC, null, UC, isParam, true);\n\t}\n",
    "96124": "\tpublic boolean isAlpha() {\n\t\treturn\t   (majorVersion >= 5)\n\t\t\t\t&& (minorVersion > 2)\n\t\t\t\t&& ((maintVersion / MAINT_ENCODING) == 0);\n\t}\n",
    "96127": "    public int getBuildNumberAsInt(){\n    \tif (buildNumber == null)\n    \t    return -1;\n    \tboolean dubiousCode = false;\n    \tint offset = buildNumber.indexOf('M');\n    \tif (offset == -1)\n    \t    offset = buildNumber.indexOf(':');\n    \telse\n    \t    dubiousCode = true;\n    \tif (offset == -1)\n    \t\toffset = buildNumber.length();\n        else\n            dubiousCode = true;\n    \t\n    \ttry {\n    \t\tint bnai = Integer.parseInt(buildNumber.substring(0, offset));\n    \t\tif (dubiousCode)\n    \t\t    bnai = -bnai;\n    \t\treturn bnai;\n    \t} catch (NumberFormatException nfe) \n     \t{\n     \t\treturn -1;\n    \t}\n    }\n",
    "96130": "\tpublic String getSimpleVersionString() {\n\n\t\treturn ProductVersionHolder.simpleVersionString(majorVersion, minorVersion, isBeta());\n\t}\n",
    "96156": "\tpublic boolean equals(Object other) {\n\t\tif (other instanceof ByteArray) {\n\t\t\tByteArray ob = (ByteArray) other;\n\t\t\treturn ByteArray.equals(array, offset, length, ob.array, ob.offset, ob.length);\n\t\t}\n\t\treturn false;\n\t}\n",
    "96216": "\tpublic boolean isAutoincAlways(){\n\t\treturn (columnDefaultInfo == null) && isAutoincrement();\n\t}\n",
    "96617": "\tpublic void syncState() throws SQLException {\n\t\tConnection conn = getRealConnection();\n\n\t\tstateIsolationLevel = conn.getTransactionIsolation();\n\t\tstateReadOnly = conn.isReadOnly();\n\t\tstateAutoCommit = conn.getAutoCommit();\n\t\t// jdk13 does not have Connection.getHoldability method and hence using\n\t\t// reflection to cover both jdk13 and higher jdks\n\t\ttry {\n\t\t\tMethod sh = conn.getClass().getMethod(\"getHoldability\", null);\n\t\t\tstateHoldability = ((Integer)sh.invoke(conn, null)).intValue();\n\t\t} catch( Exception e)\n\t\t{\n\t\t\tthrow PublicAPI.wrapStandardException( StandardException.plainWrapException( e));\n\t\t}       \n\t}\n",
    "96664": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_DATE_ID;\n\t}\n",
    "96713": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_LONGINT_ID;\n\t}\n",
    "96791": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_TIMESTAMP_ID;\n\t}\n",
    "96825": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_CHAR_ID;\n\t}\n",
    "96878": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_REF_ID;\n\t}  \n",
    "96913": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_BOOLEAN_ID;\n\t}\n",
    "96983": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_LONGVARCHAR_ID;\n\t}\n",
    "97030": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_INTEGER_ID;\n\t}\n",
    "97229": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_NATIONAL_VARCHAR_ID;\n\t}\n",
    "97237": "\tpublic void setInto(ResultSet rs, int position) throws SQLException, StandardException {\n\t\trs.updateObject(position, getObject());\n\t}\n",
    "97249": "\tpublic int\t\t\t\t\ttypePrecedence() {\n\t\treturn -1;\n\t}\n",
    "97253": "        public int getTypeFormatId() {\n                return StoredFormatIds.SQL_NCLOB_ID;\n        }\n",
    "97371": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_REAL_ID;\n\t}\n",
    "97456": "\tpublic DataValueDescriptor getNull() {\n\t\treturn typeId.getNull();\n\t}\n",
    "97504": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_SMALLINT_ID;\n\t}\n",
    "97558": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_NATIONAL_CHAR_ID;\n\t}\n",
    "97638": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_DOUBLE_ID;\n\t}\n",
    "97685": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_CLOB_ID;\n\t}\n",
    "97749": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_TIME_ID;\n\t}\n",
    "97807": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_VARCHAR_ID;\n\t}\n",
    "97821": "\tprotected int typeCompare(DataValueDescriptor arg) throws StandardException {\n\t\t\n\t\tBigIntegerDecimal obid = getBID(arg);\n\t\t\n\t\t// need to align scales to perform comparisions\n\t\tint tscale = getDecimalValueScale();\n\t\tint oscale = obid.getDecimalValueScale();\n\t\n\t\tBigInteger tbi = new BigInteger(data2c);\n\t\tBigInteger obi = new BigInteger(obid.data2c);\n\t\t\n\t\tif (tscale < oscale)\n\t\t\ttbi = BigIntegerDecimal.rescale(tbi, oscale - tscale);\n\t\telse if (oscale < tscale)\n\t\t\tobi = BigIntegerDecimal.rescale(obi, tscale - oscale);\n\t\n\t\treturn tbi.compareTo(obi);\n\t}\n",
    "97824": "\tpublic NumberDataValue minus(NumberDataValue result) throws StandardException {\n\t\t\n\t\tif (result == null)\n\t\t\tresult = (NumberDataValue) getNewNull();\n\n\t\tif (isNull())\n\t\t\tresult.setToNull();\n\t\telse\n\t\t{\n\t\t\tBinaryDecimal rbd = (BinaryDecimal) result;\n\t\t\t\n\t\t\tBigInteger bi = new BigInteger(data2c);\n\t\t\t// scale remains unchanged.\n\t\t\trbd.data2c = bi.negate().toByteArray();\n\t\t\trbd.sqlScale = sqlScale;\n\t\t\n\t\t}\n\t\t\t\n\t\treturn result;\n\t}\n",
    "97838": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_NATIONAL_LONGVARCHAR_ID;\n\t}\n",
    "97873": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_USERTYPE_ID_V3;\n\t}\n",
    "97957": "\tpublic long getContainerId() {\n\t\treturn containerId;\n\t}\n",
    "97982": "        public boolean  streamStorable() {\n                return isStringTypeId() || isBitTypeId();\n        }\n",
    "97991": "\tpublic void checkLogicalOperationOk() throws StandardException {\n\t}\n",
    "97992": "\tpublic boolean recoveryRollbackFirst() {\n\t\treturn false;\n\t}\n",
    "97994": "\tpublic void setObserverException(StandardException se) {\n\t\tif (observerException == null)\n\t\t\tobserverException = se;\n\t}\n",
    "97995": "\tpublic void notifyObservers(Object arg) {\n\t\tif (countObservers() != 0) {\n\t\t\tsetChanged();\n\t\t\tsuper.notifyObservers(arg);\n\t\t}\n\t}\n",
    "98034": "    public boolean inField() {\n        return false;\n    }\n",
    "98036": "    public boolean inConstructor() {\n        return false;\n    }\n",
    "98037": "    public boolean inMethod() {\n        return false;\n    }\n",
    "98038": "    public boolean inOverview() {\n        return true;\n    }\n",
    "98039": "    public boolean inPackage() {\n        return true;\n    }\n",
    "98040": "    public boolean inType() {\n        return true;\n    }\n",
    "98041": "    public boolean isInlineTag() {\n        return false;\n    }\n",
    "98042": "    public String toString(Tag tag) {\n        return \"\\n<dt><table cellpadding=2 cellspacing=2><tr><td>\" + ROWNAME + \"</td>\"\n               + \"<td>\" + tag.text() + \"</td></tr>\\n\";\n    }\n",
    "98043": "    public String toString(Tag[] tags) {\n        if (tags.length == 0) {\n            return null;\n        }\n        String result = \"<table cellpadding=2 cellspacing=2><tr><td>\" + ROWNAME + \"</td><td>\" ;\n        for (int i = 0; i < tags.length; i++) {\n            if (i > 0) {\n                result += \"\";\n            }\n            result += tags[i].text() + \"</td></tr>\";\n        }\n        return result + \"\\n\";\n    }\n",
    "98053": "    public String toString(Tag tag) {\n        return \"<tr><td>\" + ROWNAME + \"</td>\"\n               + \"<td>\" + tag.text() + \"</td></tr>\\n\";\n    }\n",
    "98054": "    public String toString(Tag[] tags) {\n        if (tags.length == 0) {\n            return null;\n        }\n        String result = \"<tr><td>\" + ROWNAME + \"</td><td>\";\n        for (int i = 0; i < tags.length; i++) {\n            if (i > 0) {\n                result += \"\";\n            }\n            result += tags[i].text() + \"</td></tr>\";\n        }\n        return result + \"\\n\";\n    }\n",
    "98086": "    public String toString(Tag tag) {\n        return \"<tr><td>\" + ROWNAME + \"</td>\"\n               + \"<td>\" + tag.text() + \"</td></tr></table>\\n\";\n    }\n",
    "98088": "    public String toString(Tag[] tags) {\n        if (tags.length == 0) {\n            return null;\n        }\n        String result = \"<tr><td>\" + ROWNAME + \"</td><td>\" ;\n        for (int i = 0; i < tags.length; i++) {\n            if (i > 0) {\n                result += \"\";\n            }\n            result += tags[i].text() + \"</td></tr>\";\n        }\n        return result + \"</table></dt>\\n\";\n    }\n",
    "98104": "\tprivate void doTrace(Throwable t) {\n\t\tif (util.getSystemProperty(\"ij.exceptionTrace\") != null) {\n\t\t\tt.printStackTrace(out);\n\t\t}\n\t\tout.flush();\n\t}\n",
    "98193": "\tpublic void ReInit(Reader s) { \n\t    try {\n\t\t\tsource.close();\n\t\t} catch (IOException ioe) {\n\t\t\t// just be quiet if it is already gone\n\t\t}\n\t\tsource = s;\n\t\tstate = IN_STATEMENT;\n\t\tatEOF = false;\n\t\tpeekEOF = false;\n\t\tpeeked = false;\n\t}\n",
    "98202": "\tprivate boolean whiteSpace(char c) {\n\t\treturn (c == SPACE ||\n\t\t    \tc == TAB ||\n\t\t    \tc == RETURN ||\n\t\t    \tc == NEWLINE ||\n\t\t    \tc == FORMFEED);\n\t}\n",
    "98208": "\tprivate void readString(char stringDelimiter) {\n\t\tstate = IN_STRING;\n\t\tdo {\n\t\t\tchar nextChar = readChar();\n\n\t\t\tif (atEOF()) {\n\t\t\t\tstate = END_OF_INPUT;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (nextChar == stringDelimiter) {\n\t\t\t\t// we've reached the end of the string\n\t\t\t\tstate = IN_STATEMENT;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// still in string\n\t\t} while (state == IN_STRING); // could be while true...\n\t}\n",
    "98217": "\tprivate char readChar() {\n\t\tif (!peeked) peekChar();\n\n\t\tpeeked = false;\n\t\tatEOF = peekEOF;\n\n\t\tif (!atEOF) statement.append(peekChar);\n\n\t\treturn peekChar;\n\t}\n",
    "98218": "\tprivate char peekChar() {\n\t\tpeeked = true;\n\t\tchar c = '\\00';\n\n\t\ttry {\n\t\t    int cInt;\n\n\t\t\t// REMIND: this is assuming a flat ascii source file.\n\t\t\t// will need to beef it up at some future point to\n\t\t\t// understand whether the stream is ascii or something else.\n\t\t\tcInt = source.read();\n\t\t\tpeekEOF = (cInt == -1);\n\t\t\tif (!peekEOF) c = (char)cInt;\n\t\t} catch (IOException ie) {\n\t\t\tthrow ijException.iOException(ie);\n\t\t}\n\n\t\tpeekChar = c;\n\t\treturn c;\n\t}\n",
    "98352": "\tstatic public boolean getPropertyArg(String[] args) throws IOException {\n\t\tString n;\n\t\tInputStream in1;\n\t\tProperties p;\n\n\t\tif ((n = getArg(\"-p\", args))!= null){\n\t\t\tin1 = new FileInputStream(n);\n\t\t\tin1 = new BufferedInputStream(in1);\n\t\t}\n\t\telse if ((n = getArg(\"-pr\", args)) != null) {\n\t\t\tin1 = getResourceAsStream(n);\n\t\t\tif (in1 == null) throw ijException.resourceNotFound();\n\t\t}\n\t\telse\n\t\t\treturn false;\n\n\t\tp = System.getProperties();\n\n\t\t// Trim off excess whitespace in property file, if any, and\n\t\t// then load those properties into 'p'.\n\t\tutil.loadWithTrimmedValues(in1, p);\n\n\t\treturn true;\n\t}\n",
    "98357": "\tstatic public String getFileArg(String[] args) throws IOException {\n\t\tString fileName;\n\t\tint fLocn;\n\t\tboolean foundP = false;\n\n\t\tif (args == null) return null;\n\t\tif ((fileName=getArg(\"-f\",args))!=null) return fileName;\n\t\t//\n\t\t//The first unknown arg is the file\n\t\tfor (int ix=0; ix < args.length; ix++)\n\t\t\tif(args[ix].equals(\"-f\")  ||\n\t\t\t   args[ix].equals(\"-fr\") ||\n\t\t\t   args[ix].equals(\"-ca\")  ||\n\t\t\t   args[ix].equals(\"-car\")  ||\n\t\t\t   args[ix].equals(\"-p\")  ||\n\t\t\t   args[ix].equals(\"-pr\"))\n\t\t\t\tix++; //skip the parameter to these args\n\t\t\telse\n\t\t\t\treturn args[ix];\n\t\treturn null;\n\t}\n",
    "98359": " \tstatic public String getInputResourceNameArg(String[] args) {\n\t\treturn getArg(\"-fr\", args);\n\t}\n",
    "98363": "    static public Connection startJBMS() throws SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException {\n\t\treturn startJBMS(null,null);\n\t}\n",
    "98410": "  final public ijResult ProtocolStatement() throws ParseException, SQLException {\n        Token t;\n        String n = null;\n    jj_consume_token(PROTOCOL);\n    t = jj_consume_token(STRING);\n    if (jj_2_56(2)) {\n      jj_consume_token(AS);\n      n = identifier();\n    } else {\n      ;\n    }\n                installProtocol(n, stringValue(t.image));\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98431": "\tstatic public boolean init() {\n\t\treturn (LocalizedResource.getInstance() != null);\n\t}\n",
    "98433": "\tstatic public void ShowException(PrintWriter out, Throwable e) {\n\t\tif (e == null) return;\n\n\t\tif (e instanceof SQLException)\n\t\t\tShowSQLException(out, (SQLException)e);\n\t\telse\n\t\t\te.printStackTrace(out);\n\t}\n",
    "98434": "\tstatic public void ShowSQLException(PrintWriter out, SQLException e) {\n\t\tString errorCode;\n\n\t\tif (Boolean.getBoolean(\"ij.showErrorCode\")) {\n\t\t\terrorCode = LocalizedResource.getMessage(\"UT_Error0\", LocalizedResource.getNumber(e.getErrorCode()));\n\t\t}\n\t\telse {\n\t\t\terrorCode = \"\";\n\t\t}\n\n\t\twhile (e!=null) {\n\t\t\tString p1 = mapNull(e.getSQLState(),LocalizedResource.getMessage(\"UT_NoSqlst\"));\n\t\t\tString p2 = mapNull(e.getMessage(),LocalizedResource.getMessage(\"UT_NoMessa\"));\n\t\t\tout.println(LocalizedResource.getMessage(\"UT_Error012\", p1, p2,errorCode));\n\t\t\tdoTrace(out, e);\n\t\t\te=e.getNextException();\n\t\t}\n\t}\n",
    "98435": "\tstatic public void ShowWarnings(PrintWriter out, Connection theConnection) {\n\t    try {\n\t\t// GET CONNECTION WARNINGS\n\t\tSQLWarning warning = null;\n\n\t\tif (theConnection != null) {\n\t\t\tShowWarnings(out, theConnection.getWarnings());\n\t\t}\n\n\t\tif (theConnection != null) {\n\t\t\ttheConnection.clearWarnings();\n\t\t}\n\t    } catch (SQLException e) {\n\t\t\tShowSQLException(out, e);\n\t    }\n\t} // ShowWarnings\n",
    "98437": "\tstatic public void ShowWarnings(PrintWriter out, ResultSet rs) {\n\t    try {\n\t\t// GET RESULTSET WARNINGS\n\t\tSQLWarning warning = null;\n\n\t\tif (rs != null) {\n\t\t\tShowWarnings(out, rs.getWarnings());\n\t\t}\n\n\t\tif (rs != null) {\n\t\t\trs.clearWarnings();\n\t\t}\n\t    } catch (SQLException e) {\n\t\t\tShowSQLException(out, e);\n\t    }\n\t} // ShowResultSetWarnings\n",
    "98454": "  final public ijResult SetConnectionStatement() throws ParseException, SQLException {\n        String t;\n    jj_consume_token(SET);\n    jj_consume_token(CONNECTION);\n    t = identifier();\n                if (!currentConnEnv.haveSession(t)) {\n                        {if (true) throw ijException.noSuchConnection(t);}\n                }\n                currentConnEnv.setCurrentSession(t);\n                theConnection = currentConnEnv.getConnection();\n                {if (true) return new ijConnectionResult(theConnection);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98459": "  final public ijResult ShowConnectionsStatement() throws ParseException, SQLException {\n    jj_consume_token(SHOW);\n    jj_consume_token(CONNECTIONS);\n                {if (true) return showConnectionsMethod(false);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98460": "\tstatic public String mapNull(String s, String nullValue) {\n\t\tif (s==null) return nullValue;\n\t\treturn s;\n\t}\n",
    "98463": "\tstatic public void doTrace(PrintWriter out, Exception e) {\n\t\tif (Boolean.getBoolean(\"ij.exceptionTrace\")) {\n\t\t\te.printStackTrace(out);\n\t\t    out.flush();\n\t\t}\n\t}\n",
    "98466": "  final public ijResult CommitStatement() throws ParseException, SQLException {\n    jj_consume_token(COMMIT);\n    if (jj_2_67(2)) {\n      jj_consume_token(WORK);\n    } else {\n      ;\n    }\n                haveConnection();\n                theConnection.commit();\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98474": "  final public ijResult RollbackStatement() throws ParseException, SQLException {\n    jj_consume_token(ROLLBACK);\n    if (jj_2_68(2)) {\n      jj_consume_token(WORK);\n    } else {\n      ;\n    }\n                haveConnection();\n                theConnection.rollback();\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98587": "    public void shutdown() {\n\ttry{\n\t    for(int i=0;i<sockets.size();i++) {\n\t\t(datain.get(i)).close();\n\t\t(dataout.get(i)).close();\n\t\t(sockets.get(i)).close();\n\t\tSystem.out.println(\"Socket closed\");\n\t    } // end for\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Problem shutting down\");\n\t    System.out.println(e);\n\t} // end catch\n    } // end shutdown\n",
    "98588": "    public boolean addServer(String IP) {\n\ttry {\n\t    sockets.add(new Socket(IP,port));\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Unable to connect to \"+IP+\":\"+port);\n\t    System.out.println(e);\n\t    return false;\n\t}// end catch\n\treturn true;\n    } // end addServer(String)\n",
    "98589": "    public void addDataStreams(int index) {\n\ttry {\n\t    dataout.add(new DataOutputStream((sockets.get(index)).getOutputStream()));\n\t    datain.add(new DataInputStream((sockets.get(index)).getInputStream()));\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Problem creating data streams\");\n\t    System.out.println(\"**** ADD CODE TO PROPERLY CLOSE STUFF HERE ****\");\n\t    System.out.println(e);\n\t} // end catch\n    } // end addDataStreams(int)\n",
    "98592": "    public void badCommand(String rcv, String exp) {\n\tSystem.out.println(\"Received \\\"\" + rcv + \"\\\"\");\n\tSystem.out.println(\"Expected \\\"\" + exp + \"\\\"\");\n    } // end badCommand(String,String)\n",
    "98593": "    public int checkOS() {\n\tif(System.getProperty(\"os.name\").toLowerCase().contains(\"linux\")) {\n\t    return 0;\n\t} // end if linux\n\tif(System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\n\t    return 1;\n\t}\n\treturn 2;\n    } // end checkOS()\n",
    "98596": "    public boolean lookForConnection() {\n\t/* Wait for client to connect */\n\tCSocket = null;\n\ttry {\n\t    CSocket = SSocket.accept();\n\t    System.out.println(\"CONNECTION ACCEPTED\");\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Unable to accept connection\");\n\t    System.out.println(e);\n\t    return false;\n\t} // end catch\n\n\t/* Add the data streams */\n\ttry {\n\t    din = new DataInputStream(CSocket.getInputStream());\n\t    dout = new DataOutputStream(CSocket.getOutputStream());\n\t    return true;\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Problem with Data Streams\");\n\t    System.out.println(e);\n\t    return false;\n\t} // end catch\n    } // end lookForConnection()\n",
    "98598": "    public void closeConnection() {\n\ttry {\n\t    din.close();\n\t    dout.close();\n\t    CSocket.close();\n\t    System.out.println(\"CSocket Closed\");\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Problem closing connection\");\n\t    System.out.println(e);\n\t} // end catch\n    } // end shutdown\n",
    "98599": "    public PointType getPoint() {\n        return point;\n    }\n",
    "98600": "    public void setPoint(PointType value) {\n        this.point = value;\n    }\n",
    "98611": "    public Pos getPos() {\n        return pos;\n    }\n",
    "98612": "    public void setPos(Pos value) {\n        this.pos = value;\n    }\n",
    "98626": "    public void setPointMembers(List<PointMember> pointMembers) {\n        this.pointMembers = pointMembers;\n    }\n",
    "98639": "    public String getSrsName() {\n        return srsName;\n    }\n",
    "98640": "    public void setSrsName(String value) {\n        this.srsName = value;\n    }\n",
    "98650": "    public void set_Geometry(JAXBElement<? extends AbstractGeometryType> value) {\n        this.geometry = ((JAXBElement<? extends AbstractGeometryType> ) value);\n    }\n",
    "98662": "    public MultiCurveType getMultiCurve() {\n        return multiCurve;\n    }\n",
    "98663": "    public void setMultiCurve(MultiCurveType value) {\n        this.multiCurve = value;\n    }\n",
    "98675": "    public AbstractRingPropertyType getExterior() {\n        return exterior;\n    }\n",
    "98677": "    public void setExterior(AbstractRingPropertyType value) {\n        this.exterior = value;\n    }\n",
    "98681": "    public SurfaceInterpolationType getInterpolation() {\n        if (interpolation == null) {\n            return SurfaceInterpolationType.PLANAR;\n        } else {\n            return interpolation;\n        }\n    }\n",
    "98682": "    public void setInterpolation(SurfaceInterpolationType value) {\n        this.interpolation = value;\n    }\n",
    "98684": "    public void setInteriors(List<AbstractRingPropertyType> interiors) {\n        this.interiors = interiors;\n    }\n",
    "98698": "    public String getValue() {\n        return value;\n    }\n",
    "98699": "    public void setValue(String value) {\n        this.value = value;\n    }\n",
    "98701": "    public String getCodeSpace() {\n        return codeSpace;\n    }\n",
    "98702": "    public void setCodeSpace(String value) {\n        this.codeSpace = value;\n    }\n",
    "98732": "    public BoundedBy createBoundedBy() {\n        return new BoundedBy();\n    }\n",
    "98733": "    public LineStringSegmentType createLineStringSegmentType() {\n        return new LineStringSegmentType();\n    }\n",
    "98734": "    public MultiPointType createMultiPointType() {\n        return new MultiPointType();\n    }\n",
    "98735": "    public Segments createSegments() {\n        return new Segments();\n    }\n",
    "98737": "    public MultiSurfacePropertyType createMultiSurfacePropertyType() {\n        return new MultiSurfacePropertyType();\n    }\n",
    "98738": "    public PolygonPatchType createPolygonPatchType() {\n        return new PolygonPatchType();\n    }\n",
    "98739": "    public GeometryPropertyType createGeometryPropertyType() {\n        return new GeometryPropertyType();\n    }\n",
    "98740": "    public MeasureType createMeasureType() {\n        return new MeasureType();\n    }\n",
    "98741": "    public PointType createPointType() {\n        return new PointType();\n    }\n",
    "98742": "    public PolygonType createPolygonType() {\n        return new PolygonType();\n    }\n",
    "98743": "    public CurveType createCurveType() {\n        return new CurveType();\n    }\n",
    "98745": "    public PosList createPosList() {\n        return new PosList();\n    }\n",
    "98747": "    public AbstractRingPropertyType createAbstractRingPropertyType() {\n        return new AbstractRingPropertyType();\n    }\n",
    "98748": "    public PointMember createPointMember() {\n        return new PointMember();\n    }\n",
    "98750": "    public LineStringType createLineStringType() {\n        return new LineStringType();\n    }\n",
    "98751": "    public MultiCurvePropertyType createMultiCurvePropertyType() {\n        return new MultiCurvePropertyType();\n    }\n",
    "98752": "    public MultiSurfaceType createMultiSurfaceType() {\n        return new MultiSurfaceType();\n    }\n",
    "98753": "    public ReferenceType createReferenceType() {\n        return new ReferenceType();\n    }\n",
    "98754": "    public Patches createPatches() {\n        return new Patches();\n    }\n",
    "98755": "    public MultiPointPropertyType createMultiPointPropertyType() {\n        return new MultiPointPropertyType();\n    }\n",
    "98756": "    public MultiGeometryPropertyType createMultiGeometryPropertyType() {\n        return new MultiGeometryPropertyType();\n    }\n",
    "98757": "    public MultiCurveType createMultiCurveType() {\n        return new MultiCurveType();\n    }\n",
    "98759": "    public Pos createPos() {\n        return new Pos();\n    }\n",
    "98761": "    public SurfaceMember createSurfaceMember() {\n        return new SurfaceMember();\n    }\n",
    "98762": "    public SurfaceType createSurfaceType() {\n        return new SurfaceType();\n    }\n",
    "98765": "    public LinearRingType createLinearRingType() {\n        return new LinearRingType();\n    }\n",
    "98766": "    public AbstractFeatureBaseType createAbstractFeatureBaseType() {\n        return new AbstractFeatureBaseType();\n    }\n",
    "98767": "    public AbstractSurfaceType createAbstractSurfaceType() {\n        return new AbstractSurfaceType();\n    }\n",
    "98768": "    public Envelope createEnvelope() {\n        return new Envelope();\n    }\n",
    "98769": "    public Name createName() {\n        return new Name();\n    }\n",
    "98770": "    public CurveMember createCurveMember() {\n        return new CurveMember();\n    }\n",
    "98776": "  final public ijResult JBMSPreparedStatementExec() throws ParseException, SQLException {\n        Token s = null;\n    jj_consume_token(EXECUTE);\n    jj_consume_token(STATEMENT);\n    s = jj_consume_token(STRING);\n                {if (true) return executeImmediate(stringValue(s.image));}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98780": "    public String getType() {\n        if (type == null) {\n            return \"simple\";\n        } else {\n            return type;\n        }\n    }\n",
    "98781": "    public void setType(String value) {\n        this.type = value;\n    }\n",
    "98783": "    public String getHref() {\n        return href;\n    }\n",
    "98784": "    public void setHref(String value) {\n        this.href = value;\n    }\n",
    "98787": "    public String getRole() {\n        return role;\n    }\n",
    "98788": "    public void setRole(String value) {\n        this.role = value;\n    }\n",
    "98791": "    public String getArcrole() {\n        return arcrole;\n    }\n",
    "98792": "    public void setArcrole(String value) {\n        this.arcrole = value;\n    }\n",
    "98795": "    public void setTitle(String value) {\n        this.title = value;\n    }\n",
    "98796": "  final public ijResult F2KExecuteProcedure() throws ParseException, SQLException {\n        Token s = null;\n    jj_consume_token(EXECUTE);\n    jj_consume_token(PROCEDURE);\n    s = jj_consume_token(STRING);\n                haveConnection();\n\n                Statement       aStatement = theConnection.createStatement();\n                String          text = \"execute procedure \" + s;\n\n                aStatement.execute( text );\n\n                {if (true) return new ijStatementResult( aStatement,true );}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98798": "    public String getShow() {\n        return show;\n    }\n",
    "98799": "    public void setShow(String value) {\n        this.show = value;\n    }\n",
    "98801": "    public String getActuate() {\n        return actuate;\n    }\n",
    "98802": "    public void setActuate(String value) {\n        this.actuate = value;\n    }\n",
    "98816": "    public MultiSurfaceType getMultiSurface() {\n        return multiSurface;\n    }\n",
    "98817": "    public void setMultiSurface(MultiSurfaceType value) {\n        this.multiSurface = value;\n    }\n",
    "98842": "    public void setDescription(String value) {\n        this.description = value;\n    }\n",
    "98844": "  final public ijResult AsyncStatement() throws ParseException, SQLException {\n        Token s = null;\n        String n = null;\n    jj_consume_token(ASYNC);\n    n = identifier();\n    s = jj_consume_token(STRING);\n            {if (true) return executeAsync(stringValue(s.image), n);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98847": "    public String getId() {\n        return id;\n    }\n",
    "98848": "    public void setId(String value) {\n        this.id = value;\n    }\n",
    "98861": "    public void set_GeometricAggregate(JAXBElement<? extends AbstractGeometricAggregateType> value) {\n        this.geometricAggregate = ((JAXBElement<? extends AbstractGeometricAggregateType> ) value);\n    }\n",
    "98869": "  final public ijResult WaitForStatement() throws ParseException, SQLException {\n        Token s = null;\n        String n = null;\n    jj_consume_token(WAIT);\n    jj_consume_token(FOR);\n    n = identifier();\n                AsyncStatement as = currentConnEnv.getSession().getAsyncStatement(n);\n                if (as == null) {if (true) throw ijException.noSuchAsyncStatement(n);}\n                try {\n                    as.join(); // we wait for it to finish.\n                } catch (InterruptedException ie) {\n                        {if (true) throw ijException.waitInterrupted(ie);}\n                }\n                {if (true) return as.getResult();}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98893": "    public MultiPointType getMultiPoint() {\n        return multiPoint;\n    }\n",
    "98894": "  final public ijResult RemoveStatement() throws ParseException, SQLException {\n        String i;\n        PreparedStatement ps;\n    jj_consume_token(REMOVE);\n    i = identifier();\n                haveConnection();\n                Session s = currentConnEnv.getSession();\n                ps = (PreparedStatement) s.getPreparedStatement(i);\n                JDBCDisplayUtil.checkNotNull(ps,\"prepared statement \"+i);\n                ps.close();\n                s.removePreparedStatement(i);\n\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98895": "    public void setMultiPoint(MultiPointType value) {\n        this.multiPoint = value;\n    }\n",
    "98907": "    public void setSegments(Segments value) {\n        this.segments = value;\n    }\n",
    "98937": "    public void set_Surface(JAXBElement<? extends AbstractSurfaceType> value) {\n        this.surface = ((JAXBElement<? extends AbstractSurfaceType> ) value);\n    }\n",
    "98949": "    public Envelope getEnvelope() {\n        return envelope;\n    }\n",
    "98950": "    public void setEnvelope(Envelope value) {\n        this.envelope = value;\n    }\n",
    "98964": "    public void set_SurfacePatches(List<JAXBElement<? extends AbstractSurfacePatchType>> surfacePatches) {\n        this.surfacePatches = surfacePatches;\n    }\n",
    "98970": "  final public ijResult AutocommitStatement() throws ParseException, SQLException {\n        Token on=null;\n    jj_consume_token(AUTOCOMMIT);\n    if (jj_2_87(2)) {\n      on = jj_consume_token(ON);\n    } else if (jj_2_88(2)) {\n      jj_consume_token(OFF);\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n                haveConnection();\n                // REMIND: want to warn if unchanged?\n                theConnection.setAutoCommit((on==null?false:true));\n\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98975": "    public BoundedBy getBoundedBy() {\n        return boundedBy;\n    }\n",
    "98976": "    public void setBoundedBy(BoundedBy value) {\n        this.boundedBy = value;\n    }\n",
    "98988": "    public void setPatches(Patches value) {\n        this.patches = value;\n    }\n",
    "99000": "    public void set_Curve(JAXBElement<? extends AbstractCurveType> value) {\n        this.curve = ((JAXBElement<? extends AbstractCurveType> ) value);\n    }\n",
    "99004": "  final public ijResult NoHoldForConnectionStatement() throws ParseException, SQLException {\n        Token on=null;\n    jj_consume_token(NOHOLDFORCONNECTION);\n                haveConnection();\n                theConnection = utilInstance.setHoldability(theConnection, JDBC30Translation.CLOSE_CURSORS_AT_COMMIT);\n\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99013": "    public PosList getPosList() {\n        return posList;\n    }\n",
    "99014": "    public void setPosList(PosList value) {\n        this.posList = value;\n    }\n",
    "99016": "    public CurveInterpolationType getInterpolation() {\n        if (interpolation == null) {\n            return CurveInterpolationType.LINEAR;\n        } else {\n            return interpolation;\n        }\n    }\n",
    "99017": "    public void setInterpolation(CurveInterpolationType value) {\n        this.interpolation = value;\n    }\n",
    "99037": "  final public ijResult LocalizedDisplay() throws ParseException {\n        Token on=null;\n    jj_consume_token(LOCALIZEDDISPLAY);\n    if (jj_2_89(2)) {\n      on = jj_consume_token(ON);\n    } else if (jj_2_90(2)) {\n      jj_consume_token(OFF);\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n                LocalizedResource.enableLocalization((on==null?false:true));\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99057": "    public void setSurfaceMembers(List<SurfaceMember> surfaceMembers) {\n        this.surfaceMembers = surfaceMembers;\n    }\n",
    "99067": "  final public ijResult ReadOnlyStatement() throws ParseException, SQLException {\n        Token on=null;\n    jj_consume_token(READONLY);\n    if (jj_2_91(2)) {\n      on = jj_consume_token(ON);\n    } else if (jj_2_92(2)) {\n      jj_consume_token(OFF);\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n                haveConnection();\n                theConnection.setReadOnly((on==null?false:true));\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99085": "    public void setCurveMembers(List<CurveMember> curveMembers) {\n        this.curveMembers = curveMembers;\n    }\n",
    "99095": "    public double getValue() {\n        return value;\n    }\n",
    "99096": "    public void setValue(double value) {\n        this.value = value;\n    }\n",
    "99098": "    public String getUom() {\n        return uom;\n    }\n",
    "99099": "    public void setUom(String value) {\n        this.uom = value;\n    }\n",
    "99101": "  final public ijResult ElapsedTimeStatement() throws ParseException {\n        Token on=null;\n    jj_consume_token(ELAPSEDTIME);\n    if (jj_2_93(2)) {\n      on = jj_consume_token(ON);\n    } else if (jj_2_94(2)) {\n      jj_consume_token(OFF);\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n                elapsedTime = (on != null);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99137": "    public Pos getLowerCorner() {\n        return lowerCorner;\n    }\n",
    "99138": "    public void setLowerCorner(Pos value) {\n        this.lowerCorner = value;\n    }\n",
    "99139": "  final public ijResult MaximumDisplayWidthStatement() throws ParseException {\n        int       maxWidth;\n    jj_consume_token(MAXIMUMDISPLAYWIDTH);\n    maxWidth = intValue();\n                JDBCDisplayUtil.setMaxDisplayWidth(maxWidth);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99141": "    public Pos getUpperCorner() {\n        return upperCorner;\n    }\n",
    "99142": "    public void setUpperCorner(Pos value) {\n        this.upperCorner = value;\n    }\n",
    "99156": "    public LinearRingType getLinearRing() {\n        return linearRing;\n    }\n",
    "99157": "    public void setLinearRing(LinearRingType value) {\n        this.linearRing = value;\n    }\n",
    "99172": "    public void set_CurveSegments(List<JAXBElement<? extends AbstractCurveSegmentType>> curveSegments) {\n        this.curveSegments = curveSegments;\n    }\n",
    "99190": "\tpublic void applyRemark(TridasValue value) {\n\t\tTridasRemark remark = asTridasRemark();\n\n\t\t// first, remove any remarks\n\t\tremoveRemarkFromValue(remark, value);\n\t\t\n\t\t// add the remark\n\t\tvalue.getRemarks().add(remark);\n\t}\n",
    "99191": "\tpublic boolean isRemarkSet(TridasValue value) {\n\t\tTridasRemark remark = asTridasRemark();\n\t\t\n\t\tfor(TridasRemark aRemark : value.getRemarks()) {\t\n\t\t\tif(RemarkEquals.remarksEqual(remark, aRemark)) {\n\t\t\t\t// must test for special 'disabled override'\n\t\t\t\tif(aRemark.isSetInheritedCount() && aRemark.getInheritedCount() < 0)\n\t\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n",
    "99192": "\tpublic boolean isRemarkInherited(TridasValue value) {\n\t\tTridasRemark remark = asTridasRemark();\n\t\t\n\t\tfor(TridasRemark aRemark : value.getRemarks()) {\t\n\t\t\tif(RemarkEquals.remarksEqual(remark, aRemark)) {\n\t\t\t\t// get the inherited count from the remark associated with the value\n\t\t\t\treturn (aRemark.isSetInheritedCount() && aRemark.getInheritedCount() > 0) ? true : false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n",
    "99193": "\tpublic void overrideRemark(TridasValue value) {\n\t\tTridasRemark source = asTridasRemark();\n\t\t\n\t\t// create a copy of the remark, as we're going to be modifying it\n\t\tTridasRemark remark = (TridasRemark) source.createCopy();\n\t\tsource.copyTo(remark);\n\n\t\t// first, remove any remarks\n\t\tremoveRemarkFromValue(remark, value);\n\t\t\n\t\t// flag the new remark as disabled\n\t\tremark.setInheritedCount(-1);\n\t\t\n\t\t// add the remark\n\t\tvalue.getRemarks().add(remark);\n\t}\n",
    "99194": "\tpublic void removeRemark(TridasValue value) {\n\t\tremoveRemarkFromValue(asTridasRemark(), value);\n\t}\n",
    "99195": "\tprotected void removeRemarkFromValue(TridasRemark remark, TridasValue value) {\n\t\tListIterator<TridasRemark> remarkIterator = value.getRemarks().listIterator();\n\t\t\n\t\twhile(remarkIterator.hasNext()) {\n\t\t\tTridasRemark aRemark = remarkIterator.next();\n\t\t\t\n\t\t\tif(RemarkEquals.remarksEqual(remark, aRemark))\n\t\t\t\tremarkIterator.remove();\n\t\t}\n\t}\n",
    "99207": "    public void setName(String value) {\n        this.name = value;\n    }\n",
    "99213": "    public boolean isIsActive() {\n        return isActive;\n    }\n",
    "99214": "    public void setIsActive(boolean value) {\n        this.isActive = value;\n    }\n",
    "99230": "    public void setMeasurementVariables(List<ControlledVoc> measurementVariables) {\n        this.measurementVariables = measurementVariables;\n    }\n",
    "99242": "    public void setElementShapes(List<ControlledVoc> elementShapes) {\n        this.elementShapes = elementShapes;\n    }\n",
    "99254": "    public String getType() {\n        return type;\n    }\n",
    "99259": "    public String getObject() {\n        return object;\n    }\n",
    "99260": "    public void setObject(String value) {\n        this.object = value;\n    }\n",
    "99281": "    public void setDatingTypes(List<ControlledVoc> datingTypes) {\n        this.datingTypes = datingTypes;\n    }\n",
    "99295": "    public void setCoverageTemporals(List<ControlledVoc> coverageTemporals) {\n        this.coverageTemporals = coverageTemporals;\n    }\n",
    "99306": "    public WSISapwoodDictionary createWSISapwoodDictionary() {\n        return new WSISapwoodDictionary();\n    }\n",
    "99307": "    public WSIParam createWSIParam() {\n        return new WSIParam();\n    }\n",
    "99308": "    public WSIBox createWSIBox() {\n        return new WSIBox();\n    }\n",
    "99310": "    public WSIRequest createWSIRequest() {\n        return new WSIRequest();\n    }\n",
    "99311": "    public WSISearchParams createWSISearchParams() {\n        return new WSISearchParams();\n    }\n",
    "99312": "    public WSIRegionDictionary createWSIRegionDictionary() {\n        return new WSIRegionDictionary();\n    }\n",
    "99313": "    public WSISecurityUserDictionary createWSISecurityUserDictionary() {\n        return new WSISecurityUserDictionary();\n    }\n",
    "99314": "  final public ijResult HelpStatement() throws ParseException {\n    jj_consume_token(HELP);\n                Vector v = new Vector();\n\n                StringTokenizer st = new StringTokenizer(LocalizedResource.getMessage(\"IJ_HelpText\"), \"\\n\");\n                while (st.hasMoreTokens()) {\n                    v.addElement(st.nextToken());\n                }\n\n                {if (true) return new ijVectorResult(v,null);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99315": "    public WSIHeartwoodDictionary createWSIHeartwoodDictionary() {\n        return new WSIHeartwoodDictionary();\n    }\n",
    "99316": "    public WSIRootElement createWSIRootElement() {\n        return new WSIRootElement();\n    }\n",
    "99317": "    public WSINonce createWSINonce() {\n        return new WSINonce();\n    }\n",
    "99318": "    public WSIMessage createWSIMessage() {\n        return new WSIMessage();\n    }\n",
    "99319": "    public WSIBoxDictionary createWSIBoxDictionary() {\n        return new WSIBoxDictionary();\n    }\n",
    "99320": "    public WSIElementAuthenticityDictionary createWSIElementAuthenticityDictionary() {\n        return new WSIElementAuthenticityDictionary();\n    }\n",
    "99321": "    public WSIEntity createWSIEntity() {\n        return new WSIEntity();\n    }\n",
    "99322": "    public WSIHelp createWSIHelp() {\n        return new WSIHelp();\n    }\n",
    "99323": "    public WSIHeader createWSIHeader() {\n        return new WSIHeader();\n    }\n",
    "99324": "    public WSILocationTypeDictionary createWSILocationTypeDictionary() {\n        return new WSILocationTypeDictionary();\n    }\n",
    "99325": "    public WSIAuthenticate createWSIAuthenticate() {\n        return new WSIAuthenticate();\n    }\n",
    "99326": "    public WSIElementTypeDictionary createWSIElementTypeDictionary() {\n        return new WSIElementTypeDictionary();\n    }\n",
    "99327": "    public WSILink createWSILink() {\n        return new WSILink();\n    }\n",
    "99328": "    public WSISampleTypeDictionary createWSISampleTypeDictionary() {\n        return new WSISampleTypeDictionary();\n    }\n",
    "99329": "    public WSIElementShapeDictionary createWSIElementShapeDictionary() {\n        return new WSIElementShapeDictionary();\n    }\n",
    "99330": "    public WSIReadingNoteDictionary createWSIReadingNoteDictionary() {\n        return new WSIReadingNoteDictionary();\n    }\n",
    "99331": "    public WSIDatingTypeDictionary createWSIDatingTypeDictionary() {\n        return new WSIDatingTypeDictionary();\n    }\n",
    "99332": "    public WSICoverageTemporalFoundationDictionary createWSICoverageTemporalFoundationDictionary() {\n        return new WSICoverageTemporalFoundationDictionary();\n    }\n",
    "99333": "    public WSITaxonDictionary createWSITaxonDictionary() {\n        return new WSITaxonDictionary();\n    }\n",
    "99335": "    public WSIContent createWSIContent() {\n        return new WSIContent();\n    }\n",
    "99336": "    public WSIMeasurementVariableDictionary createWSIMeasurementVariableDictionary() {\n        return new WSIMeasurementVariableDictionary();\n    }\n",
    "99337": "    public WSIObjectTypeDictionary createWSIObjectTypeDictionary() {\n        return new WSIObjectTypeDictionary();\n    }\n",
    "99338": "    public SecurityGroup createSecurityGroup() {\n        return new SecurityGroup();\n    }\n",
    "99339": "    public WSICoverageTemporalDictionary createWSICoverageTemporalDictionary() {\n        return new WSICoverageTemporalDictionary();\n    }\n",
    "99340": "    public SecurityUser createSecurityUser() {\n        return new SecurityUser();\n    }\n",
    "99342": "    public EntityType getType() {\n        return type;\n    }\n",
    "99343": "    public void setType(EntityType value) {\n        this.type = value;\n    }\n",
    "99360": "    public void setSqlsAndObjectsAndElements(List<Object> sqlsAndObjectsAndElements) {\n        this.sqlsAndObjectsAndElements = sqlsAndObjectsAndElements;\n    }\n",
    "99377": "    public TridasIdentifier getIdentifier() {\n        return identifier;\n    }\n",
    "99378": "    public void setIdentifier(TridasIdentifier value) {\n        this.identifier = value;\n    }\n",
    "99380": "    public DateTime getCreatedTimestamp() {\n        return createdTimestamp;\n    }\n",
    "99382": "    public void setCreatedTimestamp(DateTime value) {\n        this.createdTimestamp = value;\n    }\n",
    "99384": "    public DateTime getLastModifiedTimestamp() {\n        return lastModifiedTimestamp;\n    }\n",
    "99385": "    public void setLastModifiedTimestamp(DateTime value) {\n        this.lastModifiedTimestamp = value;\n    }\n",
    "99388": "    public String getComments() {\n        return comments;\n    }\n",
    "99389": "    public void setComments(String value) {\n        this.comments = value;\n    }\n",
    "99391": "    public String getTrackingLocation() {\n        return trackingLocation;\n    }\n",
    "99393": "    public void setTrackingLocation(String value) {\n        this.trackingLocation = value;\n    }\n",
    "99396": "    public String getCurationLocation() {\n        return curationLocation;\n    }\n",
    "99397": "    public void setCurationLocation(String value) {\n        this.curationLocation = value;\n    }\n",
    "99399": "    public Integer getSampleCount() {\n        return sampleCount;\n    }\n",
    "99400": "    public void setSampleCount(Integer value) {\n        this.sampleCount = value;\n    }\n",
    "99405": "    public void setSamples(List<TridasSample> samples) {\n        this.samples = samples;\n    }\n"
}
